<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员黄小斜</title>
  
  <subtitle>Java技术江湖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-24T08:03:23.992Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄小斜学Java</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java网络编程与NIO详解10：深度解读Tomcat中的NIO模型</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E8%AF%A6%E8%A7%A310%EF%BC%9A%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BBTomcat%E4%B8%AD%E7%9A%84NIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程与NIO详解10：深度解读Tomcat中的NIO模型/</id>
    <published>2019-12-13T15:20:43.000Z</published>
    <updated>2021-11-24T08:03:23.992Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转自：<a href="http://www.sohu.com/a/203838233_827544" target="_blank" rel="noopener">http://www.sohu.com/a/203838233_827544</a></p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><blockquote><p>摘要: I/O复用模型，是同步非阻塞，这里的非阻塞是指I/O读写，对应的是recvfrom操作，因为数据报文已经准备好，无需阻塞。</p></blockquote><p>说它是同步，是因为，这个执行是在一个线程里面执行的。有时候，还会说它又是阻塞的，实际上是指阻塞在select上面，必须等到读就绪、写就绪等网络事件。</p><h2 id="一、I-O复用模型解读"><a href="#一、I-O复用模型解读" class="headerlink" title="一、I/O复用模型解读"></a>一、I/O复用模型解读</h2><p>Tomcat的NIO是基于I/O复用来实现的。对这点一定要清楚，不然我们的讨论就不在一个逻辑线上。下面这张图学习过I/O模型知识的一般都见过，出自《UNIX网络编程》，I/O模型一共有阻塞式I/O，非阻塞式I/O，I/O复用(select/poll/epoll)，信号驱动式I/O和异步I/O。这篇文章讲的是I/O复用。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/0ab0b70be5a64b0e9014de867235da73.png" alt></p><p>IO复用.png</p><p>这里先来说下用户态和内核态，直白来讲，如果线程执行的是用户代码，当前线程处在用户态，如果线程执行的是内核里面的代码，当前线程处在内核态。更深层来讲，操作系统为代码所处的特权级别分了4个级别。</p><p>不过现代操作系统只用到了0和3两个级别。0和3的切换就是用户态和内核态的切换。更详细的可参照《深入理解计算机操作系统》。I/O复用模型，是同步非阻塞，这里的非阻塞是指I/O读写，对应的是recvfrom操作，因为数据报文已经准备好，无需阻塞。</p><p>说它是同步，是因为，这个执行是在一个线程里面执行的。有时候，还会说它又是阻塞的，实际上是指阻塞在select上面，必须等到读就绪、写就绪等网络事件。有时候我们又说I/O复用是多路复用，这里的多路是指N个连接，每一个连接对应一个channel，或者说多路就是多个channel。</p><p>复用，是指多个连接复用了一个线程或者少量线程(在Tomcat中是Math.min(2,Runtime.getRuntime().availableProcessors()))。</p><p>上面提到的网络事件有连接就绪，接收就绪，读就绪，写就绪四个网络事件。I/O复用主要是通过Selector复用器来实现的，可以结合下面这个图理解上面的叙述。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/3a18d371c9c848479ca39d8eb4e57ce4.jpeg" alt></p><p>Selector图解.png</p><h2 id="二、TOMCAT对IO模型的支持"><a href="#二、TOMCAT对IO模型的支持" class="headerlink" title="二、TOMCAT对IO模型的支持"></a>二、TOMCAT对IO模型的支持</h2><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/983c122c2a924e01b9f898279e2bd0b5.jpeg" alt></p><p>tomcat支持IO类型图.png</p><p>tomcat从6以后开始支持NIO模型，实现是基于JDK的java.nio包。这里可以看到对read body 和response body是Blocking的。关于这点在第6.3节源代码阅读有重点介绍。</p><h2 id="三、TOMCAT中NIO的配置与使用"><a href="#三、TOMCAT中NIO的配置与使用" class="headerlink" title="三、TOMCAT中NIO的配置与使用"></a>三、TOMCAT中NIO的配置与使用</h2><p>在Connector节点配置protocol=”org.apache.coyote.http11.Http11NioProtocol”，Http11NioProtocol协议下默认最大连接数是10000，也可以重新修改maxConnections的值，同时我们可以设置最大线程数maxThreads，这里设置的最大线程数就是Excutor的线程池的大小。</p><p>在BIO模式下实际上是没有maxConnections，即使配置也不会生效，BIO模式下的maxConnections是保持跟maxThreads大小一致，因为它是一请求一线程模式。</p><h2 id="四、NioEndpoint组件关系图解读"><a href="#四、NioEndpoint组件关系图解读" class="headerlink" title="四、NioEndpoint组件关系图解读"></a>四、NioEndpoint组件关系图解读</h2><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/4e1a924a60974c76ab5115007562e563.jpeg" alt></p><p>tomcatnio组成.png</p><p>我们要理解tomcat的nio最主要就是对NioEndpoint的理解。它一共包含LimitLatch、Acceptor、Poller、SocketProcessor、Excutor5个部分。</p><p>LimitLatch是连接控制器，它负责维护连接数的计算，nio模式下默认是10000，达到这个阈值后，就会拒绝连接请求。Acceptor负责接收连接，默认是1个线程来执行，将请求的事件注册到事件列表。</p><p>有Poller来负责轮询，Poller线程数量是cpu的核数Math.min(2,Runtime.getRuntime().availableProcessors())。由Poller将就绪的事件生成SocketProcessor同时交给Excutor去执行。Excutor线程池的大小就是我们在Connector节点配置的maxThreads的值。</p><p>在Excutor的线程中，会完成从socket中读取http request，解析成HttpServletRequest对象，分派到相应的servlet并完成逻辑，然后将response通过socket发回client。</p><p>在从socket中读数据和往socket中写数据的过程，并没有像典型的非阻塞的NIO的那样，注册OP_READ或OP_WRITE事件到主Selector，而是直接通过socket完成读写，这时是阻塞完成的，但是在timeout控制上，使用了NIO的Selector机制，但是这个Selector并不是Poller线程维护的主Selector，而是BlockPoller线程中维护的Selector，称之为辅Selector。详细源代码可以参照 第6.3节。</p><h2 id="五、NioEndpoint执行序列图"><a href="#五、NioEndpoint执行序列图" class="headerlink" title="五、NioEndpoint执行序列图"></a>五、NioEndpoint执行序列图</h2><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/d69c2ef5110d4706aa7284c616d62927.jpeg" alt></p><p>tomcatnio序列图.png</p><p>在下一小节NioEndpoint源码解读中我们将对步骤1-步骤11依次找到对应的代码来说明。</p><h2 id="六、NioEndpoint源码解读"><a href="#六、NioEndpoint源码解读" class="headerlink" title="六、NioEndpoint源码解读"></a>六、NioEndpoint源码解读</h2><p>6.1、初始化</p><p>无论是BIO还是NIO，开始都会初始化连接限制，不可能无限增大，NIO模式下默认是10000。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/332338f6d2c8488e9b35cd4fd76f078a.png" alt></p><p><strong>6.2、步骤解读</strong></p><p>下面我们着重叙述跟NIO相关的流程，共分为11个步骤，分别对应上面序列图中的步骤。</p><p><strong>步骤1</strong>：绑定IP地址及端口，将ServerSocketChannel设置为阻塞。</p><p>这里为什么要设置成阻塞呢，我们一直都在说非阻塞。Tomcat的设计初衷主要是为了操作方便。这样这里就跟BIO模式下一样了。只不过在BIO下这里返回的是</p><p>Socket，NIO下这里返回的是SocketChannel。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/ca01395590944a35b4717b15c984849e.png" alt></p><p><strong>步骤2</strong>：启动接收线程</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/e7c40dc6f84b48f4915ca854c2a3b2cc.png" alt></p><p><strong>步骤3</strong>：ServerSocketChannel.accept()接收新连接</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/50ddbfe042514ba29a8bcd606b125f76.jpeg" alt></p><p><strong>步骤4</strong>：将接收到的链接通道设置为非阻塞</p><p><strong>步骤5</strong>：构造NioChannel对象</p><p><strong>步骤6</strong>：register注册到轮询线程</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/f3f5130bcf7a4348bc9752bd009c1b72.png" alt></p><p><strong>步骤7</strong>：构造PollerEvent，并添加到事件队列</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/65de3c5cebea42c59ff19e8a168cf406.png" alt></p><p><strong>步骤8</strong>：启动轮询线程</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/5c097feaa2324a2da082a81287f9e862.png" alt></p><p><strong>步骤9</strong>：取出队列中新增的PollerEvent并注册到Selector</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/8ac5e80b9aa84f57b4c3f7ecd4e2ea1d.png" alt></p><p><strong>步骤10</strong>：Selector.select()</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/82d20de2a4614eab9fe14e58234db552.jpeg" alt></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/75641a4b8d444f8ab7a033bee9497c2b.png" alt></p><p><strong>步骤11</strong>：根据选择的SelectionKey构造SocketProcessor提交到请求处理线程</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/b8ec9bbcbdcd4088841741acb20152f8.png" alt></p><p><strong>6.3、NioBlockingSelector和BlockPoller介绍</strong></p><p>上面的序列图有个地方我没有描述，就是NioSelectorPool这个内部类，是因为在整体理解tomcat的nio上面在序列图里面不包括它更好理解。</p><p>在有了上面的基础后，我们在来说下NioSelectorPool这个类，对更深层了解Tomcat的NIO一定要知道它的作用。NioEndpoint对象中维护了一个NioSelecPool对象，这个NioSelectorPool中又维护了一个BlockPoller线程，这个线程就是基于辅Selector进行NIO的逻辑。</p><p>以执行servlet后，得到response，往socket中写数据为例，最终写的过程调用NioBlockingSelector的write方法。代码如下：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/4ac6ac8fdb0a4b24bdcb646a09cbb13e.jpeg" alt></p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/549283c8059b4e3c8798077b654dc3d1.png" alt></p><p>也就是说当socket.write()返回0时，说明网络状态不稳定，这时将socket注册OP_WRITE事件到辅Selector，由BlockPoller线程不断轮询这个辅Selector，直到发现这个socket的写状态恢复了，通过那个倒数计数器，通知Worker线程继续写socket动作。看一下BlockSelector线程的代码逻辑：</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/626817ca25fc4a439dbf5d23c2c08d0e.jpeg" alt></p><p>使用这个辅Selector主要是减少线程间的切换，同时还可减轻主Selector的负担。</p><h2 id="七、关于性能"><a href="#七、关于性能" class="headerlink" title="七、关于性能"></a>七、关于性能</h2><p>下面这份报告是我们压测的一个结果，跟想象的是不是不太一样？几乎没有差别，实际上NIO优化的是I/O的读写，如果瓶颈不在这里的话，比如传输字节数很小的情况下，BIO和NIO实际上是没有差别的。</p><p>NIO的优势更在于用少量的线程hold住大量的连接。还有一点，我们在压测的过程中，遇到在NIO模式下刚开始的一小段时间内容，会有错误，这是因为一般的压测工具是基于一种长连接，也就是说比如模拟1000并发，那么同时建立1000个连接，下一时刻再发送请求就是基于先前的这1000个连接来发送，还有TOMCAT的NIO处理是有POLLER线程来接管的，它的线程数一般等于CPU的核数，如果一瞬间有大量并发过来，POLLER也会顿时处理不过来。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/7d62f8792e1c41f090d945c755bba6c7.jpeg" alt></p><p>压测1.jpeg</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20171112/e8ec450685d64e5785db44a0bb60660c.jpeg" alt></p><p>压测2.jpeg</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>NIO只是优化了网络IO的读写，如果系统的瓶颈不在这里，比如每次读取的字节说都是500b，那么BIO和NIO在性能上没有区别。NIO模式是最大化压榨CPU，把时间片都更好利用起来。</p><p>对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源如内存，有关线程资源可参照这篇文章《一台java服务器可以跑多少个线程》。</p><p>因此，使用的线程越少越好。而I/O复用模型正是利用少量的线程来管理大量的连接。在对于维护大量长连接的应用里面更适合用基于I/O复用模型NIO，比如web qq这样的应用。所以我们要清楚系统的瓶颈是I/O还是CPU的计算</p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自：&lt;a href=&quot;http://www.sohu.com/a/203838233_827544&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sohu.com/a/203838233_827544&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解11：Tomcat中的Connector源码分析（NIO）</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E8%AF%A6%E8%A7%A311%EF%BC%9ATomcat%E4%B8%AD%E7%9A%84Connector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88NIO%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程与NIO详解11：Tomcat中的Connector源码分析（NIO）/</id>
    <published>2019-12-13T15:19:43.000Z</published>
    <updated>2021-11-24T08:03:23.992Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转载 <a href="https://www.javadoop.com" target="_blank" rel="noopener">https://www.javadoop.com</a></p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写了两篇关于 NIO 的文章，第一篇介绍了 NIO 的 Channel、Buffer、Selector 使用，第二篇介绍了非阻塞 IO 和异步 IO，并展示了简单的用例。</p><p>本文将介绍 Tomcat 中的 NIO 使用，使大家对 Java NIO 的生产使用有更加直观的认识。</p><p>虽然本文的源码篇幅也不短，但是 Tomcat 的源码毕竟不像 Doug Lea 的并发源码那么“变态”，对于大部分读者来说，阅读难度比之前介绍的其他并发源码要简单一些，所以读者不要觉得有什么压力。</p><p>本文基于 Tomcat 当前（2018-03-20）<strong>最新版本 9.0.6</strong>。</p><p>先简单画一张图示意一下本文的主要内容：</p><p><img src="https://www.javadoop.com/blogimages/tomcat-nio/0.png" alt="0"></p><p><strong>目录</strong></p><h2 id="源码环境准备"><a href="#源码环境准备" class="headerlink" title="源码环境准备"></a>源码环境准备</h2><p>Tomcat 9.0.6 下载地址：<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-90.cgi</a></p><p>由于上面下载的 tomcat 的源码并没有使用 maven 进行组织，不方便我们看源码，也不方便我们进行调试。这里我们将使用 maven 仓库中的 tomcat-embed-core，自己编写代码进行启动的方式来进行调试。</p><p>首先，创建一个空的 maven 工程，然后添加以下依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">    tomcat-embed-core</span><br><span class="line">    &lt;version&gt;9.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>上面的依赖，只会将 tomcat-embed-core-9.0.6.jar 和 tomcat-annotations-api-9.0.6.jar 两个包引进来，对于本文来说，已经足够了，如果你需要其他功能，需要额外引用其他的依赖，如 Jasper。</p></blockquote><p>然后，使用以下启动方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">   Tomcat tomcat = new Tomcat();</span><br><span class="line"></span><br><span class="line">   Connector connector = new Connector(&quot;HTTP/1.1&quot;);</span><br><span class="line">   connector.setPort(8080);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line"></span><br><span class="line">   tomcat.start();</span><br><span class="line">   tomcat.getServer().await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上的代码，我们的 Tomcat 就启动起来了。</p><blockquote><p>Tomcat 中的其他接口感兴趣的读者请自行探索，如设置 webapp 目录，设置 resources 等</p></blockquote><p>这里，介绍第一个重要的概念：<strong>Connector</strong>。在 Tomcat 中，使用 Connector 来处理连接，一个 Tomcat 可以配置多个 Connector，分别用于监听不同端口，或处理不同协议。</p><p>在 Connector 的构造方法中，我们可以传 <code>HTTP/1.1</code> 或 <code>AJP/1.3</code> 用于指定协议，也可以传入相应的协议处理类，毕竟协议不是重点，将不同端口进来的连接对应不同处理类才是正道。典型地，我们可以指定以下几个协议处理类：</p><ul><li>org.apache.coyote.http11.Http11NioProtocol：对应非阻塞 IO</li><li>org.apache.coyote.http11.Http11Nio2Protocol：对应异步 IO</li><li>org.apache.coyote.http2.Http2Protocol：对应 http2 协议，对 http2 感兴趣的读者，赶紧看起来吧。</li></ul><p>本文的重点当然是非阻塞 IO 了，之前已经介绍过<code>异步 IO</code>的基础知识了，读者看完本文后，如果对异步 IO 的处理流程感兴趣，可以自行去分析一遍。</p><blockquote><p>如果你使用 9.0 以前的版本，Tomcat 在启动的时候是会自动配置一个 connector 的，我们可以不用显示配置。</p><p>9.0 版本的 Tomcat#start() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; public void start() throws LifecycleException &#123;</span><br><span class="line">&gt;     getServer();</span><br><span class="line">&gt;     server.start();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>8.5 及之前版本的 Tomcat#start() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; public void start() throws LifecycleException &#123;</span><br><span class="line">&gt;     getServer();</span><br><span class="line">&gt;     // 自动配置一个使用非阻塞 IO 的 connector</span><br><span class="line">&gt;     getConnector();</span><br><span class="line">&gt;     server.start();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h2><p>前面我们说过一个 Connector 对应一个协议，当然这描述也不太对，NIO 和 NIO2 就都是处理 HTTP/1.1 的，只不过一个使用非阻塞，一个使用异步。进到指定 protocol 代码，我们就会发现，它们的代码及其简单，只不过是指定了特定的 <strong>endpoint</strong>。</p><p>打开 <code>Http11NioProtocol</code> 和 <code>Http11Nio2Protocol</code>源码，我们可以看到，在构造方法中，它们分别指定了 NioEndpoint 和 Nio2Endpoint。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 非阻塞模式</span><br><span class="line">public class Http11NioProtocol extends AbstractHttp11JsseProtocol&lt;NioChannel&gt; &#123;</span><br><span class="line">    public Http11NioProtocol() &#123;</span><br><span class="line">        // NioEndpoint</span><br><span class="line">        super(new NioEndpoint());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// 异步模式</span><br><span class="line">public class Http11Nio2Protocol extends AbstractHttp11JsseProtocol&lt;Nio2Channel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Http11Nio2Protocol() &#123;</span><br><span class="line">        // Nio2Endpoint</span><br><span class="line">        super(new Nio2Endpoint());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里介绍第二个重要的概念：<strong>endpoint</strong>。Tomcat 使用不同的 endpoint 来处理不同的协议请求，今天我们的重点是 <strong>NioEndpoint</strong>，其使用<strong>非阻塞 IO</strong> 来进行处理 HTTP/1.1 协议的请求。</p><p><strong>NioEndpoint</strong> 继承 =&gt; <strong>AbstractJsseEndpoint</strong> 继承 =&gt; <strong>AbstractEndpoint</strong>。中间的 AbstractJsseEndpoint 主要是提供了一些关于 <code>HTTPS</code> 的方法，这块我们暂时忽略它，后面所有关于 HTTPS 的我们都直接忽略，感兴趣的读者请自行分析。</p><h2 id="init-过程分析"><a href="#init-过程分析" class="headerlink" title="init 过程分析"></a>init 过程分析</h2><p>下面，我们看看从 tomcat.start() 一直到 NioEndpoint 的过程。</p><p><strong>1. AbstractProtocol</strong> # <strong>init</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void init() throws Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    endpoint.setName(endpointName.substring(1, endpointName.length()-1));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line">    // endpoint 的 name=http-nio-8089,domain=Tomcat</span><br><span class="line">    endpoint.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. AbstractEndpoint</strong> # <strong>init</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void init() throws Exception &#123;</span><br><span class="line">    if (bindOnInit) &#123;</span><br><span class="line">        bind(); // 这里对应的当然是子类 NioEndpoint 的 bind() 方法</span><br><span class="line">        bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. NioEndpoint</strong> # <strong>bind</strong></p><p>这里就到我们的 NioEndpoint 了，要使用到我们之前学习的 NIO 的知识了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void bind() throws Exception &#123;</span><br><span class="line">    // initServerSocket(); 原代码是这行，我们 “内联” 过来一起说</span><br><span class="line"></span><br><span class="line">    // 开启 ServerSocketChannel</span><br><span class="line">    serverSock = ServerSocketChannel.open();</span><br><span class="line">    socketProperties.setProperties(serverSock.socket());</span><br><span class="line"></span><br><span class="line">    // getPort() 会返回我们最开始设置的 8080，得到我们的 address 是 0.0.0.0:8080</span><br><span class="line">    InetSocketAddress addr = (getAddress()!=null?new InetSocketAddress(getAddress(),getPort()):new InetSocketAddress(getPort()));</span><br><span class="line"></span><br><span class="line">    // ServerSocketChannel 绑定地址、端口，</span><br><span class="line">    // 第二个参数 backlog 默认为 100，超过 100 的时候，新连接会被拒绝(不过源码注释也说了，这个值的真实语义取决于具体实现)</span><br><span class="line">    serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line"></span><br><span class="line">    // ※※※ 设置 ServerSocketChannel 为阻塞模式 ※※※</span><br><span class="line">    serverSock.configureBlocking(true);</span><br><span class="line"></span><br><span class="line">    // 设置 acceptor 和 poller 的数量，至于它们是什么角色，待会说</span><br><span class="line">    // acceptorThreadCount 默认为 1</span><br><span class="line">    if (acceptorThreadCount == 0) &#123;</span><br><span class="line">        // FIXME: Doesn&apos;t seem to work that well with multiple accept threads</span><br><span class="line">        // 作者想表达的意思应该是：使用多个 acceptor 线程并不见得性能会更好</span><br><span class="line">        acceptorThreadCount = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // poller 线程数，默认值定义如下，所以在多核模式下，默认为 2</span><br><span class="line">    // pollerThreadCount = Math.min(2,Runtime.getRuntime().availableProcessors());</span><br><span class="line">    if (pollerThreadCount &lt;= 0) &#123;</span><br><span class="line">        pollerThreadCount = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // </span><br><span class="line">    setStopLatch(new CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    // 初始化 ssl，我们忽略 ssl</span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    // 打开 NioSelectorPool，先忽略它</span><br><span class="line">    selectorPool.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ServerSocketChannel 已经打开，并且绑定要了之前指定的 8080 端口，设置成了<strong>阻塞模式</strong>。</li><li>设置了 acceptor 的线程数为 1</li><li>设置了 poller 的线程数，单核 CPU 为 1，多核为 2</li><li>打开了一个 SelectorPool，我们先忽略这个</li></ol><p>到这里，我们还不知道 Acceptor 和 Poller 是什么东西，我们只是设置了它们的数量，我们先来看看最后面提到的 SelectorPool。</p><h2 id="start-过程分析"><a href="#start-过程分析" class="headerlink" title="start 过程分析"></a>start 过程分析</h2><p>刚刚我们分析完了 init() 过程，下面是启动过程 start() 分析。</p><p>AbstractProtocol # start</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void start() throws Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 调用 endpoint 的 start 方法</span><br><span class="line">    endpoint.start();</span><br><span class="line"></span><br><span class="line">    // Start async timeout thread</span><br><span class="line">    asyncTimeout = new AsyncTimeout();</span><br><span class="line">    Thread timeoutThread = new Thread(asyncTimeout, getNameInternal() + &quot;-AsyncTimeout&quot;);</span><br><span class="line">    int priority = endpoint.getThreadPriority();</span><br><span class="line">    if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">        priority = Thread.NORM_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutThread.setPriority(priority);</span><br><span class="line">    timeoutThread.setDaemon(true);</span><br><span class="line">    timeoutThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractEndpoint # start</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final void start() throws Exception &#123;</span><br><span class="line">    // 按照我们的流程，刚刚 init 的时候，已经把 bindState 改为 BindState.BOUND_ON_INIT 了，</span><br><span class="line">    // 所以下面的 if 分支我们就不进去了</span><br><span class="line">    if (bindState == BindState.UNBOUND) &#123;</span><br><span class="line">        bind();</span><br><span class="line">        bindState = BindState.BOUND_ON_START;</span><br><span class="line">    &#125;</span><br><span class="line">    // 往里看 NioEndpoint 的实现</span><br><span class="line">    startInternal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个方法还是比较重要的，这里会创建前面说过的 acceptor 和 poller。</p><p>NioEndpoint # startInternal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void startInternal() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    if (!running) &#123;</span><br><span class="line">        running = true;</span><br><span class="line">        paused = false;</span><br><span class="line"></span><br><span class="line">        // 以下几个是缓存用的，之后我们也会看到很多这样的代码，为了减少 new 很多对象出来</span><br><span class="line">        processorCache = new SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getProcessorCache());</span><br><span class="line">        eventCache = new SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                        socketProperties.getEventCache());</span><br><span class="line">        nioChannels = new SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">        // 创建【工作线程池】，Tomcat 自己包装了一下 ThreadPoolExecutor，</span><br><span class="line">        // 1\. 为了在创建线程池以后，先启动 corePoolSize 个线程(这个属于线程池的知识了，不熟悉的读者可以看看我之前的文章)</span><br><span class="line">        // 2\. 自己管理线程池的增长方式（默认 corePoolSize 10, maxPoolSize 200），不是本文重点，不分析</span><br><span class="line">        if ( getExecutor() == null ) &#123;</span><br><span class="line">            createExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置一个栅栏（tomcat 自定义了类 LimitLatch），控制最大的连接数，默认是 10000</span><br><span class="line">        initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">        // 开启 poller 线程</span><br><span class="line">        // 还记得之前 init 的时候，默认地设置了 poller 的数量为 2，所以这里启动 2 个 poller 线程</span><br><span class="line">        pollers = new Poller[getPollerThreadCount()];</span><br><span class="line">        for (int i=0; i&lt;pollers.length; i++) &#123;</span><br><span class="line">            pollers[i] = new Poller();</span><br><span class="line">            Thread pollerThread = new Thread(pollers[i], getName() + &quot;-ClientPoller-&quot;+i);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(true);</span><br><span class="line">            pollerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 开启 acceptor 线程，和开启 poller 线程组差不多。</span><br><span class="line">        // init 的时候，默认地，acceptor 的线程数是 1</span><br><span class="line">        startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们启动了<strong>工作线程池</strong>、 <strong>poller 线程组</strong>、<strong>acceptor 线程组</strong>。同时，工作线程池初始就已经启动了 10 个线程。我们用 <strong>jconsole</strong> 来看看此时的线程，请看下图：</p><p><img src="https://www.javadoop.com/blogimages/tomcat-nio/1.png" alt="1"></p><p>从 jconsole 中，我们可以看到，此时启动了 BlockPoller、worker、poller、acceptor、AsyncTimeout，大家应该都已经清楚了每个线程是哪里启动的吧。</p><blockquote><p>Tomcat 中并没有 Worker 这个类，此名字是我瞎编。</p></blockquote><p>此时，我们还是不知道 acceptor、poller 甚至 worker 到底是干嘛的，下面，我们从 acceptor 线程开始看起。</p><h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>它的结构非常简单，在构造函数中，已经把 endpoint 传进来了，此外就只有 threadName 和 state 两个简单的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final AbstractEndpoint&lt;?,U&gt; endpoint;</span><br><span class="line">private String threadName;</span><br><span class="line">protected volatile AcceptorState state = AcceptorState.NEW;</span><br><span class="line"></span><br><span class="line">public Acceptor(AbstractEndpoint&lt;?,U&gt; endpoint) &#123;</span><br><span class="line">    this.endpoint = endpoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>threadName</strong> 就是一个线程名字而已，Acceptor 的状态 <strong>state</strong> 主要是随着 endpoint 来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum AcceptorState &#123;</span><br><span class="line">    NEW, RUNNING, PAUSED, ENDED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接来看 acceptor 的 run 方法吧：</p><p>Acceptor # run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">    int errorDelay = 0;</span><br><span class="line"></span><br><span class="line">    // 只要 endpoint 处于 running，这里就一直循环</span><br><span class="line">    while (endpoint.isRunning()) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果 endpoint 处于 pause 状态，这边 Acceptor 用一个 while 循环将自己也挂起</span><br><span class="line">        while (endpoint.isPaused() &amp;&amp; endpoint.isRunning()) &#123;</span><br><span class="line">            state = AcceptorState.PAUSED;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // Ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // endpoint 结束了，Acceptor 自然也要结束嘛</span><br><span class="line">        if (!endpoint.isRunning()) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果此时达到了最大连接数(之前我们说过，默认是10000)，就等待</span><br><span class="line">            endpoint.countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">            // Endpoint might have been paused while waiting for latch</span><br><span class="line">            // If that is the case, don&apos;t accept new connections</span><br><span class="line">            if (endpoint.isPaused()) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U socket = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 这里就是接收下一个进来的 SocketChannel</span><br><span class="line">                // 之前我们设置了 ServerSocketChannel 为阻塞模式，所以这边的 accept 是阻塞的</span><br><span class="line">                socket = endpoint.serverSocketAccept();</span><br><span class="line">            &#125; catch (Exception ioe) &#123;</span><br><span class="line">                // We didn&apos;t get a socket</span><br><span class="line">                endpoint.countDownConnection();</span><br><span class="line">                if (endpoint.isRunning()) &#123;</span><br><span class="line">                    // Introduce delay if necessary</span><br><span class="line">                    errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">                    // re-throw</span><br><span class="line">                    throw ioe;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // accept 成功，将 errorDelay 设置为 0</span><br><span class="line">            errorDelay = 0;</span><br><span class="line"></span><br><span class="line">            if (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line">                // setSocketOptions() 是这里的关键方法，也就是说前面千辛万苦都是为了能到这里进行处理</span><br><span class="line">                if (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                    // 如果上面的方法返回 false，关闭 SocketChannel</span><br><span class="line">                    endpoint.closeSocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 由于 endpoint 不 running 了，或者处于 pause 了，将此 SocketChannel 关闭</span><br><span class="line">                endpoint.destroySocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            String msg = sm.getString(&quot;endpoint.accept.fail&quot;);</span><br><span class="line">            // APR specific.</span><br><span class="line">            // Could push this down but not sure it is worth the trouble.</span><br><span class="line">            if (t instanceof Error) &#123;</span><br><span class="line">                Error e = (Error) t;</span><br><span class="line">                if (e.getError() == 233) &#123;</span><br><span class="line">                    // Not an error on HP-UX so log as a warning</span><br><span class="line">                    // so it can be filtered out on that platform</span><br><span class="line">                    // See bug 50273</span><br><span class="line">                    log.warn(msg, t);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    log.error(msg, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                    log.error(msg, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state = AcceptorState.ENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家应该发现了，Acceptor 绕来绕去，都是在调用 NioEndpoint 的方法，我们简单分析一下这个。</p><p>在 NioEndpoint init 的时候，我们开启了一个 ServerSocketChannel，后来 start 的时候，我们开启多个 acceptor（实际上，默认是 1 个），每个 acceptor 启动以后就开始循环调用 ServerSocketChannel 的 accept() 方法获取新的连接，然后调用 endpoint.setSocketOptions(socket) 处理新的连接，之后再进入循环 accept 下一个连接。</p><p>到这里，大家应该也就知道了，为什么这个叫 acceptor 了吧？接下来，我们来看看 setSocketOptions 方法到底做了什么。</p><p>NioEndpoint # setSocketOptions</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected boolean setSocketOptions(SocketChannel socket) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置该 SocketChannel 为非阻塞模式</span><br><span class="line">        socket.configureBlocking(false);</span><br><span class="line">        Socket sock = socket.socket();</span><br><span class="line">        // 设置 socket 的一些属性</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">        // 还记得 startInternal 的时候，说过了 nioChannels 是缓存用的。</span><br><span class="line">        // 限于篇幅，这里的 NioChannel 就不展开了，它包括了 socket 和 buffer</span><br><span class="line">        NioChannel channel = nioChannels.pop();</span><br><span class="line">        if (channel == null) &#123;</span><br><span class="line">            // 主要是创建读和写的两个 buffer，默认地，读和写 buffer 都是 8192 字节，8k</span><br><span class="line">            SocketBufferHandler bufhandler = new SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            if (isSSLEnabled()) &#123;</span><br><span class="line">                channel = new SecureNioChannel(socket, bufhandler, selectorPool, this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                channel = new NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            channel.setIOChannel(socket);</span><br><span class="line">            channel.reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // getPoller0() 会选取所有 poller 中的一个 poller</span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        try &#123;</span><br><span class="line">            log.error(&quot;&quot;,t);</span><br><span class="line">        &#125; catch (Throwable tt) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(tt);</span><br><span class="line">        &#125;</span><br><span class="line">        // Tell to close the socket</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这里又没有进行实际的处理，而是将这个 SocketChannel <strong>注册</strong>到了其中一个 poller 上。因为我们知道，acceptor 应该尽可能的简单，只做 accept 的工作，简单处理下就往后面扔。acceptor 还得回到之前的循环去 accept 新的连接呢。</p><p>我们只需要明白，此时，往 poller 中注册了一个 NioChannel 实例，此实例包含客户端过来的 SocketChannel 和一个 SocketBufferHandler 实例。</p><h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><p>之前我们看到 acceptor 将一个 NioChannel 实例 register 到了一个 poller 中。在看 register 方法之前，我们需要先对 poller 要有个简单的认识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Poller implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public Poller() throws IOException &#123;</span><br><span class="line">        // 每个 poller 开启一个 Selector</span><br><span class="line">        this.selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    // events 队列，此类的核心</span><br><span class="line">    private final SynchronizedQueue&lt;PollerEvent&gt; events =</span><br><span class="line">            new SynchronizedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private volatile boolean close = false;</span><br><span class="line">    private long nextExpiration = 0;//optimize expiration handling</span><br><span class="line"></span><br><span class="line">    // 这个值后面有用，记住它的初始值为 0</span><br><span class="line">    private AtomicLong wakeupCounter = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">    private volatile int keyCount = 0;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>敲重点：每个 poller 关联了一个 Selector。</p></blockquote><p>Poller 内部围着一个 events 队列转，来看看其 events() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean events() &#123;</span><br><span class="line">    boolean result = false;</span><br><span class="line"></span><br><span class="line">    PollerEvent pe = null;</span><br><span class="line">    for (int i = 0, size = events.size(); i &lt; size &amp;&amp; (pe = events.poll()) != null; i++ ) &#123;</span><br><span class="line">        result = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 逐个执行 event.run()</span><br><span class="line">            pe.run();</span><br><span class="line">            // 该 PollerEvent 还得给以后用，这里 reset 一下(还是之前说过的缓存)</span><br><span class="line">            pe.reset();</span><br><span class="line">            if (running &amp;&amp; !paused) &#123;</span><br><span class="line">                eventCache.push(pe);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch ( Throwable x ) &#123;</span><br><span class="line">            log.error(&quot;&quot;,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>events() 方法比较简单，就是取出当前队列中的 PollerEvent 对象，逐个执行 event.run() 方法。</p><p>然后，现在来看 Poller 的 run() 方法，该方法会一直循环，直到 poller.destroy() 被调用。</p><p>Poller # run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line"></span><br><span class="line">        boolean hasEvents = false;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (!close) &#123;</span><br><span class="line">                // 执行 events 队列中每个 event 的 run() 方法</span><br><span class="line">                hasEvents = events();</span><br><span class="line">                // wakeupCounter 的初始值为 0，这里设置为 -1</span><br><span class="line">                if (wakeupCounter.getAndSet(-1) &gt; 0) &#123;</span><br><span class="line">                    //if we are here, means we have other stuff to do</span><br><span class="line">                    //do a non blocking select</span><br><span class="line">                    keyCount = selector.selectNow();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // timeout 默认值 1 秒</span><br><span class="line">                    keyCount = selector.select(selectorTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeupCounter.set(0);</span><br><span class="line">            &#125;</span><br><span class="line">            // 篇幅所限，我们就不说 close 的情况了</span><br><span class="line">            if (close) &#123;</span><br><span class="line">                events();</span><br><span class="line">                timeout(0, false);</span><br><span class="line">                try &#123;</span><br><span class="line">                    selector.close();</span><br><span class="line">                &#125; catch (IOException ioe) &#123;</span><br><span class="line">                    log.error(sm.getString(&quot;endpoint.nio.selectorCloseFail&quot;), ioe);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable x) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(x);</span><br><span class="line">            log.error(&quot;&quot;,x);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //either we timed out or we woke up, process events first</span><br><span class="line">        // 这里没什么好说的，顶多就再执行一次 events() 方法</span><br><span class="line">        if ( keyCount == 0 ) hasEvents = (hasEvents | events());</span><br><span class="line"></span><br><span class="line">        // 如果刚刚 select 有返回 ready keys，进行处理</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">            keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;</span><br><span class="line">        // Walk through the collection of ready keys and dispatch</span><br><span class="line">        // any active event.</span><br><span class="line">        while (iterator != null &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey sk = iterator.next();</span><br><span class="line">            NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">            // Attachment may be null if another thread has called</span><br><span class="line">            // cancelledKey()</span><br><span class="line">            if (attachment == null) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                // ※※※※※ 处理 ready key ※※※※※</span><br><span class="line">                processKey(sk, attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//while</span><br><span class="line"></span><br><span class="line">        //process timeouts</span><br><span class="line">        timeout(keyCount,hasEvents);</span><br><span class="line">    &#125;//while</span><br><span class="line"></span><br><span class="line">    getStopLatch().countDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poller 的 run() 方法主要做了调用 events() 方法和处理注册到 Selector 上的 ready key，这里我们暂时不展开 processKey 方法，因为此方法必定是及其复杂的。</p><p>我们回过头来看之前从 acceptor 线程中调用的 register 方法。</p><p>Poller # register</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void register(final NioChannel socket) &#123;</span><br><span class="line">    socket.setPoller(this);</span><br><span class="line">    NioSocketWrapper ka = new NioSocketWrapper(socket, NioEndpoint.this);</span><br><span class="line">    socket.setSocketWrapper(ka);</span><br><span class="line">    ka.setPoller(this);</span><br><span class="line">    ka.setReadTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">    ka.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());</span><br><span class="line">    ka.setSecure(isSSLEnabled());</span><br><span class="line"></span><br><span class="line">    PollerEvent r = eventCache.pop();</span><br><span class="line">    ka.interestOps(SelectionKey.OP_READ);//this is what OP_REGISTER turns into.</span><br><span class="line"></span><br><span class="line">    // 注意第三个参数值 OP_REGISTER</span><br><span class="line">    if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);</span><br><span class="line">    else r.reset(socket,ka,OP_REGISTER);</span><br><span class="line"></span><br><span class="line">    // 添加 event 到 poller 中</span><br><span class="line">    addEvent(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将这个 socket（包含 socket 和 buffer 的 NioChannel 实例） 包装为一个 PollerEvent，然后添加到 events 中，此时调用此方法的 acceptor 结束返回，去处理新的 accepted 连接了。</p><p>接下来，我们已经知道了，poller 线程在循环过程中会不断调用 events() 方法，那么 PollerEvent 的 run() 方法很快就会被执行，我们就来看看刚刚这个新的连接被<strong>注册</strong>到这个 poller 后，会发生什么。</p><p>PollerEvent # run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // 对于新来的连接，前面我们说过，interestOps == OP_REGISTER</span><br><span class="line">    if (interestOps == OP_REGISTER) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 这步很关键！！！</span><br><span class="line">            // 将这个新连接 SocketChannel 注册到该 poller 的 Selector 中，</span><br><span class="line">            // 设置监听 OP_READ 事件，</span><br><span class="line">            // 将 socketWrapper 设置为 attachment 进行传递(这个对象可是什么鬼都有，往上看就知道了)</span><br><span class="line">            socket.getIOChannel().register(</span><br><span class="line">                    socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);</span><br><span class="line">        &#125; catch (Exception x) &#123;</span><br><span class="line">            log.error(sm.getString(&quot;endpoint.nio.registerFail&quot;), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* else 这块不介绍，省得大家头大 */</span><br><span class="line"></span><br><span class="line">        final SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">        try &#123;</span><br><span class="line">            if (key == null) &#123;</span><br><span class="line">                // The key was cancelled (e.g. due to socket closure)</span><br><span class="line">                // and removed from the selector while it was being</span><br><span class="line">                // processed. Count down the connections at this point</span><br><span class="line">                // since it won&apos;t have been counted down when the socket</span><br><span class="line">                // closed.</span><br><span class="line">                socket.socketWrapper.getEndpoint().countDownConnection();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final NioSocketWrapper socketWrapper = (NioSocketWrapper) key.attachment();</span><br><span class="line">                if (socketWrapper != null) &#123;</span><br><span class="line">                    //we are registering the key to start with, reset the fairness counter.</span><br><span class="line">                    int ops = key.interestOps() | interestOps;</span><br><span class="line">                    socketWrapper.interestOps(ops);</span><br><span class="line">                    key.interestOps(ops);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    socket.getPoller().cancelledKey(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (CancelledKeyException ckx) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                socket.getPoller().cancelledKey(key);</span><br><span class="line">            &#125; catch (Exception ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们再回顾一下：刚刚在 PollerEvent 的 run() 方法中，我们看到，新的 SocketChannel 注册到了 Poller 内部的 Selector 中，监听 OP_READ 事件，然后我们再回到 Poller 的 run() 看下，一旦该 SocketChannel 是 readable 的状态，那么就会进入到 poller 的 processKey 方法。</p><h2 id="processKey"><a href="#processKey" class="headerlink" title="processKey"></a>processKey</h2><p>Poller # processKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void processKey(SelectionKey sk, NioSocketWrapper attachment) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if ( close ) &#123;</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125; else if ( sk.isValid() &amp;&amp; attachment != null ) &#123;</span><br><span class="line">            if (sk.isReadable() || sk.isWritable() ) &#123;</span><br><span class="line">                // 忽略 sendfile</span><br><span class="line">                if ( attachment.getSendfileData() != null ) &#123;</span><br><span class="line">                    processSendfile(sk,attachment, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // unregister 相应的 interest set，</span><br><span class="line">                    // 如接下来是处理 SocketChannel 进来的数据，那么就不再监听该 channel 的 OP_READ 事件</span><br><span class="line">                    unreg(sk, attachment, sk.readyOps());</span><br><span class="line">                    boolean closeSocket = false;</span><br><span class="line">                    // Read goes before write</span><br><span class="line">                    if (sk.isReadable()) &#123;</span><br><span class="line">                        // 处理读</span><br><span class="line">                        if (!processSocket(attachment, SocketEvent.OPEN_READ, true)) &#123;</span><br><span class="line">                            closeSocket = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                        // 处理写</span><br><span class="line">                        if (!processSocket(attachment, SocketEvent.OPEN_WRITE, true)) &#123;</span><br><span class="line">                            closeSocket = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (closeSocket) &#123;</span><br><span class="line">                        cancelledKey(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //invalid key</span><br><span class="line">            cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(&quot;&quot;,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是 processSocket 方法，注意第三个参数，上面进来的时候是 true。</p><p>AbstractEndpoint # processSocket</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean processSocket(SocketWrapperBase&lt;S&gt; socketWrapper,</span><br><span class="line">        SocketEvent event, boolean dispatch) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (socketWrapper == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        if (sc == null) &#123;</span><br><span class="line">            // 创建一个 SocketProcessor 的实例</span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line">        Executor executor = getExecutor();</span><br><span class="line">        if (dispatch &amp;&amp; executor != null) &#123;</span><br><span class="line">            // 将任务放到之前建立的 worker 线程池中执行</span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sc.run(); // ps: 如果 dispatch 为 false，那么就当前线程自己执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RejectedExecutionException ree) &#123;</span><br><span class="line">        getLog().warn(sm.getString(&quot;endpoint.executor.fail&quot;, socketWrapper) , ree);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        // This means we got an OOM or similar creating a thread, or that</span><br><span class="line">        // the pool and its queue are full</span><br><span class="line">        getLog().error(sm.getString(&quot;endpoint.process.fail&quot;), t);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEndpoint # createSocketProcessor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected SocketProcessorBase&lt;NioChannel&gt; createSocketProcessor(</span><br><span class="line">        SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event) &#123;</span><br><span class="line">    return new SocketProcessor(socketWrapper, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，提交到 worker 线程池中的是 NioEndpoint.SocketProcessor 的实例，至于它的 run() 方法之后的逻辑，我们就不再继续往里分析了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，再祭出文章开始的那张图来总结一下：</p><p><img src="https://www.javadoop.com/blogimages/tomcat-nio/0.png" alt="0"></p><p>这里简单梳理下前面我们说的流程，帮大家回忆一下：</p><ol><li>指定 Protocol，初始化相应的 Endpoint，我们分析的是 NioEndpoint；</li><li>init 过程：在 NioEndpoint 中做 bind 操作；</li><li>start 过程：启动 worker 线程池，启动 1 个 Acceptor 和 2 个 Poller，当然它们都是默认值，可配；</li><li>Acceptor 获取到新的连接后，getPoller0() 获取其中一个 Poller，然后 register 到 Poller 中；</li><li>Poller 循环 selector.select(xxx)，如果有通道 readable，那么在 processKey 中将其放到 worker 线程池中。</li></ol><p>后续的流程，感兴趣的读者请自行分析，本文就说到这里了。</p><p>（全文完）</p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载 &lt;a href=&quot;https://www.javadoop.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.javadoop.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解9：基于NIO的网络编程框架Netty</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A39%EF%BC%9A%E5%9F%BA%E4%BA%8ENIO%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6Netty/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程和NIO详解9：基于NIO的网络编程框架Netty/</id>
    <published>2019-12-13T15:19:43.000Z</published>
    <updated>2021-11-24T08:03:23.999Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转自：<a href="https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/" target="_blank" rel="noopener">https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/</a></p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><h2 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h2><p><strong>Netty是一个基于异步与事件驱动的网络应用程序框架，它支持快速与简单地开发可维护的高性能的服务器与客户端。</strong></p><p>所谓<strong>事件驱动就是由通过各种事件响应来决定程序的流程</strong>，在Netty中到处都充满了异步与事件驱动，这种特点使得应用程序可以以任意的顺序响应在任意的时间点产生的事件，它带来了非常高的可伸缩性，让你的应用可以在需要处理的工作不断增长时，通过某种可行的方式或者扩大它的处理能力来适应这种增长。</p><p>Netty提供了高性能与易用性，它具有以下特点：</p><ul><li><p><strong>拥有设计良好且统一的API</strong>，支持NIO与OIO（阻塞IO）等多种传输类型，支持真正的无连接UDP Socket。</p></li><li><p><strong>简单而强大的线程模型</strong>，可高度定制线程（池）。(定制化的Reactor模型)</p></li><li><p><strong>良好的模块化与解耦</strong>，支持可扩展和灵活的事件模型，可以很轻松地分离关注点以复用逻辑组件（可插拔的）。</p></li><li><p><strong>性能高效</strong>，拥有比Java核心API更高的吞吐量，通过zero-copy功能以实现最少的内存复制消耗。</p></li><li><p><strong>内置了许多常用的协议编解码器</strong>，如HTTP、SSL、WebScoket等常见协议可以通过Netty做到开箱即用。用户也可以利用Netty简单方便地实现自己的应用层协议。</p></li></ul><p>大多数人使用Netty主要还是为了<strong>提高应用的性能</strong>，而高性能则离不开非阻塞IO。Netty的非阻塞IO是基于Java NIO的，并且对其进行了封装（直接使用Java NIO API在高复杂度下的应用中是一项非常繁琐且容易出错的操作，而Netty帮你封装了这些复杂操作）。</p><h2 id="etty简介"><a href="#etty简介" class="headerlink" title="etty简介"></a>etty简介</h2><pre>读完这一章，我们基本上可以了解到Netty所有重要的组件，对Netty有一个全面的认识，这对下一步深入学习Netty是十分重要的，而学完这一章，我们其实已经可以用Netty解决一些常规的问题了。</pre><h3 id="Netty都有哪些组件？"><a href="#Netty都有哪些组件？" class="headerlink" title="Netty都有哪些组件？"></a>Netty都有哪些组件？</h3><pre>为了更好的理解和进一步深入Netty，我们先总体认识一下Netty用到的组件及它们在整个Netty架构中是怎么协调工作的。Netty应用中必不可少的组件：</pre><ul><li><p>Bootstrap or ServerBootstrap</p></li><li><p>EventLoop</p></li><li><p>EventLoopGroup</p></li><li><p>ChannelPipeline</p></li><li><p>Channel</p></li><li><p>Future or ChannelFuture</p></li><li><p>ChannelInitializer</p></li><li><p>ChannelHandler</p></li><li><p>Bootstrap，一个Netty应用通常由一个Bootstrap开始，它主要作用是配置整个Netty程序，<strong>串联起各个组件</strong>。</p><p>Handler，为了支持各种协议和处理数据的方式，便诞生了Handler组件。Handler主要用来<strong>处理各种事件</strong>，这里的事件很广泛，比如可以是<strong>连接、数据接收、异常、数据转换</strong>等。</p><p><strong>ChannelInboundHandler</strong>，一个最常用的Handler。这个Handler的作用就是<strong>处理接收到数据</strong>时的事件，也就是说，我们的业务逻辑一般就是写在这个Handler里面的，ChannelInboundHandler就是用来处理我们的<strong>核心业务逻辑</strong>。</p><p>ChannelInitializer，当一个链接建立时，我们需要知道<strong>怎么来接收或者发送数据</strong>，当然，我们有各种各样的Handler实现来处理它，那么ChannelInitializer便是用来<strong>配置这些Handler，它会提供一个ChannelPipeline，并把Handler加入到ChannelPipeline。</strong></p><p>ChannelPipeline，一个Netty应用基于ChannelPipeline机制，这种机制需要<strong>依赖于EventLoop和EventLoopGroup，因为它们三个都和事件或者事件处理相关。</strong></p><p>EventLoops的目的是为Channel处理IO操作，一个EventLoop可以为多个Channel服务。</p><p>EventLoopGroup会包含多个EventLoop。</p><p>Channel代表了一个Socket链接，或者其它和IO操作相关的组件，它和EventLoop一起用来参与IO处理。</p><p>Future，在Netty中所有的IO操作都是<strong>异步的</strong>，因此，你<strong>不能立刻得知消息是否被正确处理</strong>，但是我们<strong>可以过一会等它执行完成或者直接注册一个监听</strong>，具体的实现就是通过Future和ChannelFutures,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之<strong>，所有的操作都会返回一个ChannelFuture</strong>。</p></li></ul><h3 id="Netty是如何处理连接请求和业务逻辑的呢？"><a href="#Netty是如何处理连接请求和业务逻辑的呢？" class="headerlink" title="Netty是如何处理连接请求和业务逻辑的呢？"></a>Netty是如何处理连接请求和业务逻辑的呢？</h3><p>Channels、Events 和 IO</p><p>Netty是一个<strong>非阻塞的、事件驱动的、网络编程</strong>框架。当然，我们很容易理解Netty会用线程来处理IO事件，对于熟悉多线程编程的人来说，你或许会想到如何同步你的代码，但是Netty不需要我们考虑这些，具体是这样：</p><p>一个Channel会对应一个EventLoop，而一个<strong>EventLoop会对应着一个线程</strong>，也就是说，仅有一个线程在负责一个Channel的IO操作。</p><p>关于这些名词之间的关系，可以见下图：</p><p><img src="https://img-blog.csdn.net/20140606104845234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>如图所示：当一个连接到达，Netty会注册一个channel，然后EventLoopGroup会<strong>分配一个EventLoop绑定到这个channel</strong>,在这个channel的整个生命周期过程中，都会由绑定的这个EventLoop来为它服务，而这个<strong>EventLoop就是一个线程</strong>。</p><p>说到这里，那么EventLoops和EventLoopGroups关系是如何的呢？我们前面说过一个EventLoopGroup包含多个Eventloop，但是我们看一下下面这幅图，这幅图是一个继承树，从这幅图中我们可以看出，EventLoop其实继承自EventloopGroup，也就是说，在某些情况下，我们可以把一个EventLoopGroup当做一个EventLoop来用。</p><pre>​</pre><p><a href="https://img-blog.csdn.net/20140606104919140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener"><img src="https://img-blog.csdn.net/20140606104919140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></a></p><h3 id="如何配置一个Netty应用？"><a href="#如何配置一个Netty应用？" class="headerlink" title="如何配置一个Netty应用？"></a>如何配置一个Netty应用？</h3><p>BootsStrapping</p><p>我们<strong>利用BootsStrap来配置netty 应用</strong>，它有两种类型，一种用于Client端：BootsStrap，另一种用于Server端：ServerBootstrap，要想区别如何使用它们，你仅需要记住一个用在Client端，一个用在Server端。下面我们来详细介绍一下这两种类型的区别：</p><p>1.第一个最明显的区别是，ServerBootstrap用于Server端，通过调用<strong>bind()</strong>方法来绑定到一个端口监听连接；Bootstrap用于Client端，需要调用<strong>connect</strong>()方法来连接服务器端，但我们也可以通过调用<strong>bind()方法返回的ChannelFuture</strong>中获取Channel从而去connect服务器端。</p><p>2.<strong>客户端</strong>的Bootstrap一般用<strong>一个EventLoopGroup</strong>，而<strong>服务器</strong>端的ServerBootstrap会用到<strong>两个</strong>（这两个也可以是同一个实例）。为何服务器端要用到两个EventLoopGroup呢？这么设计有明显的好处，如果一个ServerBootstrap有两个EventLoopGroup，那么就可以把<strong>第一个</strong>EventLoopGroup用来<strong>专门负责绑定到端口监听连接事件</strong>，而把<strong>第二个</strong>EventLoopGroup用来<strong>处理每个接收到的连接</strong>，下面我们用一幅图来展现一下这种模式：</p><p><img src="https://img-blog.csdn.net/20140606104949484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>PS: 如果仅由一个EventLoopGroup处理所有请求和连接的话，在并发量很大的情况下，这个EventLoopGroup有可能会忙于处理已经接收到的连接而不能及时处理新的连接请求，<strong>用两个的话</strong>，会有专门的线程来处理连接请求，不会导致请求超时的情况，大大<strong>提高了并发处理能力</strong>。</p><p>我们知道一个Channel需要由一个EventLoop来绑定，而且两者<strong>一旦绑定就不会再改变</strong>。一般情况下一个EventLoopGroup中的<strong>EventLoop数量会少于Channel数量</strong>，那么就很<strong>有可能出现一个多个Channel公用一个EventLoop</strong>的情况，这就意味着如果一个Channel中的<strong>EventLoop很忙</strong>的话，会<strong>影响</strong>到这个Eventloop<strong>对其它Channel的处理</strong>，<strong>这也就是为什么我们不能阻塞EventLoop的原因。</strong></p><p>当然，我们的Server也可以只用一个EventLoopGroup,由一个实例来处理连接请求和IO事件，请看下面这幅图：</p><p><img src="https://img-blog.csdn.net/20140606105016890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h3 id="Netty是如何处理数据的？"><a href="#Netty是如何处理数据的？" class="headerlink" title="Netty是如何处理数据的？"></a>Netty是如何处理数据的？</h3><p>Netty核心ChannelHandler</p><p>下面我们来看一下netty中是怎样处理数据的，回想一下我们前面讲到的Handler，对了，就是它。说到Handler我们就不得不提ChannelPipeline，ChannelPipeline负责<strong>安排Handler的顺序及其执行</strong>，下面我们就来详细介绍一下他们：</p><p>ChannelPipeline and handlers</p><p>我们的应用程序中用到的最多的应该就是ChannelHandler，我们可以这么想象，数据在一个ChannelPipeline中流动，而ChannelHandler便是其中的一个个的小阀门，这些数据都会经过每一个ChannelHandler并且被它处理。这里有一个公共接口ChannelHandler:</p><p><img src="https://img-blog.csdn.net/20140606105045406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>从上图中我们可以看到，ChannelHandler有两个子类ChannelInboundHandler和ChannelOutboundHandler，这两个类对应了两个数据流向，如果数据是<strong>从外部流入</strong>我们的应用程序，我们就看做是<strong>inbound</strong>，相反便是outbound。其实ChannelHandler和Servlet有些类似，一个ChannelHandler处理完接收到的数据会传给下一个Handler，或者什么不处理，直接传递给下一个。下面我们看一下ChannelPipeline是如何安排ChannelHandler的：</p><p><img src="https://img-blog.csdn.net/20140606105113171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VpZmVuZzMwNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>从上图中我们可以看到，<strong>一个ChannelPipeline可以把两种Handler（ChannelInboundHandler和ChannelOutboundHandler）混合在一起</strong>，当一个数据流进入ChannelPipeline时，它会从ChannelPipeline头部开始传给第一个ChannelInboundHandler，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的“最后”一个ChannelOutboundHandler，当它处理完成后会传递给前一个ChannelOutboundHandler。</p><p><strong>数据在各个Handler之间传递</strong>，这需要调用方法中传递的<strong>ChanneHandlerContext</strong>来操作， 在netty的API中提供了两个基类分<strong>ChannelOutboundHandlerAdapter</strong>和<strong>ChannelInboundHandlerAdapter</strong>，他们<strong>仅仅实现了调用ChanneHandlerContext来把消息传递给下一个Handler</strong>，因为我们只关心处理数据，因此我们的程序中<strong>可以继承这两个基类来帮助我们做这些</strong>，而<strong>我们仅需实现处理数据</strong>的部分即可。</p><p>我们知道InboundHandler和OutboundHandler在ChannelPipeline中是<strong>混合在一起</strong>的，那么它们<strong>如何区分</strong>彼此呢？其实很容易，因为<strong>它们各自实现的是不同的接口</strong>，对于inbound event，Netty会自动跳过OutboundHandler,相反若是outbound event，ChannelInboundHandler会被忽略掉。</p><p>当一个ChannelHandler被加入到ChannelPipeline中时，它便会获得一个ChannelHandlerContext的引用，而<strong>ChannelHandlerContext可以用来读写Netty中的数据流</strong>。因此，现在可以有两种方式来发送数据，一种是把数据直接写入Channel，一种是把数据写入ChannelHandlerContext，它们的区别是写入Channel的话，数据流会从Channel的头开始传递，而如果写入ChannelHandlerContext的话，数据流会流入管道中的下一个Handler。</p><h3 id="如何处理我们的业务逻辑？"><a href="#如何处理我们的业务逻辑？" class="headerlink" title="如何处理我们的业务逻辑？"></a>如何处理我们的业务逻辑？</h3><p>Encoders, Decoders and Domain Logic</p><p>Netty中会有很多Handler，具体是哪种Handler还要看它们继承的是InboundAdapter还是OutboundAdapter。当然，Netty中还提供了一些列的<strong>Adapter来帮助我们简化开发</strong>，我们知道在Channelpipeline中<strong>每一个Handler都负责把Event传递给下一个Handler</strong>，如果有了这些辅助Adapter，这些<strong>额外的工作都可自动完成</strong>，我们只需覆盖实现我们真正关心的部分即可。此外，还有一些Adapter会提供一些额外的功能，比如编码和解码。那么下面我们就来看一下其中的三种常用的ChannelHandler：</p><p>Encoders和Decoders</p><p>因为我们在网络传输时只能传输字节流，因此，在发送数据之前，我们必须把我们的message型转换为bytes，与之对应，我们在接收数据后，必须把接收到的bytes再转换成message。我们把bytes to message这个过程称作Decode(解码成我们可以理解的)，把message to bytes这个过程成为Encode。</p><p>Netty中提供了很多现成的编码/解码器，我们一般从他们的名字中便可知道他们的用途，如<strong>ByteToMessageDecoder</strong>、<strong>MessageToByteEncoder</strong>，如专门用来处理Google Protobuf协议的<strong>ProtobufEncoder</strong>、 <strong>ProtobufDecoder</strong>。</p><p>我们前面说过，具体是哪种Handler就要看它们继承的是InboundAdapter还是OutboundAdapter，对于<strong>Decoders</strong>,很容易便可以知道它是继承自<strong>ChannelInboundHandlerAdapter</strong>或 ChannelInboundHandler，因为解码的意思是把ChannelPipeline<strong>传入的bytes解码成我们可以理解的message</strong>（即Java Object），而ChannelInboundHandler正是处理Inbound Event，而Inbound Event中传入的正是字节流。Decoder会覆盖其中的“ChannelRead()”方法，在这个方法中来调用具体的decode方法解码传递过来的字节流，然后通过调用ChannelHandlerContext.fireChannelRead(decodedMessage)方法把编码好的Message传递给下一个Handler。与之类似，Encoder就不必多少了。</p><p>Domain Logic</p><p>其实我们最最关心的事情就是<strong>如何处理接收到的解码后的数据</strong>，我们真正的业务逻辑便是处理接收到的数据。Netty提供了一个最常用的基类<strong>SimpleChannelInboundHandler</strong><t>，其中<strong>T就是这个Handler处理的数据的类型</strong>（上一个Handler已经替我们解码好了），消息到达这个Handler时，Netty会自动调用这个Handler中的<strong>channelRead0</strong>(ChannelHandlerContext,T)方法，T是传递过来的数据对象，在这个方法中我们便可以任意写我们的业务逻辑了。</t></p><p>Netty从某方面来说就是一套NIO框架，在Java NIO基础上做了封装，所以要想学好Netty我建议先理解好Java NIO，</p><p>NIO可以称为New IO也可以称为Non-blocking IO，它比Java旧的阻塞IO在性能上要高效许多（如果让每一个连接中的IO操作都单独创建一个线程，那么阻塞IO并不会比NIO在性能上落后，但不可能创建无限多的线程，在连接数非常多的情况下会很糟糕）。</p><ul><li><p>ByteBuffer：NIO的数据传输是基于缓冲区的，ByteBuffer正是NIO数据传输中所使用的缓冲区抽象。<strong>ByteBuffer支持在堆外分配内存</strong>，并且尝试避免在执行I/O操作中的多余复制。一般的I/O操作都需要进行系统调用，这样会先切换到内核态，内核态要先从文件读取数据到它的缓冲区，只有等数据准备完毕后，才会从内核态把数据写到用户态，所谓的<strong>阻塞IO</strong>其实就是说的<strong>在等待数据准备好的这段时间内进行阻塞</strong>。如果想要避免这个额外的内核操作，可以通过使用mmap（虚拟内存映射）的方式来让用户态直接操作文件。</p></li><li><p>Channel：它类似于(fd)文件描述符，简单地来说它<strong>代表了一个实体</strong>（如一个硬件设备、文件、Socket或者一个能够执行一个或多个不同的I/O操作的程序组件）。你可以从一个Channel中读取数据到缓冲区，也可以将一个缓冲区中的数据写入到Channel。</p></li><li><p>Selector：选择器是NIO实现的关键，NIO采用的是I/O多路复用的方式来实现非阻塞，Selector通过在<strong>一个线程中监听每个Channel的IO事件来确定有哪些已经准备好进行IO操作的Channel</strong>，因此可<strong>以在任何时间检查任意的读操作或写操作的完成状态</strong>。这种方式<strong>避免了等待IO操作准备数据时的阻塞</strong>，使用较少的线程便可以处理许多连接，减少了线程切换与维护的开销。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1flys7n7hvaj20h90doglj.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1flys7n7hvaj20h90doglj.jpg" alt></a></p></li></ul><p>了解了NIO的实现思想之后，我觉得还很有必要了解一下Unix中的I/O模型，Unix中拥有以下5种I/O模型：</p><ul><li><p>阻塞I/O（Blocking I/O）</p></li><li><p>非阻塞I/O（Non-blocking I/O）</p></li><li><p>I/O多路复用（I/O multiplexing (select and poll)）</p></li><li><p>信号驱动I/O（signal driven I/O (SIGIO)）</p></li><li><p>异步I/O（asynchronous I/O (the POSIX aio_functions)）</p></li></ul><p><a href="http://wx3.sinaimg.cn/large/63503acbly1flz1e7kzblj20wb0ftq3l.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1flz1e7kzblj20wb0ftq3l.jpg" alt></a></p><p><img src="file:///C:/Users/xiaok/Pictures/%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87_%E5%8B%BF%E5%88%A0/%E6%AF%94%E7%89%B9%E6%88%AA%E5%9B%BE2019-01-12-16-40-18.png?lastModify=1549709160" alt></p><p>阻塞I/O模型是最常见的I/O模型，通常我们使用的InputStream/OutputStream都是基于阻塞I/O模型。在上图中，我们使用UDP作为例子，recvfrom()函数是UDP协议用于接收数据的函数，它需要<strong>使用系统调用并一直阻塞到内核将数据准备好</strong>，之后再由内核缓冲区复制数据到用户态（即是recvfrom()接收到数据），所谓<strong>阻塞就是在等待内核准备数据的这段时间内什么也不干</strong>。</p><p>举个生活中的例子，阻塞I/O就像是你去餐厅吃饭，在等待饭做好的时间段中，你只能在餐厅中坐着干等（如果你在玩手机那么这就是非阻塞I/O了）。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1flz1e8lh7rj20wb0ft0ty.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1flz1e8lh7rj20wb0ft0ty.jpg" alt></a></p><blockquote><p>在非阻塞I/O模型中，内核在<strong>数据尚未准备好</strong>的情况下回<strong>返回一个错误码<code>EWOULDBLOCK</code></strong>，而<strong>recvfrom</strong>并没有在失败的情况下选择阻塞休眠，而是<strong>不断地向内核询问是否已经准备完毕</strong>，在上图中，前三次内核都返回了<code>EWOULDBLOCK</code>，直到第四次询问时，内核数据准备完毕，然后开始将内核中缓存的数据复制到用户态。这种不断询问内核以查看某种状态是否完成的方式被称为<strong>polling（轮询）</strong>。</p></blockquote><p>非阻塞I/O就像是你在点外卖，只不过你非常心急，<strong>每隔一段时间就要打电话问外卖小哥有没有到</strong>。</p><p><a href="http://wx3.sinaimg.cn/large/63503acbly1flz1e989dfj20wh0g80tw.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1flz1e989dfj20wh0g80tw.jpg" alt></a></p><p>I/O多路复用的思想跟非阻塞I/O是一样的，只不过在<strong>非阻塞I/O</strong>中，是在<strong>recvfrom的用户态（或一个线程）中去轮询内核</strong>，这种方式会<strong>消耗大量的CPU时间</strong>。而<strong>I/O多路复用</strong>则是通过select()或poll()<strong>系统调用来负责进行轮询</strong>，以实现监听I/O读写事件的状态。如上图中，select监听到一个datagram可读时，就交由recvfrom去发送系统调用将内核中的数据复制到用户态。</p><p>这种方式的优点很明显，通过<strong>I/O多路复用</strong>可以<strong>监听多个文件描述符</strong>，且在<strong>内核中完成监控的任务</strong>。但缺点是至少需要两个系统调用（select()与recvfrom()）。</p><p>I/O多路复用同样适用于点外卖这个例子，只不过你在等外卖的期间完全可以做自己的事情，当外卖到的时候会<strong>通过外卖APP或者由外卖小哥打电话来通知你</strong>(因为内核会帮你轮询)。</p><p>Unix中提供了两种I/O多路复用函数，select()和poll()。select()的兼容性更好，但它在单个进程中所能监控的文件描述符是有限的，这个值与<code>FD_SETSIZE</code>相关，32位系统中默认为1024，64位系统中为2048。select()还有一个缺点就是他轮询的方式，它采取了<strong>线性扫描的轮询方式</strong>，每次都要遍历FD_SETSIZE个文件描述符，不管它们是否活不活跃的。poll()本质上与select()的实现<strong>没有区别</strong>，不过在数据结构上区别很大，用户必须分配一个pollfd结构数组，该数组维护在内核态中，正因如此，<strong>poll()并不像select()那样拥有大小上限的限制</strong>，但缺点同样也很明显，<strong>大量的fd数组会在用户态与内核态之间不断复制</strong>，不管这样的复制是否有意义。</p><p>还有一种比select()与poll()更加高效的实现叫做epoll()，它是由Linux内核2.6推出的可伸缩的I/O多路复用实现，目的是为了替代select()与poll()。epoll()同样<strong>没有文件描述符上限的限制</strong>，它<strong>使用一个文件描述符来管理多个文件描述符</strong>，并<strong>使用一个红黑树来作为存储结构</strong>。同时它还支持边缘触发（edge-triggered）与水平触发（level-triggered）两种模式（poll()只支持水平触发），在<strong>边缘触发模式</strong>下，<strong><code>epoll_wait</code>仅会在新的事件对象首次被加入到epoll时返回</strong>，而在<strong>水平触发</strong>模式下，<strong><code>epoll_wait</code>会在事件状态未变更前不断地触发</strong>。也就是说，边缘触发模式<strong>只会</strong>在文件描述符<strong>变为就绪状态时通知一次</strong>，水平触发模式会<strong>不断地通知</strong>该文件描述符<strong>直到被处理</strong>。</p><p>关于<code>epoll_wait</code>请参考如下epoll API。</p><pre>// 创建一个epoll对象并返回它的文件描述符。// 参数flags允许修改epoll的行为，它只有一个有效值EPOLL_CLOEXEC。int epoll_create1(int flags);// 配置对象，该对象负责描述监控哪些文件描述符和哪些事件。int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);// 等待与epoll_ctl注册的任何事件，直至事件发生一次或超时。// 返回在events中发生的事件，最多同时返回maxevents个。int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</pre><p>epoll另一亮点是<strong>采用了事件驱动的方式而不是轮询</strong>，在<strong>epoll_ctl</strong>中注册的文件描述符<strong>在事件触发的时候会通过一个回调机制</strong>来激活该文件描述符，<strong><code>epoll_wait</code>便可以收到通知</strong>。这样效率就不会与文件描述符的数量成正比</p><p>在Java NIO2（从JDK1.7开始引入）中，只要Linux内核版本在2.6以上，就会采用epoll，如下源码所示（DefaultSelectorProvider.java）。</p><pre>public static SelectorProvider create() {String osname = AccessController.doPrivileged(new GetPropertyAction("os.name"));if ("SunOS".equals(osname)) {return new sun.nio.ch.DevPollSelectorProvider();}// use EPollSelectorProvider for Linux kernels >= 2.6if ("Linux".equals(osname)) {String osversion = AccessController.doPrivileged(new GetPropertyAction("os.version"));String[] vers = osversion.split("\\.", 0);if (vers.length >= 2) {try {int major = Integer.parseInt(vers[0]);int minor = Integer.parseInt(vers[1]);if (major > 2 || (major == 2 && minor >= 6)) {return new sun.nio.ch.EPollSelectorProvider();}} catch (NumberFormatException x) {// format not recognized}}}return new sun.nio.ch.PollSelectorProvider();}</pre><p><a href="http://wx3.sinaimg.cn/large/63503acbly1flz1e9uk8aj20wb0ft3zn.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1flz1e9uk8aj20wb0ft3zn.jpg" alt></a></p><p>信号驱动I/O模型使用到了<strong>信号</strong>，内核在数据<strong>准备就绪</strong>时会<strong>通过信号来进行通知</strong>。我们首先<strong>开启</strong>了一个信号驱动I/O套接字，并使用sigaction系统调用来安装信号处理程序，内核直接返回，不会阻塞用户态。当datagram准备好时，内核会发送SIGIN信号，recvfrom接收到信号后会发送系统调用开始进行I/O操作。</p><p>这种模型的优点是<strong>主进程（线程）不会被阻塞</strong>，当数据准备就绪时，<strong>通过信号处理程序</strong>来通知主进程（线程）准备进行I/O操作与对数据的处理。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1flz1eai66rj20wb0g8aau.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1flz1eai66rj20wb0g8aau.jpg" alt></a></p><p>我们之前讨论的各种I/O模型无论是阻塞还是非阻塞，它们所说的<strong>阻塞都是指的数据准备阶段</strong>。<strong>异步I/O</strong>模型<strong>同样依赖</strong>于<strong>信号</strong>处理程序来进行通知，但与以上I/O模型都不相同的是，异步I/O模型通知的是<strong>I/O操作</strong>已经完成，而不是<strong>数据准备</strong>完成。</p><p>可以说<strong>异步I/O模型才是真正的非阻塞</strong>，主进程只管做自己的事情，然后在I/O操作完成时调用回调函数来完成一些对数据的处理操作即可。</p><p>闲扯了这么多，想必大家已经对I/O模型有了一个深刻的认识。之后，我们将会结合部分源码（Netty4.X）来探讨Netty中的各大核心组件，以及如何使用Netty，你会发现实现一个Netty程序是多么简单（而且还伴随了高性能与可维护性）。</p><p><img src="https://netty.io/images/components.png" alt></p><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><hr><p>网络传输的基本单位是字节，在Java NIO中提供了ByteBuffer作为字节缓冲区容器，但该类的API使用起来不太方便，所以Netty实现了ByteBuf作为其替代品，下面是使用ByteBuf的优点：</p><ul><li><p>相比ByteBuffer使用起来<strong>更加简单</strong>。</p></li><li><p>通过内置的复合缓冲区类型实现了透明的<strong>zero-copy</strong>。</p></li><li><p><strong>容量</strong>可以<strong>按需增长</strong>。</p></li><li><p><strong>读和写</strong>使用了<strong>不同的索引指针</strong>。</p></li><li><p>支持<strong>链式调用</strong>。</p></li><li><p>支持<strong>引用计数与池化</strong>。</p></li><li><p>可以被用户<strong>自定义的缓冲区类型</strong>扩展。</p></li></ul><p>在讨论ByteBuf之前，我们先需要了解一下ByteBuffer的实现，这样才能比较深刻地明白它们之间的区别。</p><p>ByteBuffer继承于<code>abstract class Buffer</code>（所以还有LongBuffer、IntBuffer等其他类型的实现），本质上它只是一个有限的线性的元素序列，包含了三个重要的属性。</p><ul><li><p>Capacity：缓冲区中元素的容量大小，你只能将capacity个数量的元素写入缓冲区，一旦缓冲区已满就需要清理缓冲区才能继续写数据。</p></li><li><p>Position：指向下一个写入数据位置的索引指针，初始位置为0，最大为capacity-1。当写模式转换为读模式时，position需要被重置为0。</p></li><li><p>Limit：在写模式中，limit是可以写入缓冲区的最大索引，也就是说它在写模式中等价于缓冲区的容量。在读模式中，limit表示可以读取数据的最大索引。</p></li></ul><p><a href="http://tutorials.jenkov.com/images/java-nio/buffers-modes.png" target="_blank" rel="noopener"><img src="http://tutorials.jenkov.com/images/java-nio/buffers-modes.png" alt></a></p><p>由于Buffer中只维护了position一个索引指针，所以它在读写模式之间的切换需要调用一个flip()方法来重置指针。使用Buffer的流程一般如下：</p><ul><li><p>写入数据到缓冲区。</p></li><li><p>调用flip()方法。</p></li><li><p>从缓冲区中读取数据</p></li><li><p>调用buffer.clear()或者buffer.compact()清理缓冲区，以便下次写入数据。</p></li></ul><pre>RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");FileChannel inChannel = aFile.getChannel();// 分配一个48字节大小的缓冲区ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); // 读取数据到缓冲区while (bytesRead != -1) {buf.flip(); // 将position重置为0while(buf.hasRemaining()){System.out.print((char) buf.get()); // 读取数据并输出到控制台}buf.clear(); // 清理缓冲区bytesRead = inChannel.read(buf);}aFile.close();Buffer中核心方法的实现也非常简单，主要就是在操作指针position。</pre><p>Buffer中核心方法的实现也非常简单，主要就是在操作指针position。</p><pre>/*** Sets this buffer's mark at its position.** @return This buffer*/public final Buffer mark() {mark = position; // mark属性是用来标记当前索引位置的return this;}// 将当前索引位置重置为mark所标记的位置public final Buffer reset() {int m = mark;if (m < 0)throw new InvalidMarkException();position = m;return this;}// 翻转这个Buffer，将limit设置为当前索引位置，然后再把position重置为0public final Buffer flip() {limit = position;position = 0;mark = -1;return this;}// 清理缓冲区// 说是清理,也只是把postion与limit进行重置,之后再写入数据就会覆盖之前的数据了public final Buffer clear() {position = 0;limit = capacity;mark = -1;return this;}// 返回剩余空间public final int remaining() {return limit - position;}</pre><p>Java NIO中的<strong>Buffer API操作的麻烦之处就在于读写转换需要手动重置指针。而ByteBuf没有这种繁琐性，它维护了两个不同的索引，一个用于读取，一个用于写入</strong>。当你从ByteBuf读取数据时，它的readerIndex将会被递增已经被读取的字节数，同样的，当你写入数据时，writerIndex则会递增。readerIndex的最大范围在writerIndex的所在位置，如果试图移动readerIndex超过该值则会触发异常。</p><p>ByteBuf中名称以read或write开头的方法将会递增它们其对应的索引，而名称以get或set开头的方法则不会。ByteBuf同样可以指定一个最大容量，试图移动writerIndex超过该值则会触发异常。</p><pre>public byte readByte() { this.checkReadableBytes0(1); // 检查readerIndex是否已越界 int i = this.readerIndex; byte b = this._getByte(i); this.readerIndex = i + 1; // 递增readerIndex return b;}private void checkReadableBytes0(int minimumReadableBytes) { this.ensureAccessible(); if(this.readerIndex > this.writerIndex - minimumReadableBytes) { throw new IndexOutOfBoundsException(String.format("readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s", new Object[]{Integer.valueOf(this.readerIndex), Integer.valueOf(minimumReadableBytes), Integer.valueOf(this.writerIndex), this})); }}public ByteBuf writeByte(int value) { this.ensureAccessible(); this.ensureWritable0(1); // 检查writerIndex是否会越过capacity this._setByte(this.writerIndex++, value); return this;}private void ensureWritable0(int minWritableBytes) { if(minWritableBytes > this.writableBytes()) { if(minWritableBytes > this.maxCapacity - this.writerIndex) { throw new IndexOutOfBoundsException(String.format("writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s", new Object[]{Integer.valueOf(this.writerIndex), Integer.valueOf(minWritableBytes), Integer.valueOf(this.maxCapacity), this})); } else { int newCapacity = this.alloc().calculateNewCapacity(this.writerIndex + minWritableBytes, this.maxCapacity); this.capacity(newCapacity); } }}// get与set只对传入的索引进行了检查，然后对其位置进行get或setpublic byte getByte(int index) { this.checkIndex(index); return this._getByte(index);}public ByteBuf setByte(int index, int value) { this.checkIndex(index); this._setByte(index, value); return this;}</pre><p>ByteBuf同样支持在<strong>堆内和堆外进行分配</strong>。在<strong>堆内分配</strong>也被称为<strong>支撑数组模式</strong>，它能在<strong>没有使用池化</strong>的情况下<strong>提供快速的分配和释放</strong>。</p><pre>ByteBuf heapBuf = Unpooled.copiedBuffer(bytes);if (heapBuf.hasArray()) { // 判断是否有一个支撑数组byte[] array = heapBuf.array();// 计算第一个字节的偏移量int offset = heapBuf.arrayOffset() + heapBuf.readerIndex();int length = heapBuf.readableBytes(); // 获得可读字节handleArray(array,offset,length); // 调用你的处理方法}</pre><p>另一种模式为<strong>堆外分配</strong>，Java NIO ByteBuffer类在JDK1.4时就已经允许JVM实现通过JNI调用来在堆外分配内存（调用malloc()函数在JVM堆外分配内存），这主要是<strong>为了避免额外的缓冲区复制操作</strong>。</p><pre>ByteBuf directBuf = Unpooled.directBuffer(capacity);if (!directBuf.hasArray()) {int length = directBuf.readableBytes();byte[] array = new byte[length];// 将字节复制到数组中directBuf.getBytes(directBuf.readerIndex(),array);handleArray(array,0,length);}</pre><p>ByteBuf还支持第三种模式，它被称为<strong>复合缓冲区</strong>，为多个ByteBuf<strong>提供</strong>了一个<strong>聚合视图</strong>。在这个视图中，你可以根据需要添加或者删除ByteBuf实例，ByteBuf的子类<strong>CompositeByteBuf实现了该模式</strong>。</p><p>一个适合使用<strong>复合缓冲区的场景是HTTP协议</strong>，通过HTTP协议传输的消息都会被分成两部分——头部和主体，如果这两部分由应用程序的不同模块产生，将在消息发送时进行组装，并且该应用程序还会为多个消息复用相同的消息主体，这样对于每个消息都将会创建一个新的头部，产生了很多不必要的内存操作。使用CompositeByteBuf是一个很好的选择，它消除了这些额外的复制，以帮助你复用这些消息。</p><pre>CompositeByteBuf messageBuf = Unpooled.compositeBuffer();ByteBuf headerBuf = ....;ByteBuf bodyBuf = ....;messageBuf.addComponents(headerBuf,bodyBuf);for (ByteBuf buf : messageBuf) {System.out.println(buf.toString());}</pre><p>CompositeByteBuf透明的实现了<strong>zero-copy</strong>，zero-copy其实就是避免数据在两个内存区域中来回的复制。从操作系统层面上来讲，zero-copy指的是<strong>避免在内核态与用户态之间的数据缓冲区复制（通过mmap避免）</strong>，而Netty中的zero-copy更偏向于在用户态中的数据操作的优化，就像使用CompositeByteBuf来复用多个ByteBuf以避免额外的复制，也可以使用wrap()方法来将一个字节数组包装成ByteBuf，又或者使用ByteBuf的slice()方法把它分割为多个共享同一内存区域的ByteBuf，这些都是为了优化内存的使用率。</p><p>那么如何创建ByteBuf呢？在上面的代码中使用到了<strong>Unpooled</strong>，它是Netty提供的一个用于创建与分配ByteBuf的工具类，建议都使用这个工具类来创建你的缓冲区，不要自己去调用构造函数。经常使用的是wrappedBuffer()与copiedBuffer()，它们一个是用于将一个字节数组或ByteBuffer包装为一个ByteBuf，一个是根据传入的字节数组与ByteBuffer/ByteBuf来复制出一个新的ByteBuf。</p><pre>// 通过array.clone()来复制一个数组进行包装public static ByteBuf copiedBuffer(byte[] array) {return array.length == 0?EMPTY_BUFFER:wrappedBuffer((byte[])array.clone());}// 默认是堆内分配public static ByteBuf wrappedBuffer(byte[] array) {return (ByteBuf)(array.length == 0?EMPTY_BUFFER:new UnpooledHeapByteBuf(ALLOC, array, array.length));}// 也提供了堆外分配的方法private static final ByteBufAllocator ALLOC;public static ByteBuf directBuffer(int initialCapacity) {return ALLOC.directBuffer(initialCapacity);}</pre><p>相对底层的分配方法是使用ByteBufAllocator，Netty实现了PooledByteBufAllocator和UnpooledByteBufAllocator，前者使用了<a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener">jemalloc（一种malloc()的实现）</a>来分配内存，并且实现了对ByteBuf的池化以提高性能。后者分配的是未池化的ByteBuf，其分配方式与之前讲的一致。</p><pre>Channel channel = ...;ByteBufAllocator allocator = channel.alloc();ByteBuf buffer = allocator.directBuffer();do something.......</pre><p>为了优化内存使用率，<strong>Netty提供了一套手动的方式来追踪不活跃对象</strong>，像UnpooledHeapByteBuf这种分配在堆内的对象得益于JVM的GC管理，无需额外操心，而UnpooledDirectByteBuf是在堆外分配的，它的内部基于DirectByteBuffer，DirectByteBuffer会先向Bits类申请一个额度（Bits还拥有一个全局变量totalCapacity，记录了所有DirectByteBuffer总大小），每次申请前都会查看是否已经超过-XX:MaxDirectMemorySize所设置的上限，<strong>如果超限就会尝试调用System.gc()</strong>，<strong>以试图回收一部分内存，然后休眠100毫秒，如果内存还是不足，则只能抛出OOM异常</strong>。堆外内存的回收虽然有了这么一层保障，但为了提高性能与使用率，主动回收也是很有必要的。由于Netty还实现了ByteBuf的池化，像PooledHeapByteBuf和PooledDirectByteBuf就必须<strong>依赖于手动的方式来进行回收</strong>（放回池中）。</p><p>Netty使用了<strong>引用计数器的方式来追踪那些不活跃的对象</strong>。引用计数的接口为<strong>ReferenceCounted</strong>，它的思想很简单，只要ByteBuf对象的<strong>引用计数大于0</strong>，就保证该对象<strong>不会被释放回收</strong>，可以通过<strong>手动调用release()与retain()</strong>方法来操作该对象的引用计数值<strong>递减或递增</strong>。用户也可以通过自定义一个ReferenceCounted的实现类，以满足自定义的规则。</p><pre>package io.netty.buffer;public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {// 由于ByteBuf的实例对象会非常多,所以这里没有将refCnt包装为AtomicInteger// 而是使用一个全局的AtomicIntegerFieldUpdater来负责操作refCntprivate static final AtomicIntegerFieldUpdater<abstractreferencecountedbytebuf> refCntUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");// 每个ByteBuf的初始引用值都为1private volatile int refCnt = 1;public int refCnt() {return this.refCnt;}protected final void setRefCnt(int refCnt) {this.refCnt = refCnt;}public ByteBuf retain() {return this.retain0(1);}// 引用计数值递增increment，increment必须大于0public ByteBuf retain(int increment) {return this.retain0(ObjectUtil.checkPositive(increment, "increment"));}public static int checkPositive(int i, String name) {if(i <= 0) { throw new illegalargumentexception(name + ": " i (expected:> 0)");} else {return i;} }// 使用CAS操作不断尝试更新值private ByteBuf retain0(int increment) {int refCnt;int nextCnt;do {refCnt = this.refCnt;nextCnt = refCnt + increment;if(nextCnt <= increment) { throw new illegalreferencecountexception(refcnt, increment); } while(!refcntupdater.compareandset(this, refcnt, nextcnt)); return this; public boolean release() this.release0(1); release(int decrement) this.release0(objectutil.checkpositive(decrement, "decrement")); private release0(int int refcnt; do refcnt="this.refCnt;" if(refcnt < -decrement); - decrement)); this.deallocate(); true; else false; protected abstract void deallocate(); pre><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><hr><p>Netty中的Channel与Java NIO的概念一样，都是对<strong>一个实体或连接的抽象</strong>，但<strong>Netty提供了一套更加通用的API</strong>。就以网络套接字为例，在Java中OIO与NIO是截然不同的两套API，假设你之前使用的是OIO而又想更改为NIO实现，那么几乎需要重写所有代码。而在Netty中，只需要更改短短几行代码（更改Channel与EventLoop的实现类，如把OioServerSocketChannel替换为NioServerSocketChannel），就可以完成OIO与NIO（或其他）之间的转换。</p><p><a href="http://wx2.sinaimg.cn/large/63503acbly1fm103i127ej20xe0f074y.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/large/63503acbly1fm103i127ej20xe0f074y.jpg" alt></a></p><p>每个Channel最终都会被分配一个<strong>ChannelPipeline</strong>和<strong>ChannelConfig</strong>，前者持有所有负责<strong>处理入站与出站数据</strong>以及<strong>事件</strong>的ChannelHandler，后者包含了该Channel的<strong>所有配置设置</strong>，并且<strong>支持热更新</strong>，由于不同的传输类型可能具有其特别的配置，所以该类可能会实现为ChannelConfig的不同子类。</p><p><strong>Channel是线程安全的</strong>（与之后要讲的线程模型有关），因此你完全可以在多个线程中复用同一个Channel，就像如下代码所示。</p><pre>final Channel channel = ...final ByteBuf buffer = Unpooled.copiedBuffer("Hello,World!", CharsetUtil.UTF_8).retain();Runnable writer = new Runnable() {@Overridepublic void run() {channel.writeAndFlush(buffer.duplicate());}};Executor executor = Executors.newCachedThreadPool();executor.execute(writer);executor.execute(writer);.......</pre><p>Netty除了支持常见的NIO与OIO，还内置了其他的传输类型。</p><table><thead><tr><th>Nmae</th><th>Package</th><th>Description</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>以Java NIO为基础实现</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>以java.net为基础实现，使用阻塞I/O模型</td></tr><tr><td>Epoll</td><td>io.netty.channel.epoll</td><td>由JNI驱动epoll()实现的更高性能的非阻塞I/O，它<strong>只能使用在Linux</strong></td></tr><tr><td>Local</td><td>io.netty.channel.local</td><td><strong>本地传输</strong>，在JVM内部通过<strong>管道</strong>进行通信</td></tr><tr><td>Embedded</td><td>io.netty.channel.embedded</td><td>允许在不需要真实网络传输的环境下使用ChannelHandler，主要用于对ChannelHandler进行<strong>测试</strong></td></tr></tbody></table><p>NIO、OIO、Epoll我们应该已经很熟悉了，下面主要说说Local与Embedded。</p><p>Local传输用于在<strong>同一个JVM中</strong>运行的客户端和服务器程序之间的<strong>异步通信</strong>，与服务器Channel相关联的SocketAddress并没有绑定真正的物理网络地址，它会被存储在注册表中，并在Channel关闭时注销。因此Local传输不会接受真正的网络流量，也就是说它不能与其他传输实现进行互操作。</p><p>Embedded传输主要用于对ChannelHandler进行<strong>单元测试</strong>，ChannelHandler是用于<strong>处理消息的逻辑组件</strong>，Netty通过将入站消息与出站消息都写入到EmbeddedChannel中的方式（提供了write/readInbound()与write/readOutbound()来读写入站与出站消息）来实现对ChannelHandler的单元测试。</p><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><hr><p>ChannelHandler充当了处理<strong>入站</strong>和<strong>出站</strong>数据的应用程序<strong>逻辑的容器</strong>，该类是基于<strong>事件驱动</strong>的，它会<strong>响应相关的事件</strong>然后去<strong>调用其关联的回调函数</strong>，例如当一个新的连接<strong>被建立</strong>时，ChannelHandler的<strong>channelActive</strong>()方法将<strong>会被调用</strong>。</p><p>关于入站消息和出站消息的数据流向定义，如果以客户端为主视角来说的话，那么从<strong>客户端</strong>流向<strong>服务器</strong>的数据被称为<strong>出站</strong>，反之为入站。</p><p>入站事件是可能被<strong>入站数据或者相关的状态更改而触发的事件</strong>，包括：连接已被激活、连接失活、读取入站数据、用户事件、发生异常等。</p><p>出站事件是<strong>未来将会触发的某个动作的结果的事件</strong>，这些动作包括：打开或关闭远程节点的连接、将数据写（或冲刷）到套接字。</p><p>ChannelHandler的主要用途包括：</p><ul><li><p>对<strong>入站与出站数据</strong>的业务<strong>逻辑处理</strong></p></li><li><p><strong>记录日志</strong></p></li><li><p><strong>将数据从一种格式转换为另一种格式</strong>，实现编解码器。以一次HTTP协议（或者其他应用层协议）的流程为例，数据在网络传输时的单位为字节，当客户端发送请求到服务器时，服务器需要通过解码器（处理入站消息）将字节解码为协议的消息内容，服务器在发送响应的时候（处理出站消息），还需要通过编码器将消息内容编码为字节。</p></li><li><p><strong>捕获异常</strong></p></li><li><p><strong>提供Channel生命周期内的通知</strong>，如Channel活动时与非活动时</p></li></ul><p>Netty中到处都充满了异步与事件驱动，而<strong>回调函数</strong>正是用于<strong>响应事件之后的操作</strong>。由于异步会直接返回一个结果，所以Netty提供了ChannelFuture（实现了java.util.concurrent.Future）来作为异步调用返回的占位符，真正的结果会在未来的某个时刻完成，到时候就可以通过ChannelFuture对其进行访问，每个Netty的出站I/O操作都将会返回一个ChannelFuture。</p><p>Netty还提供了<strong>ChannelFutureListener</strong>接口来<strong>监听ChannelFuture</strong>是否成功，并采取对应的操作。</p><pre>Channel channel = ...ChannelFuture future = channel.connect(new InetSocketAddress("192.168.0.1",6666));// 注册一个监听器future.addListener(new ChannelFutureListener() {@Overridepublic void operationComplete(ChannelFuture future) {if (future.isSuccess()) {// do something....} else {// 输出错误信息Throwable cause = future.cause();cause.printStackTrace();// do something....}}});</pre><p>ChannelFutureListener接口中还提供了几个简单的默认实现，方便我们使用。</p><pre>package io.netty.channel;import io.netty.channel.ChannelFuture;import io.netty.util.concurrent.GenericFutureListener;public interface ChannelFutureListener extends GenericFutureListener<channelfuture> {// 在Future完成时关闭ChannelFutureListener CLOSE = new ChannelFutureListener() {public void operationComplete(ChannelFuture future) {future.channel().close();}};// 如果失败则关闭ChannelFutureListener CLOSE_ON_FAILURE = new ChannelFutureListener() {public void operationComplete(ChannelFuture future) {if(!future.isSuccess()) {future.channel().close();}}};// 将异常信息传递给下一个ChannelHandlerChannelFutureListener FIRE_EXCEPTION_ON_FAILURE = new ChannelFutureListener() {public void operationComplete(ChannelFuture future) {if(!future.isSuccess()) {future.channel().pipeline().fireExceptionCaught(future.cause());}}};}</channelfuture></pre><p>ChannelHandler接口<strong>定义了对它生命周期进行监听的回调函数</strong>，在ChannelHandler被添加到ChannelPipeline或者被移除时都会调用这些函数。</p><pre>package io.netty.channel;public interface ChannelHandler {void handlerAdded(ChannelHandlerContext var1) throws Exception;void handlerRemoved(ChannelHandlerContext var1) throws Exception;/** @deprecated */@Deprecatedvoid exceptionCaught(ChannelHandlerContext var1, Throwable var2) throws Exception;// 该注解表明这个ChannelHandler可被其他线程复用@Inherited@Documented@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface Sharable {}}</pre><p><strong>入站消息与出站消息</strong>由其对应的接口<strong>ChannelInboundHandler与ChannelOutboundHandle</strong>r负责，这两个接口定义了监听Channel的<strong>生命周期的状态改变事件</strong>的回调函数。</p><pre>package io.netty.channel;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;public interface ChannelInboundHandler extends ChannelHandler {// 当channel被注册到EventLoop时被调用void channelRegistered(ChannelHandlerContext var1) throws Exception;// 当channel已经被创建，但还未注册到EventLoop（或者从EventLoop中注销）被调用void channelUnregistered(ChannelHandlerContext var1) throws Exception;// 当channel处于活动状态（连接到远程节点）被调用void channelActive(ChannelHandlerContext var1) throws Exception;// 当channel处于非活动状态（没有连接到远程节点）被调用void channelInactive(ChannelHandlerContext var1) throws Exception;// 当从channel读取数据时被调用void channelRead(ChannelHandlerContext var1, Object var2) throws Exception;// 当channel的上一个读操作完成时被调用void channelReadComplete(ChannelHandlerContext var1) throws Exception;// 当ChannelInboundHandler.fireUserEventTriggered()方法被调用时被调用void userEventTriggered(ChannelHandlerContext var1, Object var2) throws Exception;// 当channel的可写状态发生改变时被调用void channelWritabilityChanged(ChannelHandlerContext var1) throws Exception;// 当处理过程中发生异常时被调用void exceptionCaught(ChannelHandlerContext var1, Throwable var2) throws Exception;}package io.netty.channel;import io.netty.channel.ChannelHandler;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelPromise;import java.net.SocketAddress;public interface ChannelOutboundHandler extends ChannelHandler {// 当请求将Channel绑定到一个地址时被调用// ChannelPromise是ChannelFuture的一个子接口，定义了如setSuccess(),setFailure()等方法void bind(ChannelHandlerContext var1, SocketAddress var2, ChannelPromise var3) throws Exception;// 当请求将Channel连接到远程节点时被调用void connect(ChannelHandlerContext var1, SocketAddress var2, SocketAddress var3, ChannelPromise var4) throws Exception;// 当请求将Channel从远程节点断开时被调用void disconnect(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;// 当请求关闭Channel时被调用void close(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;// 当请求将Channel从它的EventLoop中注销时被调用void deregister(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;// 当请求从Channel读取数据时被调用void read(ChannelHandlerContext var1) throws Exception;// 当请求通过Channel将数据写到远程节点时被调用void write(ChannelHandlerContext var1, Object var2, ChannelPromise var3) throws Exception;// 当请求通过Channel将缓冲中的数据冲刷到远程节点时被调用void flush(ChannelHandlerContext var1) throws Exception;}</pre><p>通过实现ChannelInboundHandler或者ChannelOutboundHandler就可以完成用户自定义的应用逻辑处理程序，不过Netty已经帮你实<strong>现了一些基本操作，用户只需要继承并扩展ChannelInboundHandlerAdapter或ChannelOutboundHandlerAdapter</strong>来作为自定义实现的起始点。</p><p>ChannelInboundHandlerAdapter与ChannelOutboundHandlerAdapter都继承于ChannelHandlerAdapter，该抽象类简单实现了ChannelHandler接口。</p><pre>public abstract class ChannelHandlerAdapter implements ChannelHandler {boolean added;public ChannelHandlerAdapter() {}// 该方法不允许将此ChannelHandler共享复用protected void ensureNotSharable() {if(this.isSharable()) {throw new IllegalStateException("ChannelHandler " + this.getClass().getName() + " is not allowed to be shared");}}// 使用反射判断实现类有没有@Sharable注解，以确认该类是否为可共享复用的public boolean isSharable() {Class clazz = this.getClass();Map cache = InternalThreadLocalMap.get().handlerSharableCache();Boolean sharable = (Boolean)cache.get(clazz);if(sharable == null) {sharable = Boolean.valueOf(clazz.isAnnotationPresent(Sharable.class));cache.put(clazz, sharable);}return sharable.booleanValue();}public void handlerAdded(ChannelHandlerContext ctx) throws Exception {}public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {}public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {ctx.fireExceptionCaught(cause);}}</pre><p>ChannelInboundHandlerAdapter与ChannelOutboundHandlerAdapter<strong>默认只是简单地将请求传递给ChannelPipeline中的下一个ChannelHandler</strong>，源码如下：</p><pre>public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {public ChannelInboundHandlerAdapter() {}public void channelRegistered(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelRegistered();}public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelUnregistered();}public void channelActive(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelActive();}public void channelInactive(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelInactive();}public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {ctx.fireChannelRead(msg);}public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelReadComplete();}public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {ctx.fireUserEventTriggered(evt);}public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {ctx.fireChannelWritabilityChanged();}public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {ctx.fireExceptionCaught(cause);}}public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {public ChannelOutboundHandlerAdapter() {}public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {ctx.bind(localAddress, promise);}public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {ctx.connect(remoteAddress, localAddress, promise);}public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {ctx.disconnect(promise);}public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {ctx.close(promise);}public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {ctx.deregister(promise);}public void read(ChannelHandlerContext ctx) throws Exception {ctx.read();}public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {ctx.write(msg, promise);}public void flush(ChannelHandlerContext ctx) throws Exception {ctx.flush();}}</pre><p>对于处理入站消息，另外一种选择是<strong>继承SimpleChannelInboundHandler</strong>，它是Netty的一个继承于ChannelInboundHandlerAdapter的抽象类，并在其之上实现了<strong>自动释放资源的功能</strong>。</p><p>我们在了解ByteBuf时就已经知道了<strong>Netty使用了一套自己实现的引用计数算法来主动释放资源</strong>，假设你的ChannelHandler继承于ChannelInboundHandlerAdapter或ChannelOutboundHandlerAdapter，那么你就有责任去管理你所分配的ByteBuf，一般来说，一个消息对象（<strong>ByteBuf</strong>）已经被消费（或丢弃）了，<strong>并不会传递给ChannelHandler链中的下一个处理器</strong>（如果该消息到达了实际的传输层，那么当它被写入或Channel关闭时，都会被自动释放），所以你就需要去手动释放它。通过一个简单的工具类<strong>ReferenceCountUtil的release方法</strong>，就可以做到这一点。</p><pre>// 这个泛型为消息对象的类型public abstract class SimpleChannelInboundHandler<i> extends ChannelInboundHandlerAdapter {private final TypeParameterMatcher matcher;private final boolean autoRelease;protected SimpleChannelInboundHandler() {    this(true);}protected SimpleChannelInboundHandler(boolean autoRelease) {        this.matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, "I");        this.autoRelease = autoRelease;}protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType) {        this(inboundMessageType, true);}protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType, boolean autoRelease) {            this.matcher = TypeParameterMatcher.get(inboundMessageType);            this.autoRelease = autoRelease;}public boolean acceptInboundMessage(Object msg) throws Exception {        return this.matcher.match(msg);}// SimpleChannelInboundHandler只是替你做了ReferenceCountUtil.release()public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {boolean release = true;try {    if(this.acceptInboundMessage(msg)) {             this.channelRead0(ctx, msg);    } else {            release = false;            ctx.fireChannelRead(msg);    }} finally {        if(this.autoRelease && release) {            //ByteBuf的释放            ReferenceCountUtil.release(msg);        }    }}// 这个方法才是我们需要实现的方法protected abstract void channelRead0(ChannelHandlerContext var1, I var2) throws Exception;}// ReferenceCountUtil中的源码，release方法对消息对象的类型进行判断然后调用它的release()方法public static boolean release(Object msg) {return msg instanceof ReferenceCounted?((ReferenceCounted)msg).release():false;}</i></pre><h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><hr><p>为了<strong>模块化与解耦合</strong>，不可能由一个ChannelHandler来完成所有应用逻辑，所以Netty采用了拦截器链的设计。ChannelPipeline就是用来<strong>管理ChannelHandler实例链的容器</strong>，它的职责就是<strong>保证实例链的流动</strong>。</p><p>每一个新创建的Channel都将会被分配一个新的ChannelPipeline，这种<strong>关联关系是永久</strong>性的，一个Channel一生只能对应一个ChannelPipeline。</p><p><a href="http://wx3.sinaimg.cn/large/63503acbly1fm1er9l4jfj213h0fcq3d.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1fm1er9l4jfj213h0fcq3d.jpg" alt></a></p><p>一个入站事件被触发时，它会先从ChannelPipeline的最左端（头部）开始一直传播到ChannelPipeline的最右端（尾部），而出站事件正好与入站事件顺序相反（从最右端一直传播到最左端）。这个<strong>顺序是定死</strong>的，Netty总是将ChannelPipeline的<strong>入站口作为头部</strong>，而将<strong>出站口作为尾部</strong>。在事件传播的过程中，ChannelPipeline会判断下一个ChannelHandler的类型是否和事件的运动方向相匹配，如果不匹配，就跳过该ChannelHandler并继续检查下一个（保证入站事件只会被ChannelInboundHandler处理），<strong>一个</strong>ChannelHandler也可以<strong>同时实现</strong>ChannelInboundHandler与ChannelOutboundHandler，它在<strong>入站事件与出站事件中都会被调用。</strong></p><p>在阅读ChannelHandler的源码时，发现很多方法需要一个ChannelHandlerContext类型的参数，该接口是ChannelPipeline与ChannelHandler之间相关联的关键。ChannelHandlerContext可以通知ChannelPipeline中的当前ChannelHandler的下一个ChannelHandler，还可以动态地改变当前ChannelHandler在ChannelPipeline中的位置（通过调用ChannelPipeline中的各种方法来修改）。</p><p>ChannelHandlerContext负责了在同一个ChannelPipeline中的ChannelHandler与其他ChannelHandler之间的交互，每个ChannelHandlerContext都对应了一个ChannelHandler。在DefaultChannelPipeline的源码中，已经表现的很明显了。</p><pre>public class DefaultChannelPipeline implements ChannelPipeline {.........// 头部节点和尾部节点的引用变量// ChannelHandlerContext在ChannelPipeline中是以链表的形式组织的final AbstractChannelHandlerContext head;final AbstractChannelHandlerContext tail;.........// 添加一个ChannelHandler到链表尾部public final ChannelPipeline addLast(String name, ChannelHandler handler) {return this.addLast((EventExecutorGroup)null, name, handler);}public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {final AbstractChannelHandlerContext newCtx;synchronized(this) {// 检查ChannelHandler是否为一个共享对象(@Sharable)// 如果该ChannelHandler没有@Sharable注解，并且是已被添加过的那么就抛出异常checkMultiplicity(handler);// 返回一个DefaultChannelHandlerContext，注意该对象持有了传入的ChannelHandlernewCtx = this.newContext(group, this.filterName(name, handler), handler);this.addLast0(newCtx);// 如果当前ChannelPipeline没有被注册，那么就先加到未决链表中if(!this.registered) {newCtx.setAddPending();this.callHandlerCallbackLater(newCtx, true);return this;}// 否则就调用ChannelHandler中的handlerAdded()EventExecutor executor = newCtx.executor();if(!executor.inEventLoop()) {newCtx.setAddPending();executor.execute(new Runnable() {public void run() {DefaultChannelPipeline.this.callHandlerAdded0(newCtx);}});return this;}}this.callHandlerAdded0(newCtx);return this;}// 将新的ChannelHandlerContext插入到尾部与尾部之前的节点之间private void addLast0(AbstractChannelHandlerContext newCtx) {AbstractChannelHandlerContext prev = this.tail.prev;newCtx.prev = prev;newCtx.next = this.tail;prev.next = newCtx;this.tail.prev = newCtx;}.....}</pre><p>ChannelHandlerContext还定义了许多与Channel和ChannelPipeline重合的方法（像read()、write()、connect()这些用于出站的方法或者如fireChannelXXXX()这样用于<strong>入站的方法</strong>），不同之处在于<strong>调用Channel或者ChannelPipeline上的这些方法，它们将会从头沿着整个ChannelHandler实例链进行传播，而调用位于ChannelHandlerContext上的相同方法，则会从当前所关联的ChannelHandler开始，且只会传播给实例链中的下一个ChannelHandler</strong>。而且，<strong>事件之间的移动</strong>（从一个ChannelHandler到下一个ChannelHandler）也是<strong>通过ChannelHandlerContext中的方法调用完成</strong>的。</p><pre>public class DefaultChannelPipeline implements ChannelPipeline {public final ChannelPipeline fireChannelRead(Object msg) {// 注意这里将头节点传入了进去AbstractChannelHandlerContext.invokeChannelRead(this.head, msg);return this;}}---------------------------------------------------------------abstract class AbstractChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext, ResourceLeakHint {static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);EventExecutor executor = next.executor();if(executor.inEventLoop()) {next.invokeChannelRead(m);} else {executor.execute(new Runnable() {public void run() {next.invokeChannelRead(m);}});}}private void invokeChannelRead(Object msg) {if(this.invokeHandler()) {try {((ChannelInboundHandler)this.handler()).channelRead(this, msg);} catch (Throwable var3) {this.notifyHandlerException(var3);}} else {// 寻找下一个ChannelHandlerthis.fireChannelRead(msg);}}public ChannelHandlerContext fireChannelRead(Object msg) {invokeChannelRead(this.findContextInbound(), msg);return this;}private AbstractChannelHandlerContext findContextInbound() {AbstractChannelHandlerContext ctx = this;do {ctx = ctx.next;} while(!ctx.inbound); // 直到找到一个ChannelInboundHandlerreturn ctx;}}</pre><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><hr><p>为了最大限度地提供高性能和可维护性，Netty设计了一套强大又易用的线程模型。在一个网络框架中，最重要的能力是能够快速高效地<strong>处理在连接的生命周期内发生的各种事件</strong>，与之相匹配的程序构造被称为<strong>事件循环</strong>，Netty定义了接口EventLoop来负责这项工作。</p><p>如果是经常用Java进行多线程开发的童鞋想必经常会使用到线程池，也就是Executor这套API。Netty就是从Executor（java.util.concurrent）之上扩展了自己的EventExecutorGroup（io.netty.util.concurrent），同时为了与Channel的事件进行交互，还扩展了EventLoopGroup接口（io.netty.channel）。在io.netty.util.concurrent包下的EventExecutorXXX负责实现<strong>线程并发</strong>相关的工作，而在io.netty.channel包下的EventLoopXXX负责<strong>实现网络编程</strong>相关的工作（处理Channel中的事件）。</p><p><a href="http://wx3.sinaimg.cn/large/63503acbly1fm296hz0p9j20ff0kc3z2.jpg" target="_blank" rel="noopener"><img src="http://wx3.sinaimg.cn/large/63503acbly1fm296hz0p9j20ff0kc3z2.jpg" alt></a></p><p>在Netty的线程模型中，一个EventLoop将由一个永远不会改变的Thread驱动，而一个Channel一生只会使用一个EventLoop（但是一个EventLoop可能会被指派用于服务多个Channel），在Channel中的所有I/O操作和事件都由EventLoop中的线程处理，也就是说<strong>一个Channel的一生之中都只会使用到一个线程</strong>。不过在Netty3，只有入站事件会被EventLoop处理，所有出站事件都会由调用线程处理，这种设计导致了ChannelHandler的线程安全问题。Netty4简化了线程模型，通过在同一个线程处理所有事件，既解决了这个问题，还提供了一个更加简单的架构。</p><pre>package io.netty.channel;public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {protected static final int DEFAULT_MAX_PENDING_TASKS = Math.max(16, SystemPropertyUtil.getInt("io.netty.eventLoop.maxPendingTasks", 2147483647));    //内部队列private final Queue<runnable> tailTasks;protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {this(parent, threadFactory, addTaskWakesUp, DEFAULT_MAX_PENDING_TASKS, RejectedExecutionHandlers.reject());}protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor, boolean addTaskWakesUp) {this(parent, executor, addTaskWakesUp, DEFAULT_MAX_PENDING_TASKS, RejectedExecutionHandlers.reject());}protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler) {super(parent, threadFactory, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);this.tailTasks = this.newTaskQueue(maxPendingTasks);}protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler) {super(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);this.tailTasks = this.newTaskQueue(maxPendingTasks);}// 返回它所在的EventLoopGrouppublic EventLoopGroup parent() {return (EventLoopGroup)super.parent();}public EventLoop next() {return (EventLoop)super.next();}// 注册Channel,这里ChannelPromise和Channel关联到了一起public ChannelFuture register(Channel channel) {return this.register((ChannelPromise)(new DefaultChannelPromise(channel, this)));}public ChannelFuture register(ChannelPromise promise) {ObjectUtil.checkNotNull(promise, "promise");promise.channel().unsafe().register(this, promise);return promise;}// 剩下这些函数都是用于调度任务public final void executeAfterEventLoopIteration(Runnable task) {ObjectUtil.checkNotNull(task, "task");if(this.isShutdown()) {reject();}if(!this.tailTasks.offer(task)) {this.reject(task);}if(this.wakesUpForTask(task)) {this.wakeup(this.inEventLoop());}}final boolean removeAfterEventLoopIterationTask(Runnable task) {return this.tailTasks.remove(ObjectUtil.checkNotNull(task, "task"));}protected boolean wakesUpForTask(Runnable task) {return !(task instanceof SingleThreadEventLoop.NonWakeupRunnable);}protected void afterRunningAllTasks() {this.runAllTasksFrom(this.tailTasks);}protected boolean hasTasks() {return super.hasTasks() || !this.tailTasks.isEmpty();}public int pendingTasks() {return super.pendingTasks() + this.tailTasks.size();}interface NonWakeupRunnable extends Runnable {}}</runnable></pre><p>为了确保一个Channel的整个生命周期中的I/O事件会被一个EventLoop负责，Netty通过<strong>inEventLoop()</strong>方法来<strong>判断当前执行的线程的身份</strong>，确定它是否是分配给当前Channel以及它的EventLoop的那一个线程。</p><p>如果当前（调用）线程正是EventLoop中的线程，那么所提交的任务将会被<strong>(true)直接执行</strong>，否则，EventLoop将调度该任务以便<strong>(false)稍后执行</strong>，并将它<strong>放入内部的任务队列</strong>（每个EventLoop都有它自己的任务队列，SingleThreadEventLoop的源码就能发现很多用于调度内部任务队列的方法），在下次处理它的事件时，将会执行队列中的那些任务。这种设计可以让任何线程与Channel直接交互，而无需在ChannelHandler中进行额外的同步。</p><p>从性能上来考虑，千万<strong>不要将一个需要长时间来运行的任务放入到任务队列中</strong>，它会影响到该队列中的其他任务的执行。<strong>解决方案</strong>是<strong>使用一个专门的EventExecutor来执行它</strong>（ChannelPipeline提供了带有EventExecutorGroup参数的addXXX()方法，该方法可以<strong>将传入的ChannelHandler绑定到你传入的EventExecutor之中</strong>），这样它就会在另一条线程中执行，与其他任务隔离。</p><pre>public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {.....public void execute(Runnable task) {if(task == null) {throw new NullPointerException("task");} else {boolean inEventLoop = this.inEventLoop();if(inEventLoop) {this.addTask(task);} else {this.startThread();this.addTask(task);if(this.isShutdown() && this.removeTask(task)) {reject();}}if(!this.addTaskWakesUp && this.wakesUpForTask(task)) {this.wakeup(inEventLoop);}}}public boolean inEventLoop(Thread thread) {return thread == this.thread;}.....}</pre><p>EventLoopGroup<strong>负责管理和分配EventLoop（创建EventLoop和为每个新创建的Channel分配EventLoop），根据不同的传输类型，EventLoop的创建和分配方式也不同</strong>。例如，使用NIO传输类型，EventLoopGroup就会只使用较少的EventLoop（一个EventLoop服务于多个Channel），这是因为NIO基于I/O多路复用，一个线程可以处理多个连接，而如果使用的是OIO，那么新创建一个Channel（连接）就需要分配一个EventLoop（线程）。</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><hr><p>在深入了解地Netty的核心组件之后，发现它们的<strong>设计</strong>都很<strong>模块化</strong>，如果想要实现你自己的应用程序，就需要<strong>将这些组件组装到一起</strong>。Netty通过Bootstrap类，以对一个Netty应用程序进行配置（<strong>组装各个组件</strong>），并最终使它运行起来。对于客户端程序和服务器程序所使用到的Bootstrap类是不同的，后者需要使用ServerBootstrap，这样设计是因为，在如TCP这样有连接的协议中，服务器程序往往需要一个以上的Channel，通过父Channel来接受来自客户端的连接，然后创建子Channel用于它们之间的通信，而像UDP这样无连接的协议，它不需要每个连接都创建子Channel，只需要一个Channel即可。</p><p>一个比较明显的差异就是Bootstrap与ServerBootstrap的group()方法，后者提供了一个接收2个EventLoopGroup的版本。</p><pre>// 该方法在Bootstrap的父类AbstractBootstrap中，泛型B为它当前子类的类型（为了链式调用）public B group(EventLoopGroup group) {if(group == null) {throw new NullPointerException("group");} else if(this.group != null) {throw new IllegalStateException("group set already");} else {this.group = group;return this;}}// ServerBootstrap中的实现，它也支持只用一个EventLoopGrouppublic ServerBootstrap group(EventLoopGroup group) {return this.group(group, group);}public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {super.group(parentGroup);if(childGroup == null) {throw new NullPointerException("childGroup");} else if(this.childGroup != null) {throw new IllegalStateException("childGroup set already");} else {this.childGroup = childGroup;return this;}}</pre><p>Bootstrap其实没有什么可以好说的，它就只是一个<strong>装配工</strong>，将各个组件拼装组合到一起，然后进行一些配置，有关它的详细API请参考<a href="http://netty.io/4.1/api/index.html" target="_blank" rel="noopener">Netty JavaDoc</a>。</p><h3 id="Echo示例"><a href="#Echo示例" class="headerlink" title="Echo示例"></a>Echo示例</h3><p>下面我们将通过一个经典的Echo客户端与服务器的例子，来梳理一遍创建Netty应用的流程。</p><p>首先实现的是服务器，我们先实现一个EchoServerInboundHandler，处理入站消息。</p><pre>public class EchoServerInboundHandler extends ChannelInboundHandlerAdapter {@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {ByteBuf in = (ByteBuf) msg;System.out.printf("Server received: %s \n", in.toString(CharsetUtil.UTF_8));// 由于读事件不是一次性就能把完整消息发送过来的，这里并没有调用writeAndFlushctx.write(in); // 直接把消息写回给客户端(会被出站消息处理器处理,不过我们的应用没有实现任何出站消息处理器)}@Overridepublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {// 等读事件已经完成时,冲刷之前写数据的缓冲区// 然后添加了一个监听器，它会在Future完成时进行关闭该Channel.ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);}// 处理异常，输出异常信息，然后关闭Channel@Overridepublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {cause.printStackTrace();ctx.close();}}</pre><p>服务器的应用逻辑只有这么多，剩下就是用ServerBootstrap进行配置了。</p><pre>public class EchoServer {private final int port;public EchoServer(int port) {this.port = port;}public void start() throws Exception {final EchoServerInboundHandler serverHandler = new EchoServerInboundHandler();EventLoopGroup group = new NioEventLoopGroup(); // 传输类型使用NIOtry {ServerBootstrap b = new ServerBootstrap();b.group(group) // 配置EventLoopGroup.channel(NioServerSocketChannel.class) // 配置Channel的类型.localAddress(new InetSocketAddress(port)) // 配置端口号.childHandler(new ChannelInitializer<socketchannel>() {// 实现一个ChannelInitializer，它可以方便地添加多个ChannelHandler@Overrideprotected void initChannel(SocketChannel socketChannel) throws Exception {socketChannel.pipeline().addLast(serverHandler);}});// 绑定地址，同步等待它完成ChannelFuture f = b.bind().sync();// 关闭这个Futuref.channel().closeFuture().sync();} finally {// 关闭应用程序，一般来说Netty应用只需要调用这个方法就够了group.shutdownGracefully().sync();}}public static void main(String[] args) throws Exception {if (args.length != 1) {System.err.printf("Usage: %s <port> \n",EchoServer.class.getSimpleName());return;}int port = Integer.parseInt(args[0]);new EchoServer(port).start();}}</port></socketchannel></pre><p>接下来实现客户端，同样需要先实现一个入站消息处理器。</p><pre>public class EchoClientInboundHandler extends SimpleChannelInboundHandler<bytebuf> {/*** 我们在Channel连接到远程节点直接发送一条消息给服务器*/@Overridepublic void channelActive(ChannelHandlerContext ctx) throws Exception {ctx.writeAndFlush(Unpooled.copiedBuffer("Hello, Netty!", CharsetUtil.UTF_8));}@Overrideprotected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception {// 输出从服务器Echo的消息System.out.printf("Client received: %s \n", byteBuf.toString(CharsetUtil.UTF_8));}@Overridepublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {cause.printStackTrace();ctx.close();}}</bytebuf></pre><p>然后配置客户端。</p><pre>public class EchoClient {private final String host;private final int port;public EchoClient(String host, int port) {this.host = host;this.port = port;}public void start() throws Exception {EventLoopGroup group = new NioEventLoopGroup();try {Bootstrap b = new Bootstrap();b.group(group).channel(NioSocketChannel.class).remoteAddress(new InetSocketAddress(host, port)) // 服务器的地址.handler(new ChannelInitializer<socketchannel>() {@Overrideprotected void initChannel(SocketChannel socketChannel) throws Exception {socketChannel.pipeline().addLast(new EchoClientInboundHandler());}});ChannelFuture f = b.connect().sync(); // 连接到服务器f.channel().closeFuture().sync();} finally {group.shutdownGracefully().sync();}}public static void main(String[] args) throws Exception {if (args.length != 2) {System.err.printf("Usage: %s <host> <port> \n", EchoClient.class.getSimpleName());return;}String host = args[0];int port = Integer.parseInt(args[1]);new EchoClient(host, port).start();}}</port></host></socketchannel></pre><p>实现一个Netty应用程序就是如此简单，用户大多数都是在编写各种应用逻辑的ChannelHandler（或者使用Netty内置的各种实用ChannelHandler），然后只需要将它们全部添加到ChannelPipeline即可。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><hr><ul><li><p><a href="https://netty.io/" target="_blank" rel="noopener">Netty: Home</a></p></li><li><p><a href="https://notes.shichao.io/unp/ch6/#io-multiplexing-model" target="_blank" rel="noopener">Chapter 6. I/O Multiplexing: The select and poll Functions - Shichao’s Notes</a></p></li><li><p><a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll(7) - Linux manual page</a></p></li><li><p><a href="http://tutorials.jenkov.com/java-nio/" target="_blank" rel="noopener">Java NIO</a></p></li><li><p><a href="https://netty.io/" target="_blank" rel="noopener">Netty: Home</a></p></li><li><p><a href="https://notes.shichao.io/unp/ch6/#io-multiplexing-model" target="_blank" rel="noopener">Chapter 6. I/O Multiplexing: The select and poll Functions - Shichao’s Notes</a></p></li><li><p><a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll(7) - Linux manual page</a></p></li><li><p><a href="http://tutorials.jenkov.com/java-nio/" target="_blank" rel="noopener">Java NIO</a></p></li></ul><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></=></=></abstractreferencecountedbytebuf></pre></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自：&lt;a href=&quot;https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://sylvanassun.github.io/2017/11/30/2017-11-30-netty_introduction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解8：浅析mmap和Direct Buffer</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E8%AF%A6%E8%A7%A38%EF%BC%9A%E6%B5%85%E6%9E%90mmap%E5%92%8CDirect%20Buffer/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程与NIO详解8：浅析mmap和Direct Buffer/</id>
    <published>2019-12-13T15:18:43.000Z</published>
    <updated>2021-11-24T08:03:23.995Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转自：<a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><p><strong>阅读目录</strong></p><ul><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label0" target="_blank" rel="noopener">mmap基础概念</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label1" target="_blank" rel="noopener">mmap内存映射原理</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label2" target="_blank" rel="noopener">mmap和常规文件操作的区别</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label3" target="_blank" rel="noopener">mmap优点总结</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label4" target="_blank" rel="noopener">mmap相关函数</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label5" target="_blank" rel="noopener">mmap使用细节</a></li></ul><h1 id="mmap基础概念"><a href="#mmap基础概念" class="headerlink" title="mmap基础概念"></a>mmap基础概念</h1><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200501092691998.png)</code></pre><p>由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。</p><p>linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200501434261629.png)</code></pre><p>vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。具体步骤请看下一节。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap内存映射原理"><a href="#mmap内存映射原理" class="headerlink" title="mmap内存映射原理"></a>mmap内存映射原理</h1><p>mmap内存映射的实现过程，总的来说可以分为三个阶段：</p><p><strong>（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</strong></p><p>1、进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</p><p>2、在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</p><p>3、为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化</p><p>4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中</p><p><strong>（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</strong></p><p>5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。</p><p>6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。</p><p>7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。</p><p>8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</p><p><strong>（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</strong></p><p>注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。</p><p>9、进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</p><p>10、缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。</p><p>11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</p><p>12、之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p><p>注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap和常规文件操作的区别"><a href="#mmap和常规文件操作的区别" class="headerlink" title="mmap和常规文件操作的区别"></a>mmap和常规文件操作的区别</h1><p>对linux文件系统不了解的朋友，请参阅我之前写的博文《<a href="http://www.cnblogs.com/huxiao-tee/p/4657851.html" target="_blank" rel="noopener">从内核文件系统看文件读写过程</a>》，我们首先简单的回顾一下常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p><p>1、进程发起读文件请求。</p><p>2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</p><p>3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</p><p>4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</p><p>总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p><p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p><p><strong>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong>说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h1 id="mmap优点总结"><a href="#mmap优点总结" class="headerlink" title="mmap优点总结"></a>mmap优点总结</h1><p>由上文讨论可知，mmap优点共有一下几点：</p><p>1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p><p>2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p><p>3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p><pre><code>同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</code></pre><p>4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</p><h1 id="mmap使用细节"><a href="#mmap使用细节" class="headerlink" title="mmap使用细节"></a>mmap使用细节</h1><p>1、使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p><p>2、内核可以跟踪被内存映射的底层对象（文件）的大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的那些字节。也就是说，如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到，这和映射建立时文件的大小无关。具体情形参见“情形三”。</p><p>3、映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p><p>在上面的知识前提下，我们下面看看如果大小不是页的整倍数的具体情况：</p><p><strong>情形一：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射5000字节到虚拟内存中。</strong></p><p>分析：因为单位物理页面的大小是4096字节，虽然被映射的文件只有5000字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此mmap函数执行后，实际映射到虚拟内存区域8192个 字节，5000~8191的字节部分用零填充。映射后的对应关系如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200521495513717.png)</code></pre><p>此时：</p><p>（1）读/写前5000个字节（0~4999），会返回操作文件内容。</p><p>（2）读字节5000<del>8191时，结果全为0。写5000</del>8191时，进程不会报错，但是所写的内容不会写入原文件中 。</p><p>（3）读/写8192以外的磁盘部分，会返回一个SIGSECV错误。</p><p><strong>情形二：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射15000字节到虚拟内存中，即映射大小超过了原始文件的大小。</strong></p><p>分析：由于文件的大小是5000字节，和情形一一样，其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常。如下图所示：</p><pre><code>![](https://images0.cnblogs.com/blog2015/571793/201507/200522381763096.png)</code></pre><p>此时：</p><p>（1）进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中。</p><p>（2）对于5000~8191字节，进程可以进行读写过程，不会报错。但是内容在写入前均为0，另外，写入后不会反映在文件中。</p><p>（3）对于8192~14999字节，进程不能对其进行读写，会报SIGBUS错误。</p><p>（4）对于15000以外的字节，进程不能对其读写，会引发SIGSEGV错误。</p><p><strong>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr。</strong></p><p>分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回SIGBUS错误。</p><p>但是如果，每次操作ptr读写前，先增加文件的大小，那么ptr在文件大小内部的操作就是合法的。例如，文件扩充4096字节，ptr就能操作ptr ~ [ (char)ptr + 4095]的空间。只要文件扩充的范围在1000个物理页（映射范围）内，ptr都可以对应操作相同的大小。</p><p>这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费。</p><p>本文转自：<a href="https://www.jianshu.com/p/007052ee3773" target="_blank" rel="noopener">https://www.jianshu.com/p/007052ee3773</a></p><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>堆外内存是相对于堆内内存的一个概念。堆内内存是由JVM所管控的Java进程内存，我们平时在Java中创建的对象都处于堆内内存中，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理它们的内存。那么堆外内存就是存在于JVM管控之外的一块内存区域，因此它是不受JVM的管控。</p><h3 id="在讲解DirectByteBuffer之前，需要先简单了解两个知识点"><a href="#在讲解DirectByteBuffer之前，需要先简单了解两个知识点" class="headerlink" title="在讲解DirectByteBuffer之前，需要先简单了解两个知识点"></a>在讲解DirectByteBuffer之前，需要先简单了解两个知识点</h3><h4 id="java引用类型，因为DirectByteBuffer是通过虚引用-Phantom-Reference-来实现堆外内存的释放的。"><a href="#java引用类型，因为DirectByteBuffer是通过虚引用-Phantom-Reference-来实现堆外内存的释放的。" class="headerlink" title="java引用类型，因为DirectByteBuffer是通过虚引用(Phantom Reference)来实现堆外内存的释放的。"></a>java引用类型，因为DirectByteBuffer是通过虚引用(Phantom Reference)来实现堆外内存的释放的。</h4><p>PhantomReference 是所有“弱引用”中最弱的引用类型。不同于软引用和弱引用，虚引用无法通过 get() 方法来取得目标对象的强引用从而使用目标对象，观察源码可以发现 get() 被重写为永远返回 null。<br>那虚引用到底有什么作用？其实虚引用主要被用来 跟踪对象被垃圾回收的状态，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否 即将被垃圾回收，从而采取行动。它并不被期待用来取得目标对象的引用，而目标对象被回收前，它的引用会被放入一个 ReferenceQueue 对象中，从而达到跟踪对象垃圾回收的作用。<br>关于java引用类型的实现和原理可以阅读之前的文章<a href="https://www.jianshu.com/p/f86d3a43eec5" target="_blank" rel="noopener">Reference 、ReferenceQueue 详解</a> 和<a href="https://www.jianshu.com/p/9a089a37f78d" target="_blank" rel="noopener">Java 引用类型简述</a></p><h4 id="关于linux的内核态和用户态"><a href="#关于linux的内核态和用户态" class="headerlink" title="关于linux的内核态和用户态"></a>关于linux的内核态和用户态</h4><p><img src="https://upload-images.jianshu.io/upload_images/4235178-7c5ca2cb236fd2eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/752/format/webp" alt></p><ul><li>内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。比如socket I/0操作或者文件的读写操作等</li><li>用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。</li><li>系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4235178-2393d0797135217b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt></p><p>因此我们可以得知当我们通过JNI调用的native方法实际上就是从用户态切换到了内核态的一种方式。并且通过该系统调用使用操作系统所提供的功能。</p><p>Q：为什么需要用户进程(位于用户态中)要通过系统调用(Java中即使JNI)来调用内核态中的资源，或者说调用操作系统的服务了？<br>A：intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态。Ring3状态不能访问Ring0的地址空间，包括代码和数据。因此用户态是没有权限去操作内核态的资源的，它只能通过系统调用外完成用户态到内核态的切换，然后在完成相关操作后再有内核态切换回用户态。</p><h3 id="DirectByteBuffer-————-直接缓冲"><a href="#DirectByteBuffer-————-直接缓冲" class="headerlink" title="DirectByteBuffer ———— 直接缓冲"></a>DirectByteBuffer ———— 直接缓冲</h3><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，我们可以通过该类实现堆外内存的创建、使用和销毁。</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-fc2ae3eac18813d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/726/format/webp" alt></p><p>DirectByteBuffer该类本身还是位于Java内存模型的堆中。堆内内存是JVM可以直接管控、操纵。<br>而DirectByteBuffer中的unsafe.allocateMemory(size);是个一个native方法，这个方法分配的是堆外内存，通过C的malloc来进行分配的。分配的内存是系统本地的内存，并不在Java的内存中，也不属于JVM管控范围，所以在DirectByteBuffer一定会存在某种方式来操纵堆外内存。<br>在DirectByteBuffer的父类Buffer中有个address属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Used only by direct buffers</span><br><span class="line">// NOTE: hoisted here for speed in JNI GetDirectBufferAddress</span><br><span class="line">long address;</span><br></pre></td></tr></table></figure><p>address只会被直接缓存给使用到。之所以将address属性升级放在Buffer中，是为了在JNI调用GetDirectBufferAddress时提升它调用的速率。<br>address表示分配的堆外内存的地址。</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-5e010dc58916b102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt></p><p>unsafe.allocateMemory(size);分配完堆外内存后就会返回分配的堆外内存基地址，并将这个地址赋值给了address属性。这样我们后面通过JNI对这个堆外内存操作时都是通过这个address来实现的了。</p><p>在前面我们说过，在linux中内核态的权限是最高的，那么在内核态的场景下，操作系统是可以访问任何一个内存区域的，所以操作系统是可以访问到Java堆的这个内存区域的。<br>Q：那为什么操作系统不直接访问Java堆内的内存区域了？<br>A：这是因为JNI方法访问的内存区域是一个已经确定了的内存区域地质，那么该内存地址指向的是Java堆内内存的话，那么如果在操作系统正在访问这个内存地址的时候，Java在这个时候进行了GC操作，而GC操作会涉及到数据的移动操作[GC经常会进行先标志在压缩的操作。即，将可回收的空间做标志，然后清空标志位置的内存，然后会进行一个压缩，压缩就会涉及到对象的移动，移动的目的是为了腾出一块更加完整、连续的内存空间，以容纳更大的新对象]，数据的移动会使JNI调用的数据错乱。所以JNI调用的内存是不能进行GC操作的。</p><p>Q：如上面所说，JNI调用的内存是不能进行GC操作的，那该如何解决了？<br>A：①堆内内存与堆外内存之间数据拷贝的方式(并且在将堆内内存拷贝到堆外内存的过程JVM会保证不会进行GC操作)：比如我们要完成一个从文件中读数据到堆内内存的操作，即FileChannelImpl.read(HeapByteBuffer)。这里实际上File I/O会将数据读到堆外内存中，然后堆外内存再讲数据拷贝到堆内内存，这样我们就读到了文件中的内存。</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-f94db8df14023550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1194/format/webp" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException &#123;</span><br><span class="line">    if (var1.isReadOnly()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Read-only buffer&quot;);</span><br><span class="line">    &#125; else if (var1 instanceof DirectBuffer) &#123;</span><br><span class="line">        return readIntoNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 分配临时的堆外内存</span><br><span class="line">        ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());</span><br><span class="line"></span><br><span class="line">        int var7;</span><br><span class="line">        try &#123;</span><br><span class="line">            // File I/O 操作会将数据读入到堆外内存中</span><br><span class="line">            int var6 = readIntoNativeBuffer(var0, var5, var2, var4);</span><br><span class="line">            var5.flip();</span><br><span class="line">            if (var6 &gt; 0) &#123;</span><br><span class="line">                // 将堆外内存的数据拷贝到堆外内存中</span><br><span class="line">                var1.put(var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var7 = var6;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 里面会调用DirectBuffer.cleaner().clean()来释放临时的堆外内存</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而写操作则反之，我们会将堆内内存的数据线写到对堆外内存中，然后操作系统会将堆外内存的数据写入到文件中。<br>② 直接使用堆外内存，如DirectByteBuffer：这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，程序通过JNI直接将数据读/写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，只需要将这个堆外内存地址传给JNI的I/O的函数就好了。</p><h3 id="DirectByteBuffer堆外内存的创建和回收的源码解读"><a href="#DirectByteBuffer堆外内存的创建和回收的源码解读" class="headerlink" title="DirectByteBuffer堆外内存的创建和回收的源码解读"></a>DirectByteBuffer堆外内存的创建和回收的源码解读</h3><h4 id="堆外内存分配"><a href="#堆外内存分配" class="headerlink" title="堆外内存分配"></a>堆外内存分配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(int cap) &#123;                   // package-private</span><br><span class="line">    super(-1, 0, cap, cap);</span><br><span class="line">    boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps = Bits.pageSize();</span><br><span class="line">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">    // 保留总分配内存(按页分配)的大小和实际内存的大小</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过unsafe.allocateMemory分配堆外内存，并返回堆外内存的基地址</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">    if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">        // Round up to page boundary</span><br><span class="line">        address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    // 构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，堆外内存也会被释放</span><br><span class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br><span class="line">    att = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bits-reserveMemory-size-cap-方法"><a href="#Bits-reserveMemory-size-cap-方法" class="headerlink" title="Bits.reserveMemory(size, cap) 方法"></a>Bits.reserveMemory(size, cap) 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static void reserveMemory(long size, int cap) &#123;</span><br><span class="line"></span><br><span class="line">    if (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</span><br><span class="line">        maxMemory = VM.maxDirectMemory();</span><br><span class="line">        memoryLimitSet = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // optimist!</span><br><span class="line">    if (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();</span><br><span class="line"></span><br><span class="line">    // retry while helping enqueue pending Reference objects</span><br><span class="line">    // which includes executing pending Cleaner(s) which includes</span><br><span class="line">    // Cleaner(s) that free direct buffer memory</span><br><span class="line">    while (jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">        if (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // trigger VM&apos;s Reference processing</span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    // a retry loop with exponential back-off delays</span><br><span class="line">    // (this gives VM some time to do it&apos;s job)</span><br><span class="line">    boolean interrupted = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        long sleepTime = 1;</span><br><span class="line">        int sleeps = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sleeps &gt;= MAX_SLEEPS) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(sleepTime);</span><br><span class="line">                    sleepTime &lt;&lt;= 1;</span><br><span class="line">                    sleeps++;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    interrupted = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // no luck</span><br><span class="line">        throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (interrupted) &#123;</span><br><span class="line">            // don&apos;t swallow interrupts</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于在系统中保存总分配内存(按页分配)的大小和实际内存的大小。</p><p>其中，如果系统中内存( 即，堆外内存 )不够的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();</span><br><span class="line"></span><br><span class="line">// retry while helping enqueue pending Reference objects</span><br><span class="line">// which includes executing pending Cleaner(s) which includes</span><br><span class="line">// Cleaner(s) that free direct buffer memory</span><br><span class="line">while (jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">    if (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jlra.tryHandlePendingReference()会触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。<br>因为在Reference的静态代码块中定义了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryHandlePendingReference() &#123;</span><br><span class="line">        return tryHandlePending(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果在进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// trigger VM&apos;s Reference processing</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>System.gc()会触发一个full gc，当然前提是你没有显示的设置-XX:+DisableExplicitGC来禁用显式GC。并且你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。<br>所以在后面打代码中，会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试之前，都对延迟等待时间，已给JVM足够的时间去完成full gc操作。如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(“Direct buffer memory”)异常。</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-6da0d60191992f59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/449/format/webp" alt></p><p>注意，这里之所以用使用full gc的很重要的一个原因是：System.gc()会对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存.<br>DirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象.<br>我们做ygc的时候会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收了，但是无法对old里的DirectByteBuffer对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题。( 并且堆外内存多用于生命期中等或较长的对象 )<br>如果有大量的DirectByteBuffer对象移到了old，但是又一直没有做cms gc或者full gc，而只进行ygc，那么我们的物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多(前提是我们禁用了System.gc – JVM参数DisableExplicitGC)。</p><p>总的来说，Bits.reserveMemory(size, cap)方法在可用堆外内存不足以分配给当前要创建的堆外内存大小时，会实现以下的步骤来尝试完成本次堆外内存的创建：<br>① 触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。<br>② 如果进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则进行 System.gc()。System.gc()会触发一个full gc，但你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。所以在后面打代码中，会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试之前，都对延迟等待时间，已给JVM足够的时间去完成full gc操作。<br>注意，如果你设置了-XX:+DisableExplicitGC，将会禁用显示GC，这会使System.gc()调用无效。<br>③ 如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(“Direct buffer memory”)异常。</p><p>那么可用堆外内存到底是多少了？，即默认堆外存内存有多大：<br>① 如果我们没有通过-XX:MaxDirectMemorySize来指定最大的堆外内存。则👇<br>② 如果我们没通过-Dsun.nio.MaxDirectMemorySize指定了这个属性，且它不等于-1。则👇<br>③ 那么最大堆外内存的值来自于directMemory = Runtime.getRuntime().maxMemory()，这是一个native方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_java_lang_Runtime_maxMemory(JNIEnv *env, jobject this)</span><br><span class="line">&#123;</span><br><span class="line">    return JVM_MaxMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))</span><br><span class="line">  JVMWrapper(&quot;JVM_MaxMemory&quot;);</span><br><span class="line">  size_t n = Universe::heap()-&gt;max_capacity();</span><br><span class="line">  return convert_size_t_to_jlong(n);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure><p>其中在我们使用CMS GC的情况下也就是我们设置的-Xmx的值里除去一个survivor的大小就是默认的堆外内存的大小了。</p><h4 id="堆外内存回收"><a href="#堆外内存回收" class="headerlink" title="堆外内存回收"></a>堆外内存回收</h4><p>Cleaner是PhantomReference的子类，并通过自身的next和prev字段维护的一个双向链表。PhantomReference的作用在于跟踪垃圾回收过程，并不会对对象的垃圾回收过程造成任何的影响。<br>所以cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); 用于对当前构造的DirectByteBuffer对象的垃圾回收过程进行跟踪。<br>当DirectByteBuffer对象从pending状态 ——&gt; enqueue状态时，会触发Cleaner的clean()，而Cleaner的clean()的方法会实现通过unsafe对堆外内存的释放。</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-792afac32aefd061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/713/format/webp" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-07eaab88f1d02927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/750/format/webp" alt></p><p>👆虽然Cleaner不会调用到Reference.clear()，但Cleaner的clean()方法调用了remove(this)，即将当前Cleaner从Cleaner链表中移除，这样当clean()执行完后，Cleaner就是一个无引用指向的对象了，也就是可被GC回收的对象。</p><p>thunk方法：</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-ebeffa00197df134.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/515/format/webp" alt></p><h4 id="通过配置参数的方式来回收堆外内存"><a href="#通过配置参数的方式来回收堆外内存" class="headerlink" title="通过配置参数的方式来回收堆外内存"></a>通过配置参数的方式来回收堆外内存</h4><p>同时我们可以通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc()来做一次full gc，以此来回收掉没有被使用的堆外内存。</p><h3 id="堆外内存那些事"><a href="#堆外内存那些事" class="headerlink" title="堆外内存那些事"></a>堆外内存那些事</h3><h4 id="使用堆外内存的原因"><a href="#使用堆外内存的原因" class="headerlink" title="使用堆外内存的原因"></a>使用堆外内存的原因</h4><ul><li>对垃圾回收停顿的改善<br>因为full gc 意味着彻底回收，彻底回收时，垃圾收集器会对所有分配的堆内内存进行完整的扫描，这意味着一个重要的事实——这样一次垃圾收集对Java应用造成的影响，跟堆的大小是成正比的。过大的堆会影响Java应用的性能。如果使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。</li><li>在某些场景下可以提升程序I/O操纵的性能。少去了将数据从堆内内存拷贝到堆外内存的步骤。</li></ul><h4 id="什么情况下使用堆外内存"><a href="#什么情况下使用堆外内存" class="headerlink" title="什么情况下使用堆外内存"></a>什么情况下使用堆外内存</h4><ul><li>堆外内存适用于生命周期中等或较长的对象。( 如果是生命周期较短的对象，在YGC的时候就被回收了，就不存在大内存且生命周期较长的对象在FGC对应用造成的性能影响 )。</li><li>直接的文件拷贝操作，或者I/O操作。直接使用堆外内存就能少去内存从用户内存拷贝到系统内存的操作，因为I/O操作是系统内核内存和设备间的通信，而不是通过程序直接和外设通信的。</li><li>同时，还可以使用 池+堆外内存 的组合方式，来对生命周期较短，但涉及到I/O操作的对象进行堆外内存的再使用。( Netty中就使用了该方式 )</li></ul><h4 id="堆外内存-VS-内存池"><a href="#堆外内存-VS-内存池" class="headerlink" title="堆外内存 VS 内存池"></a>堆外内存 VS 内存池</h4><ul><li>内存池：主要用于两类对象：①生命周期较短，且结构简单的对象，在内存池中重复利用这些对象能增加CPU缓存的命中率，从而提高性能；②加载含有大量重复对象的大片数据，此时使用内存池能减少垃圾回收的时间。</li><li>堆外内存：它和内存池一样，也能缩短垃圾回收时间，但是它适用的对象和内存池完全相反。内存池往往适用于生命期较短的可变对象，而生命期中等或较长的对象，正是堆外内存要解决的。</li></ul><h4 id="堆外内存的特点"><a href="#堆外内存的特点" class="headerlink" title="堆外内存的特点"></a>堆外内存的特点</h4><ul><li>对于大内存有良好的伸缩性</li><li>对垃圾回收停顿的改善可以明显感觉到</li><li>在进程间可以共享，减少虚拟机间的复制</li></ul><h4 id="堆外内存的一些问题"><a href="#堆外内存的一些问题" class="headerlink" title="堆外内存的一些问题"></a>堆外内存的一些问题</h4><ul><li>堆外内存回收问题，以及堆外内存的泄漏问题。这个在上面的源码解析已经提到了</li><li>堆外内存的数据结构问题：堆外内存最大的问题就是你的数据结构变得不那么直观，如果数据结构比较复杂，就要对它进行串行化（serialization），而串行化本身也会影响性能。另一个问题是由于你可以使用更大的内存，你可能开始担心虚拟内存（即硬盘）的速度对你的影响了。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://link.jianshu.com/?t=http://lovestblog.cn/blog/2015/05/12/direct-buffer/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2015/05/12/direct-buffer/</a><br><a href="https://link.jianshu.com/?t=http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory</a><br><a href="https://www.jianshu.com/p/85e931636f27" target="_blank" rel="noopener">http://www.jianshu.com/p/85e931636f27</a><br>圣思园《并发与Netty》课程</p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自：&lt;a href=&quot;https://www.cnblogs.com/huxiao-tee/p/4660352.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/huxiao-tee/p/4660352.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解7：浅谈 Linux 中NIO Selector 的实现原理</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A37%EF%BC%9A%E6%B5%85%E8%B0%88%20Linux%20%E4%B8%ADNIO%20Selector%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程和NIO详解7：浅谈 Linux 中NIO Selector 的实现原理/</id>
    <published>2019-12-13T15:17:43.000Z</published>
    <updated>2021-11-24T08:03:23.998Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转自互联网</p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Selector是NIO中实现I/O多路复用的关键类。Selector实现了通过一个线程管理多个Channel，从而管理多个网络连接的目的。</p><p>Channel代表这一个网络连接通道，我们可以将Channel注册到Selector中以实现Selector对其的管理。一个Channel可以注册到多个不同的Selector中。</p><p>当Channel注册到Selector后会返回一个SelectionKey对象，该SelectionKey对象则代表这这个Channel和它注册的Selector间的关系。并且SelectionKey中维护着两个很重要的属性：interestOps、readyOps<br>interestOps是我们希望Selector监听Channel的哪些事件。</p><p>我们将我们感兴趣的事件设置到该字段，这样在selection操作时，当发现该Channel有我们所感兴趣的事件发生时，就会将我们感兴趣的事件再设置到readyOps中，这样我们就能得知是哪些事件发生了以做相应处理。</p><h2 id="Selector的中的重要属性"><a href="#Selector的中的重要属性" class="headerlink" title="Selector的中的重要属性"></a>Selector的中的重要属性</h2><p>Selector中维护3个特别重要的SelectionKey集合，分别是</p><ul><li>keys：所有注册到Selector的Channel所表示的SelectionKey都会存在于该集合中。keys元素的添加会在Channel注册到Selector时发生。</li><li>selectedKeys：该集合中的每个SelectionKey都是其对应的Channel在上一次操作selection期间被检查到至少有一种SelectionKey中所感兴趣的操作已经准备好被处理。该集合是keys的一个子集。</li><li>cancelledKeys：执行了取消操作的SelectionKey会被放入到该集合中。该集合是keys的一个子集。</li></ul><p>下面的源码解析会说明上面3个集合的用处</p><h2 id="Selector-源码解析"><a href="#Selector-源码解析" class="headerlink" title="Selector 源码解析"></a>Selector 源码解析</h2><p>下面我们通过一段对Selector的使用流程讲解来进一步深入其实现原理。<br>首先先来段Selector最简单的使用片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(false);</span><br><span class="line">int port = 5566;          </span><br><span class="line">serverChannel.socket().bind(new InetSocketAddress(port));</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">while(true)&#123;</span><br><span class="line">    int n = selector.select();</span><br><span class="line">    if(n &gt; 0) &#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">            SelectionKey selectionKey = iter.next();</span><br><span class="line">            ......</span><br><span class="line">            iter.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、Selector的构建"><a href="#1、Selector的构建" class="headerlink" title="1、Selector的构建"></a>1、Selector的构建</h3><p>SocketChannel、ServerSocketChannel和Selector的实例初始化都通过SelectorProvider类实现。</p><p>ServerSocketChannel.open();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ServerSocketChannel open() throws IOException &#123;</span><br><span class="line">    return SelectorProvider.provider().openServerSocketChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SocketChannel.open();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static SocketChannel open() throws IOException &#123;</span><br><span class="line">    return SelectorProvider.provider().openSocketChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Selector.open();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Selector open() throws IOException &#123;</span><br><span class="line">    return SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来进一步的了解下SelectorProvider.provider()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static SelectorProvider provider() &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        if (provider != null)</span><br><span class="line">            return provider;</span><br><span class="line">        return AccessController.doPrivileged(</span><br><span class="line">            new PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                public SelectorProvider run() &#123;</span><br><span class="line">                        if (loadProviderFromProperty())</span><br><span class="line">                            return provider;</span><br><span class="line">                        if (loadProviderAsService())</span><br><span class="line">                            return provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        return provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 如果配置了“java.nio.channels.spi.SelectorProvider”属性，则通过该属性值load对应的SelectorProvider对象，如果构建失败则抛异常。<br>② 如果provider类已经安装在了对系统类加载程序可见的jar包中，并且该jar包的源码目录META-INF/services包含有一个java.nio.channels.spi.SelectorProvider提供类配置文件，则取文件中第一个类名进行load以构建对应的SelectorProvider对象，如果构建失败则抛异常。<br>③ 如果上面两种情况都不存在，则返回系统默认的SelectorProvider，即，sun.nio.ch.DefaultSelectorProvider.create();<br>④ 随后在调用该方法，即SelectorProvider.provider()。则返回第一次调用的结果。</p><p>不同系统对应着不同的sun.nio.ch.DefaultSelectorProvider</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-a02c498e08979aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt></p><p>这里我们看linux下面的sun.nio.ch.DefaultSelectorProvider</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSelectorProvider &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Prevent instantiation.</span><br><span class="line">     */</span><br><span class="line">    private DefaultSelectorProvider() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the default SelectorProvider.</span><br><span class="line">     */</span><br><span class="line">    public static SelectorProvider create() &#123;</span><br><span class="line">        return new sun.nio.ch.EPollSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，linux系统下sun.nio.ch.DefaultSelectorProvider.create(); 会生成一个sun.nio.ch.EPollSelectorProvider类型的SelectorProvider，这里对应于linux系统的epoll</p><h6 id="接下来看下-selector-open-："><a href="#接下来看下-selector-open-：" class="headerlink" title="接下来看下 selector.open()："></a>接下来看下 selector.open()：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Opens a selector.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; The new selector is created by invoking the &#123;@link</span><br><span class="line"> * java.nio.channels.spi.SelectorProvider#openSelector openSelector&#125; method</span><br><span class="line"> * of the system-wide default &#123;@link</span><br><span class="line"> * java.nio.channels.spi.SelectorProvider&#125; object.  &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @return  A new selector</span><br><span class="line"> *</span><br><span class="line"> * @throws  IOException</span><br><span class="line"> *          If an I/O error occurs</span><br><span class="line"> */</span><br><span class="line">public static Selector open() throws IOException &#123;</span><br><span class="line">    return SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在得到sun.nio.ch.EPollSelectorProvider后调用openSelector()方法构建Selector，这里会构建一个EPollSelectorImpl对象。</p><h3 id="EPollSelectorImpl"><a href="#EPollSelectorImpl" class="headerlink" title="EPollSelectorImpl"></a>EPollSelectorImpl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class EPollSelectorImpl</span><br><span class="line">    extends SelectorImpl</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // File descriptors used for interrupt</span><br><span class="line">    protected int fd0;</span><br><span class="line">    protected int fd1;</span><br><span class="line"></span><br><span class="line">    // The poll object</span><br><span class="line">    EPollArrayWrapper pollWrapper;</span><br><span class="line"></span><br><span class="line">    // Maps from file descriptors to keys</span><br><span class="line">    private Map&lt;Integer,SelectionKeyImpl&gt; fdToKey;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EPollSelectorImpl(SelectorProvider sp) throws IOException &#123;</span><br><span class="line">        super(sp);</span><br><span class="line">        long pipeFds = IOUtil.makePipe(false);</span><br><span class="line">        fd0 = (int) (pipeFds &gt;&gt;&gt; 32);</span><br><span class="line">        fd1 = (int) pipeFds;</span><br><span class="line">        try &#123;</span><br><span class="line">            pollWrapper = new EPollArrayWrapper();</span><br><span class="line">            pollWrapper.initInterrupt(fd0, fd1);</span><br><span class="line">            fdToKey = new HashMap&lt;&gt;();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                FileDispatcherImpl.closeIntFD(fd0);</span><br><span class="line">            &#125; catch (IOException ioe0) &#123;</span><br><span class="line">                t.addSuppressed(ioe0);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                FileDispatcherImpl.closeIntFD(fd1);</span><br><span class="line">            &#125; catch (IOException ioe1) &#123;</span><br><span class="line">                t.addSuppressed(ioe1);</span><br><span class="line">            &#125;</span><br><span class="line">            throw t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>EPollSelectorImpl构造函数完成：<br>① EPollArrayWrapper的构建，EpollArrayWapper将Linux的epoll相关系统调用封装成了native方法供EpollSelectorImpl使用。<br>② 通过EPollArrayWrapper向epoll注册中断事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void initInterrupt(int fd0, int fd1) &#123;</span><br><span class="line">    outgoingInterruptFD = fd1;</span><br><span class="line">    incomingInterruptFD = fd0;</span><br><span class="line">    epollCtl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ fdToKey：构建文件描述符-SelectionKeyImpl映射表，所有注册到selector的channel对应的SelectionKey和与之对应的文件描述符都会放入到该映射表中。</p><h3 id="EPollArrayWrapper"><a href="#EPollArrayWrapper" class="headerlink" title="EPollArrayWrapper"></a>EPollArrayWrapper</h3><p>EPollArrayWrapper完成了对epoll文件描述符的构建，以及对linux系统的epoll指令操纵的封装。维护每次selection操作的结果，即epoll_wait结果的epoll_event数组。<br>EPollArrayWrapper操纵了一个linux系统下epoll_event结构的本地数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* typedef union epoll_data &#123;</span><br><span class="line">*     void *ptr;</span><br><span class="line">*     int fd;</span><br><span class="line">*     __uint32_t u32;</span><br><span class="line">*     __uint64_t u64;</span><br><span class="line">*  &#125; epoll_data_t;</span><br><span class="line">*</span><br><span class="line">* struct epoll_event &#123;</span><br><span class="line">*     __uint32_t events;</span><br><span class="line">*     epoll_data_t data;</span><br><span class="line">* &#125;;</span><br></pre></td></tr></table></figure><p>epoll_event的数据成员(epoll_data_t data)包含有与通过epoll_ctl将文件描述符注册到epoll时设置的数据相同的数据。这里data.fd为我们注册的文件描述符。这样我们在处理事件的时候持有有效的文件描述符了。</p><p>EPollArrayWrapper将Linux的epoll相关系统调用封装成了native方法供EpollSelectorImpl使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private native int epollCreate();</span><br><span class="line">private native void epollCtl(int epfd, int opcode, int fd, int events);</span><br><span class="line">private native int epollWait(long pollAddress, int numfds, long timeout,</span><br><span class="line">                             int epfd) throws IOException;</span><br></pre></td></tr></table></figure><p>上述三个native方法就对应Linux下epoll相关的三个系统调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// The fd of the epoll driver</span><br><span class="line">private final int epfd;</span><br><span class="line"></span><br><span class="line"> // The epoll_event array for results from epoll_wait</span><br><span class="line">private final AllocatedNativeObject pollArray;</span><br><span class="line"></span><br><span class="line">// Base address of the epoll_event array</span><br><span class="line">private final long pollArrayAddress;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 用于存储已经注册的文件描述符和其注册等待改变的事件的关联关系。在epoll_wait操作就是要检测这里文件描述法注册的事件是否有发生。</span><br><span class="line">private final byte[] eventsLow = new byte[MAX_UPDATE_ARRAY_SIZE];</span><br><span class="line">private final Map&lt;Integer,Byte&gt; eventsHigh = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EPollArrayWrapper() throws IOException &#123;</span><br><span class="line">    // creates the epoll file descriptor</span><br><span class="line">    epfd = epollCreate();</span><br><span class="line"></span><br><span class="line">    // the epoll_event array passed to epoll_wait</span><br><span class="line">    int allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;</span><br><span class="line">    pollArray = new AllocatedNativeObject(allocationSize, true);</span><br><span class="line">    pollArrayAddress = pollArray.address();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EPoolArrayWrapper构造函数，创建了epoll文件描述符。构建了一个用于存放epoll_wait返回结果的epoll_event数组。</p><h3 id="ServerSocketChannel的构建"><a href="#ServerSocketChannel的构建" class="headerlink" title="ServerSocketChannel的构建"></a>ServerSocketChannel的构建</h3><p>ServerSocketChannel.open();</p><p>返回ServerSocketChannelImpl对象，构建linux系统下ServerSocket的文件描述符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Our file descriptor</span><br><span class="line">private final FileDescriptor fd;</span><br><span class="line"></span><br><span class="line">// fd value needed for dev/poll. This value will remain valid</span><br><span class="line">// even after the value in the file descriptor object has been set to -1</span><br><span class="line">private int fdVal;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannelImpl(SelectorProvider sp) throws IOException &#123;</span><br><span class="line">    super(sp);</span><br><span class="line">    this.fd =  Net.serverSocket(true);</span><br><span class="line">    this.fdVal = IOUtil.fdVal(fd);</span><br><span class="line">    this.state = ST_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将ServerSocketChannel注册到Selector"><a href="#将ServerSocketChannel注册到Selector" class="headerlink" title="将ServerSocketChannel注册到Selector"></a>将ServerSocketChannel注册到Selector</h3><p>serverChannel.register(selector, SelectionKey.OP_ACCEPT);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final SelectionKey register(Selector sel, int ops,</span><br><span class="line">                                   Object att)</span><br><span class="line">    throws ClosedChannelException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (regLock) &#123;</span><br><span class="line">        if (!isOpen())</span><br><span class="line">            throw new ClosedChannelException();</span><br><span class="line">        if ((ops &amp; ~validOps()) != 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (blocking)</span><br><span class="line">            throw new IllegalBlockingModeException();</span><br><span class="line">        SelectionKey k = findKey(sel);</span><br><span class="line">        if (k != null) &#123;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            k.attach(att);</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            // New registration</span><br><span class="line">            synchronized (keyLock) &#123;</span><br><span class="line">                if (!isOpen())</span><br><span class="line">                    throw new ClosedChannelException();</span><br><span class="line">                k = ((AbstractSelector)sel).register(this, ops, att);</span><br><span class="line">                addKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final SelectionKey register(AbstractSelectableChannel ch,</span><br><span class="line">                                      int ops,</span><br><span class="line">                                      Object attachment)</span><br><span class="line">&#123;</span><br><span class="line">    if (!(ch instanceof SelChImpl))</span><br><span class="line">        throw new IllegalSelectorException();</span><br><span class="line">    SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);</span><br><span class="line">    k.attach(attachment);</span><br><span class="line">    synchronized (publicKeys) &#123;</span><br><span class="line">        implRegister(k);</span><br><span class="line">    &#125;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 构建代表channel和selector间关系的SelectionKey对象<br>② implRegister(k)将channel注册到epoll中<br>③ k.interestOps(int) 完成下面两个操作：<br>a) 会将注册的感兴趣的事件和其对应的文件描述存储到EPollArrayWrapper对象的eventsLow或eventsHigh中，这是给底层实现epoll_wait时使用的。<br>b) 同时该操作还会将设置SelectionKey的interestOps字段，这是给我们程序员获取使用的。</p><h3 id="EPollSelectorImpl-implRegister"><a href="#EPollSelectorImpl-implRegister" class="headerlink" title="EPollSelectorImpl. implRegister"></a>EPollSelectorImpl. implRegister</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void implRegister(SelectionKeyImpl ski) &#123;</span><br><span class="line">    if (closed)</span><br><span class="line">        throw new ClosedSelectorException();</span><br><span class="line">    SelChImpl ch = ski.channel;</span><br><span class="line">    int fd = Integer.valueOf(ch.getFDVal());</span><br><span class="line">    fdToKey.put(fd, ski);</span><br><span class="line">    pollWrapper.add(fd);</span><br><span class="line">    keys.add(ski);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 将channel对应的fd(文件描述符)和对应的SelectionKeyImpl放到fdToKey映射表中。<br>② 将channel对应的fd(文件描述符)添加到EPollArrayWrapper中，并强制初始化fd的事件为0 ( 强制初始更新事件为0，因为该事件可能存在于之前被取消过的注册中。)<br>③ 将selectionKey放入到keys集合中。</p><h3 id="Selection操作"><a href="#Selection操作" class="headerlink" title="Selection操作"></a>Selection操作</h3><p>selection操作有3中类型：<br>① select()：该方法会一直阻塞直到至少一个channel被选择(即，该channel注册的事件发生了)为止，除非当前线程发生中断或者selector的wakeup方法被调用。<br>② select(long time)：该方法和select()类似，该方法也会导致阻塞直到至少一个channel被选择(即，该channel注册的事件发生了)为止，除非下面3种情况任意一种发生：a) 设置的超时时间到达；b) 当前线程发生中断；c) selector的wakeup方法被调用<br>③ selectNow()：该方法不会发生阻塞，如果没有一个channel被选择也会立即返回。</p><p>我们主要来看看select()的实现 ：int n = selector.select();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int select() throws IOException &#123;</span><br><span class="line">    return select(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用到EPollSelectorImpl的doSelect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected int doSelect(long timeout) throws IOException &#123;</span><br><span class="line">    if (closed)</span><br><span class="line">        throw new ClosedSelectorException();</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    try &#123;</span><br><span class="line">        begin();</span><br><span class="line">        pollWrapper.poll(timeout);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line">    processDeregisterQueue();</span><br><span class="line">    int numKeysUpdated = updateSelectedKeys();</span><br><span class="line">    if (pollWrapper.interrupted()) &#123;</span><br><span class="line">        // Clear the wakeup pipe</span><br><span class="line">        pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);</span><br><span class="line">        synchronized (interruptLock) &#123;</span><br><span class="line">            pollWrapper.clearInterrupted();</span><br><span class="line">            IOUtil.drain(fd0);</span><br><span class="line">            interruptTriggered = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 先处理注销的selectionKey队列<br>② 进行底层的epoll_wait操作<br>③ 再次对注销的selectionKey队列进行处理<br>④ 更新被选择的selectionKey</p><p>先来看processDeregisterQueue():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void processDeregisterQueue() throws IOException &#123;</span><br><span class="line">    Set var1 = this.cancelledKeys();</span><br><span class="line">    synchronized(var1) &#123;</span><br><span class="line">        if (!var1.isEmpty()) &#123;</span><br><span class="line">            Iterator var3 = var1.iterator();</span><br><span class="line"></span><br><span class="line">            while(var3.hasNext()) &#123;</span><br><span class="line">                SelectionKeyImpl var4 = (SelectionKeyImpl)var3.next();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    this.implDereg(var4);</span><br><span class="line">                &#125; catch (SocketException var12) &#123;</span><br><span class="line">                    IOException var6 = new IOException(&quot;Error deregistering key&quot;);</span><br><span class="line">                    var6.initCause(var12);</span><br><span class="line">                    throw var6;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    var3.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从cancelledKeys集合中依次取出注销的SelectionKey，执行注销操作，将处理后的SelectionKey从cancelledKeys集合中移除。执行processDeregisterQueue()后cancelledKeys集合会为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void implDereg(SelectionKeyImpl ski) throws IOException &#123;</span><br><span class="line">    assert (ski.getIndex() &gt;= 0);</span><br><span class="line">    SelChImpl ch = ski.channel;</span><br><span class="line">    int fd = ch.getFDVal();</span><br><span class="line">    fdToKey.remove(Integer.valueOf(fd));</span><br><span class="line">    pollWrapper.remove(fd);</span><br><span class="line">    ski.setIndex(-1);</span><br><span class="line">    keys.remove(ski);</span><br><span class="line">    selectedKeys.remove(ski);</span><br><span class="line">    deregister((AbstractSelectionKey)ski);</span><br><span class="line">    SelectableChannel selch = ski.channel();</span><br><span class="line">    if (!selch.isOpen() &amp;&amp; !selch.isRegistered())</span><br><span class="line">        ((SelChImpl)selch).kill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注销会完成下面的操作：<br>① 将已经注销的selectionKey从fdToKey( 文件描述与SelectionKeyImpl的映射表 )中移除<br>② 将selectionKey所代表的channel的文件描述符从EPollArrayWrapper中移除<br>③ 将selectionKey从keys集合中移除，这样下次selector.select()就不会再将该selectionKey注册到epoll中监听<br>④ 也会将selectionKey从对应的channel中注销<br>⑤ 最后如果对应的channel已经关闭并且没有注册其他的selector了，则将该channel关闭<br>完成👆的操作后，注销的SelectionKey就不会出现先在keys、selectedKeys以及cancelKeys这3个集合中的任何一个。</p><p>接着我们来看EPollArrayWrapper.poll(timeout)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int poll(long timeout) throws IOException &#123;</span><br><span class="line">    updateRegistrations();</span><br><span class="line">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class="line">    for (int i=0; i&lt;updated; i++) &#123;</span><br><span class="line">        if (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class="line">            interruptedIndex = i;</span><br><span class="line">            interrupted = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return updated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateRegistrations()方法会将已经注册到该selector的事件(eventsLow或eventsHigh)通过调用epollCtl(epfd, opcode, fd, events); 注册到linux系统中。<br>这里epollWait就会调用linux底层的epoll_wait方法，并返回在epoll_wait期间有事件触发的entry的个数</p><p>再看updateSelectedKeys()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private int updateSelectedKeys() &#123;</span><br><span class="line">    int entries = pollWrapper.updated;</span><br><span class="line">    int numKeysUpdated = 0;</span><br><span class="line">    for (int i=0; i&lt;entries; i++) &#123;</span><br><span class="line">        int nextFD = pollWrapper.getDescriptor(i);</span><br><span class="line">        SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD));</span><br><span class="line">        // ski is null in the case of an interrupt</span><br><span class="line">        if (ski != null) &#123;</span><br><span class="line">            int rOps = pollWrapper.getEventOps(i);</span><br><span class="line">            if (selectedKeys.contains(ski)) &#123;</span><br><span class="line">                if (ski.channel.translateAndSetReadyOps(rOps, ski)) &#123;</span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ski.channel.translateAndSetReadyOps(rOps, ski);</span><br><span class="line">                if ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0) &#123;</span><br><span class="line">                    selectedKeys.add(ski);</span><br><span class="line">                    numKeysUpdated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numKeysUpdated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会从通过EPollArrayWrapper pollWrapper 以及 fdToKey( 构建文件描述符-SelectorKeyImpl映射表 )来获取有事件触发的SelectionKeyImpl对象，然后将SelectionKeyImpl放到selectedKey集合( 有事件触发的selectionKey集合，可以通过selector.selectedKeys()方法获得 )中，即selectedKeys。并重新设置SelectionKeyImpl中相关的readyOps值。</p><p>但是，这里要注意两点：</p><p>① 如果SelectionKeyImpl已经存在于selectedKeys集合中，并且发现触发的事件已经存在于readyOps中了，则不会使numKeysUpdated++；这样会使得我们无法得知该事件的变化。</p><p>👆这点说明了为什么我们要在每次从selectedKey中获取到Selectionkey后，将其从selectedKey集合移除，就是为了当有事件触发使selectionKey能正确到放入selectedKey集合中，并正确的通知给调用者。</p><p>再者，如果不将已经处理的SelectionKey从selectedKey集合中移除，那么下次有新事件到来时，在遍历selectedKey集合时又会遍历到这个SelectionKey，这个时候就很可能出错了。比如，如果没有在处理完OP_ACCEPT事件后将对应SelectionKey从selectedKey集合移除，那么下次遍历selectedKey集合时，处理到到该SelectionKey，相应的ServerSocketChannel.accept()将返回一个空(null)的SocketChannel。</p><p>② 如果发现channel所发生I/O事件不是当前SelectionKey所感兴趣，则不会将SelectionKeyImpl放入selectedKeys集合中，也不会使numKeysUpdated++</p><h3 id="epoll原理"><a href="#epoll原理" class="headerlink" title="epoll原理"></a>epoll原理</h3><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。</p><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)<br>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p><p>注意：linux下Selector底层是通过epoll来实现的，当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p>先看看使用c封装的3个epoll系统调用:</p><ul><li><p><strong>int epoll_create(int size)</strong><br>epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</p></li><li><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong><br>epoll_ctl可以操作epoll_create创建的epoll，如将socket句柄加入到epoll中让其监控，或把epoll正在监控的某个socket句柄移出epoll。</p></li><li><p><strong>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)</strong><br>epoll_wait在调用时，在给定的timeout时间内，所监控的句柄中有事件发生时，就返回用户态的进程。</p><p>大概看看epoll内部是怎么实现的：</p></li></ul><ol><li><p>epoll初始化时，会向内核注册一个文件系统，用于存储被监控的句柄文件，调用epoll_create时，会在这个文件系统中创建一个file节点。同时epoll会开辟自己的内核高速缓存区，以红黑树的结构保存句柄，以支持快速的查找、插入、删除。还会再建立一个list链表，用于存储准备就绪的事件。</p></li><li><p>当执行epoll_ctl时，除了把socket句柄放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后，就把socket插入到就绪链表里。</p></li><li><p>当epoll_wait调用时，仅仅观察就绪链表里有没有数据，如果有数据就返回，否则就sleep，超时时立刻返回。</p><p>epoll的两种工作模式：</p></li></ol><ul><li>LT：level-trigger，水平触发模式，只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket。</li><li>ET：edge-trigger，边缘触发模式，只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。</li></ul><p>socket读数据</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-55ea1cf846c7d84c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp" alt></p><p>socket写数据</p><p><img src="https://upload-images.jianshu.io/upload_images/4235178-39c86c1d52d6abce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/585/format/webp" alt></p><p>最后顺便说下在Linux系统中JDK NIO使用的是 LT ，而Netty epoll使用的是 ET。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为本人对计算机系统组成以及C语言等知识比较欠缺，因为文中相关知识点的表示也相当“肤浅”，如有不对不妥的地方望读者指出。同时我也会继续加强对该方面知识点的学习~</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/0d497fe5484a" target="_blank" rel="noopener">http://www.jianshu.com/p/0d497fe5484a</a><br><a href="https://link.jianshu.com/?t=http://remcarpediem.com/2017/04/02/Netty" target="_blank" rel="noopener">http://remcarpediem.com/2017/04/02/Netty</a>源码-三-I-O模型和Java-NIO底层原理/<br>圣思园netty课程</p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自互联网&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解6：Linux epoll实现原理详解</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A36%EF%BC%9ALinux%20epoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程和NIO详解6：Linux epoll实现原理详解/</id>
    <published>2019-12-13T15:16:43.000Z</published>
    <updated>2021-11-24T08:03:23.998Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><h2 id="为什么要-I-O-多路复用"><a href="#为什么要-I-O-多路复用" class="headerlink" title="为什么要 I/O 多路复用"></a>为什么要 I/O 多路复用</h2><p>当需要从一个叫 <code>r_fd</code> 的描述符不停地读取数据，并把读到的数据写入一个叫 <code>w_fd</code> 的描述符时，我们可以用循环使用阻塞 I/O ：</p><pre><code>while((n = read(r_fd, buf, BUF_SIZE)) &gt; 0)    if(write(w_fd, buf, n) != n)        err_sys(&quot;write error&quot;);</code></pre><p>但是，如果要从两个地方读取数据呢？这时，不能再使用会把程序阻塞住的 <code>read</code> 函数。因为可能在阻塞地等待 <code>r_fd1</code> 的数据时，来不及处理 <code>r_fd2</code>，已经到达的 <code>r_fd2</code> 的数据可能会丢失掉。</p><p>这个情况下需要使用<strong>非阻塞 I/O</strong>。</p><p>只要做个标记，把文件描述符标记为非阻塞的，以后再对它使用 <code>read</code> 函数：如果它还没有数据可读，函数会立即返回并把 errorno 这个变量的值设置为 35，于是我们知道它没有数据可读，然后可以立马去对其他描述符使用 <code>read</code>；如果它有数据可读，我们就读取它数据。对所有要读的描述符都调用了一遍 <code>read</code> 之后，我们可以等一个较长的时间（比如几秒），然后再从第一个文件描述符开始调用 <code>read</code> 。这种循环就叫做<strong>轮询</strong>（polling）。</p><p>这样，不会像使用阻塞 I/O 时那样因为一个描述符 <code>read</code> 长时间处于等待数据而使程序阻塞。</p><p>轮询的缺点是浪费太多 CPU 时间。大多数时候我们没有数据可读，但是还是用了 <code>read</code> 这个<strong>系统调用</strong>，使用系统调用时会从用户态切换到内核态。而大多数情况下我们调用 <code>read</code>，然后陷入内核态，内核发现这个描述符没有准备好，然后切换回用户态并且只得到 EAGAIN （errorno 被设置为 35），做的是无用功。描述符非常多的时候，每次的切换过程就是巨大的浪费。</p><p>所以，需要 <strong>I/O 多路复用</strong>。I/O 多路复用通过使用一个系统函数，同时等待多个描述符的可读、可写状态。</p><p>为了达到这个目的，我们需要做的是：建立一个描述符列表，以及我们分别关心它们的什么事件（可读还是可写还是发生例外情况）；调用一个系统函数，直到这个描述符列表里有至少一个描述符关联的事件发生时，这个函数才会返回。</p><p>select, poll, epoll 就是这样的系统函数。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#select" title="select" target="_blank" rel="noopener"></a>select</h3><p>我们可以在所有 POSIX 兼容的系统里使用 select 函数来进行 I/O 多路复用。我们需要通过 select 函数的参数传递给内核的信息有：</p><pre><code>*   我们关心哪些描述符*   我们关心它们的什么事件*   我们希望等待多长时间</code></pre><p>select 的返回时，内核会告诉我们：</p><pre><code>*   可读的描述符的个数*   哪些描述符发生了哪些事件#include &lt;sys/select.h&gt;int select(int maxfdp1, fd_set* readfds,           fd_set* writefds, fd_set* exceptfds,           struct timeval* timeout);// 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</code></pre><p><code>maxfdp1</code> 意思是 “max file descriptor plus 1” ，就是把你要监视的所有文件描述符里最大的那个加上 1 。（它实际上决定了内核要遍历文件描述符的次数，比如你监视了文件描述符 5 和 20 并把 <code>maxfdp1</code> 设置为 21 ，内核每次都会从描述符 0 依次检查到 20。）</p><p>中间的三个参数是你想监视的文件描述符的集合。可以把 fd_set 类型视为 1024 位的二进制数，这意味着 select 只能监视小于 1024 的文件描述符（1024 是由 Linux 的 sys/select.h 里 <code>FD_SETSIZE</code> 宏设置的值）。在 select 返回后我们通过 <code>FD_ISSET</code> 来判断代表该位的描述符是否是已准备好的状态。</p><p>最后一个参数是等待超时的时长：到达这个时长但是没有任一描述符可用时，函数会返回 0 。</p><p>用一个代码片段来展示 select 的用法：</p><pre><code>// 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态// 初始化两个 fd_set 以及 timevalfd_set read_set, write_set;FD_ZERO(read_set);FD_ZERO(write_set);timeval t;t.tv_sec = 5;   // 超时为 5 秒t.tv_usec = 0;  // 加 0 微秒// 设置好两个 fd_setint fd1 = 3;int fd2 = 4;int fd3 = 5;int maxfdp1 = 5 + 1;FD_SET(fd1, &amp;read_set);FD_SET(fd2, &amp;read_set);FD_SET(fd2, &amp;write_set);FD_SET(fd3, &amp;write_set);// 准备备用的 fd_setfd_set r_temp = read_set;fd_set w_temp = write_set;while(true){    // 每次都要重新设置放入 select 的 fd_set    read_set = r_temp;    write_set = w_temp;    // 使用 select    int n = select(maxfdp1, &amp;read_set, &amp;write_set, NULL, &amp;t);    // 上面的 select 函数会一直阻塞，直到    // 3, 4 可读以及 4, 5 可写这四件事中至少一项发生    // 或者等待时间到达 5 秒，返回 0    for(int i=0; i&lt;maxfdp1 &amp;&amp; n&gt;0; i++){        if(FD_ISSET(i, &amp;read_set)){            n--;            if(i==fd1)                prinf(&quot;描述符 3 可读&quot;);            if(i==fd2)                prinf(&quot;描述符 4 可读&quot;);        }        if(FD_ISSET(i, &amp;write_set)){            n--;            if(i==fd2)                prinf(&quot;描述符 3 可写&quot;);            if(i==fd3)                prinf(&quot;描述符 4 可写&quot;);        }    }    // 上面的 printf 语句换成对应的 read 或者 write 函数就    // 可以立即读取或者写入相应的描述符而不用等待}</code></pre><p>可以看到，select 的缺点有：</p><ul><li>默认能监视的文件描述符不能大于 1024，也代表监视的总数不超过1024。即使你因为需要监视的描述符大于 1024 而改动内核的 <code>FD_SETSIZE</code> 值，但由于 select 是每次都会线性扫描整个fd_set，集合越大速度越慢，所以性能会比较差。</li><li>select 函数返回时只能看见已准备好的描述符数量，至于是哪个描述符准备好了需要循环用 <code>FD_ISSET</code> 来检查，当未准备好的描述符很多而准备好的很少时，效率比较低。</li><li>select 函数每次执行的时候，都把参数里传入的三个 fd_set 从用户空间复制到内核空间。而每次 fd_set 里要监视的描述符变化不大时，全部重新复制一遍并不划算。同样在每次都是未准备好的描述符很多而准备好的很少时，调用 select 会很频繁，用户/内核间的的数据复制就成了一个大的开销。</li></ul><p>还有一个问题是在代码的写法上给我一些困扰的，就是每次调用 select 前必须重新设置三个 fd_set。 fd_set 类型只是 1024 位的二进制数（实际上结构体里是几个 long 变量的数组；比如 64 位机器上 long 是 64 bit，那么 fd_set 里就是 16 个 long 变量的数组），由一位的 1 和 0 代表一个文件描述符的状态，但是其实调用 select 前后位的 1/0 状态意义是不一样的。</p><p>先讲一下几个对 fd_set 操作的函数的作用：<code>FD_ZERO</code> 把 fd_set 所有位设置为 0 ；<code>FD_SET</code> 把一个位设置为 1 ；<code>FD_ISSET</code> 判断一个位是否为 1 。</p><p>调用 select 前：我们用 <code>FD_ZERO</code> 把 fd_set 先全部初始化，然后用 <code>FD_SET</code> 把我们关心的代表描述符的位设置为 1 。我们这时可以用 <code>FD_ISSET</code> 判断这个位是否被我们设置，这时的含义是<strong>我们想要监视的描述符是否被设置为被监视的状态</strong>。</p><p>调用 select 时：内核判断 fd_set 里的位并把各个 fd_set 里所有值为 1 的位记录下来，然后把 fd_set 全部设置成 0 ；一个描述符上有对应的事件发生时，把对应 fd_set 里代表这个描述符的位设置为 1 。</p><p>在 select 返回之后：我们同样用 <code>FD_ISSET</code> 判断各个我们关心的位是 0 还是 1 ，这时的含义是，<strong>这个位是否是发生了我们关心的事件</strong>。</p><p>所以，在下一次调用 select 前，我们不得不把已经被内核改掉的 fd_set 全部重新设置一下。</p><p>select 在监视大量描述符尤其是更多的描述符未准备好的情况时性能很差。《Unix 高级编程》里写，用 select 的程序通常只使用 3 到 10 个描述符。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#poll" title="poll" target="_blank" rel="noopener"></a>poll</h3><p>poll 和 select 是相似的，只是给的接口不同。</p><pre><code>#include &lt;poll.h&gt;int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);// 返回值: 已就绪的描述符的个数。超时时为 0 ，错误时为 -1</code></pre><p><code>fdarray</code> 是 <code>pollfd</code> 的数组。<code>pollfd</code> 结构体是这样的：</p><pre><code>struct pollfd {    int fd;         // 文件描述符    short events;   // 我期待的事件    short revents;  // 实际发生的事件：我期待的事件中发生的；或者异常情况};</code></pre><p><code>nfds</code> 是 <code>fdarray</code> 的长度，也就是 pollfd 的个数。</p><p><code>timeout</code> 代表等待超时的毫秒数。</p><p>相比 select ，poll 有这些优点：由于 poll 在 pollfd 里用 <code>int fd</code> 来表示文件描述符而不像 select 里用的 fd_set 来分别表示描述符，所以没有必须小于 1024 的限制，也没有数量限制；由于 poll 用 <code>events</code> 表示期待的事件，通过修改 <code>revents</code> 来表示发生的事件，所以不需要像 select 在每次调用前重新设置描述符和期待的事件。</p><p>除此之外，poll 和 select 几乎相同。在 poll 返回后，需要遍历 <code>fdarray</code> 来检查各个 <code>pollfd</code> 里的 <code>revents</code> 是否发生了期待的事件；每次调用 poll 时，把 <code>fdarray</code> 复制到内核空间。在描述符太多而每次准备好的较少时，poll 有同样的性能问题。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll" title="epoll" target="_blank" rel="noopener"></a>epoll</h3><p>epoll 是在 Linux 2.5.44 中首度登场的。不像 select 和 poll ，它提供了三个系统函数而不是一个。</p><h4 id="epoll-create-用来创建一个-epoll-描述符："><a href="#epoll-create-用来创建一个-epoll-描述符：" class="headerlink" title="epoll_create 用来创建一个 epoll 描述符："></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll-create-%E7%94%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-epoll-%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9A" title="epoll_create 用来创建一个 epoll 描述符：" target="_blank" rel="noopener"></a>epoll_create 用来创建一个 epoll 描述符：</h4><pre><code>#include &lt;sys/epoll.h&gt;int epoll_create(int size);// 返回值：epoll 描述符</code></pre><p><code>size</code> 用来告诉内核你想监视的文件描述符的数目，但是它<strong>并不是限制了能监视的描述符的最大个数</strong>，而是给内核最初分配的空间一个建议。然后系统会在内核中分配一个空间来存放事件表，并返回一个 <strong>epoll 描述符</strong>，用来操作这个事件表。</p><h4 id="epoll-ctl-用来增-删-改内核中的事件表："><a href="#epoll-ctl-用来增-删-改内核中的事件表：" class="headerlink" title="epoll_ctl 用来增/删/改内核中的事件表："></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll-ctl-%E7%94%A8%E6%9D%A5%E5%A2%9E-%E5%88%A0-%E6%94%B9%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%A1%A8%EF%BC%9A" title="epoll_ctl 用来增/删/改内核中的事件表：" target="_blank" rel="noopener"></a>epoll_ctl 用来增/删/改内核中的事件表：</h4><pre><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);// 返回值：成功时返回 0 ，失败时返回 -1</code></pre><p><code>epfd</code> 是 epoll 描述符。</p><p><code>op</code> 是操作类型（增加/删除/修改）。</p><p><code>fd</code> 是希望监视的文件描述符。</p><p><code>event</code> 是一个 epoll_event 结构体的指针。epoll_event 的定义是这样的：</p><pre><code>typedef union epoll_data {   void        *ptr;   int          fd;   uint32_t     u32;   uint64_t     u64;} epoll_data_t;struct epoll_event {   uint32_t     events;      // 我期待的事件   epoll_data_t data;        // 用户数据变量};</code></pre><p>这个结构体里，除了期待的事件外，还有一个 <code>data</code> ，是一个 union，它是用来让我们在得到下面第三个函数的返回值以后方便的定位文件描述符的。</p><h4 id="epoll-wait-用来等待事件"><a href="#epoll-wait-用来等待事件" class="headerlink" title="epoll_wait 用来等待事件"></a><a href="https://jeff.wtf/2017/02/IO-multiplexing/#epoll-wait-%E7%94%A8%E6%9D%A5%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6" title="epoll_wait 用来等待事件" target="_blank" rel="noopener"></a>epoll_wait 用来等待事件</h4><pre><code>int epoll_wait(int epfd, struct epoll_event *result_events,              int maxevents, int timeout);// 返回值：已就绪的描述符个数。超时时为 0 ，错误时为 -1</code></pre><p><code>epfd</code> 是 epoll 描述符。</p><p><code>result_events</code> 是 epoll_event 结构体的指针，它将指向的是所有已经准备好的事件描述符相关联的 epoll_event（在上个步骤里调用 epoll_ctl 时关联起来的）。下面的例子可以让你知道这个参数的意义。</p><p><code>maxevents</code> 是返回的最大事件个数，也就是你能通过 result_events 指针遍历到的最大的次数。</p><p><code>timeout</code> 是等待超时的毫秒数。</p><p>用一个代码片段来展示 epoll 的用法：<br>    // 这个例子要监控文件描述符 3, 4 的可读状态，以及 4, 5 的可写状态</p><pre><code>/* 通过 epoll_create 创建 epoll 描述符 */int epfd = epoll_create(4);int fd1 = 3;int fd2 = 4;int fd3 = 5;/* 通过 epoll_ctl 注册好四个事件 */struct epoll_event ev1;ev1.events = EPOLLIN;      // 期待它的可读事件发生ev1.data   = fd1;          // 我们通常就把 data 设置为 fd ，方便以后查看epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &amp;ev1);  // 添加到事件表struct epoll_event ev2;ev2.events = EPOLLIN;ev2.data   = fd2;epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev2);struct epoll_event ev3;ev3.events = EPOLLOUT;     // 期待它的可写事件发生ev3.data   = fd2;epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &amp;ev3);struct epoll_event ev4;ev4.events = EPOLLOUT;ev4.data   = fd3;epoll_ctl(epfd, EPOLL_CTL_ADD, fd3, &amp;ev4);/* 通过 epoll_wait 等待事件 */# DEFINE MAXEVENTS 4struct epoll_event result_events[MAXEVENTS];while(true){    int n = epoll_wait(epfd, &amp;result_events, MAXEVENTS, 5000);    for(int i=0; i&lt;n; n--){        // result_events[i] 一定是 ev1 到 ev4 中的一个        if(result_events[i].events&amp;EPOLLIN)            printf(&quot;描述符 %d 可读&quot;, result_events[i].fd);        else if(result_events[i].events&amp;EPOLLOUT)            printf(&quot;描述符 %d 可写&quot;, result_events[i].fd)    }}</code></pre><p>所以 epoll 解决了 poll 和 select 的问题：</p><ul><li><p>只在 epoll_ctl 的时候把数据复制到内核空间，这保证了每个描述符和事件一定只会被复制到内核空间一次；每次调用 epoll_wait 都不会复制新数据到内核空间。相比之下，select 每次调用都会把三个 fd_set 复制一遍；poll 每次调用都会把 <code>fdarray</code> 复制一遍。</p></li><li><p>epoll_wait 返回 n ，那么只需要做 n 次循环，可以保证遍历的每一次都是有意义的。相比之下，select 需要做至少 n 次至多 <code>maxfdp1</code> 次循环；poll 需要遍历完 fdarray 即做 <code>nfds</code> 次循环。</p></li><li><p>在内部实现上，epoll 使用了回调的方法。调用 epoll_ctl 时，就是注册了一个事件：在集合中放入文件描述符以及事件数据，并且加上一个回调函数。一旦文件描述符上的对应事件发生，就会调用回调函数，这个函数会把这个文件描述符加入到<strong>就绪队列</strong>上。当你调用 epoll_wait 时，它只是在查看就绪队列上是否有内容，有的话就返回给你的程序。<code>select()</code> <code>poll()</code> <code>epoll_wait()</code> 三个函数在操作系统看来，都是睡眠一会儿然后判断一会儿的循环，但是 select 和 poll 在醒着的时候要遍历整个文件描述符集合，而 epoll_wait 只是看看就绪队列是否为空而已。这是 epoll 高性能的理由，使得其 I/O 的效率不会像使用轮询的 select/poll 随着描述符增加而大大降低。</p></li></ul><blockquote><p>注 1 ：select/poll/epoll_wait 三个函数的等待超时时间都有一样的特性：等待时间设置为 0 时函数不阻塞而是立即返回，不论是否有文件描述符已准备好；poll/epoll_wait 中的 timeout 为 -1，select 中的 timeout 为 NULL 时，则无限等待，直到有描述符已准备好才会返回。</p></blockquote><blockquote><p>注 2 ：有的新手会把文件描述符是否标记为阻塞 I/O 等同于 I/O 多路复用函数是否阻塞。其实文件描述符是否标记为阻塞，决定了你 <code>read</code> 或 <code>write</code> 它时如果它未准备好是阻塞等待，还是立即返回 EAGAIN ；而 I/O 多路复用函数除非你把 timeout 设置为 0 ，否则它总是会阻塞住你的程序。</p></blockquote><blockquote><p>注 3 ：上面的例子只是入门，可能是不准确或不全面的：一是数据要立即处理防止丢失；二是 EPOLLIN/EPOLLOUT 不完全等同于可读可写事件，具体要去搜索 poll/epoll 的事件具体有哪些；三是大多数实际例子里，比如一个 tcp server ，都会在运行中不断增加/删除的文件描述符而不是记住固定的 3 4 5 几个描述符（用这种例子更能看出 epoll 的优势）；四是 epoll 的优势更多的体现在处理大量闲连接的情况，如果场景是处理少量短连接，用 select 反而更好，而且用 select 的代码能运行在所有平台上。</p></blockquote><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解5：Java 非阻塞 IO 和异步 IO</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A35%EF%BC%9AJava%20%E9%9D%9E%E9%98%BB%E5%A1%9E%20IO%20%E5%92%8C%E5%BC%82%E6%AD%A5%20IO/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程和NIO详解5：Java 非阻塞 IO 和异步 IO/</id>
    <published>2019-12-13T15:15:43.000Z</published>
    <updated>2021-11-24T08:03:23.997Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><p>上一篇文章介绍了 Java NIO 中 Buffer、Channel 和 Selector 的基本操作，主要是一些接口操作，比较简单。</p><p>本文将介绍<strong>非阻塞 IO</strong> 和<strong>异步 IO</strong>，也就是大家耳熟能详的 NIO 和 AIO。很多初学者可能分不清楚异步和非阻塞的区别，只是在各种场合能听到<strong>异步非阻塞</strong>这个词。</p><p>本文会先介绍并演示阻塞模式，然后引入非阻塞模式来对阻塞模式进行优化，最后再介绍 JDK7 引入的异步 IO，由于网上关于异步 IO 的介绍相对较少，所以这部分内容我会介绍得具体一些。</p><p>希望看完本文，读者可以对非阻塞 IO 和异步 IO 的迷雾看得更清晰些，或者为初学者解开一丝丝疑惑也是好的。</p><h2 id="阻塞模式-IO"><a href="#阻塞模式-IO" class="headerlink" title="阻塞模式 IO"></a>阻塞模式 IO</h2><p>我们已经介绍过使用 Java NIO 包组成一个简单的<strong>客户端-服务端</strong>网络通讯所需要的 ServerSocketChannel、SocketChannel 和 Buffer，我们这里整合一下它们，给出一个完整的可运行的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        // 监听 8080 端口进来的 TCP 链接</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(8080));</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            // 这里会阻塞，直到有一个请求的连接进来</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">            // 开启一个新的线程来处理这个请求，然后在 while 循环中继续监听 8080 端口</span><br><span class="line">            SocketHandler handler = new SocketHandler(socketChannel);</span><br><span class="line">            new Thread(handler).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看一下新的线程需要做什么，SocketHandler：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SocketHandler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    public SocketHandler(SocketChannel socketChannel) &#123;</span><br><span class="line">        this.socketChannel = socketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将请求数据读入 Buffer 中</span><br><span class="line">            int num;</span><br><span class="line">            while ((num = socketChannel.read(buffer)) &gt; 0) &#123;</span><br><span class="line">                // 读取 Buffer 内容之前先 flip 一下</span><br><span class="line">                buffer.flip();</span><br><span class="line"></span><br><span class="line">                // 提取 Buffer 中的数据</span><br><span class="line">                byte[] bytes = new byte[num];</span><br><span class="line">                buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">                String re = new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">                System.out.println(&quot;收到请求：&quot; + re);</span><br><span class="line"></span><br><span class="line">                // 回应客户端</span><br><span class="line">                ByteBuffer writeBuffer = ByteBuffer.wrap((&quot;我已经收到你的请求，你的请求内容是：&quot; + re).getBytes());</span><br><span class="line">                socketChannel.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            IOUtils.closeQuietly(socketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，贴一下客户端 SocketChannel 的使用，客户端比较简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SocketChannelTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br><span class="line"></span><br><span class="line">        // 发送请求</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(&quot;1234567890&quot;.getBytes());</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">        // 读取响应</span><br><span class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">        int num;</span><br><span class="line">        if ((num = socketChannel.read(readBuffer)) &gt; 0) &#123;</span><br><span class="line">            readBuffer.flip();</span><br><span class="line"></span><br><span class="line">            byte[] re = new byte[num];</span><br><span class="line">            readBuffer.get(re);</span><br><span class="line"></span><br><span class="line">            String result = new String(re, &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot;返回值: &quot; + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍的阻塞模式的代码应该很好理解：来一个新的连接，我们就新开一个线程来处理这个连接，之后的操作全部由那个线程来完成。</p><p>那么，这个模式下的性能瓶颈在哪里呢？</p><ol><li>首先，每次来一个连接都开一个新的线程这肯定是不合适的。当活跃连接数在几十几百的时候当然是可以这样做的，但如果活跃连接数是几万几十万的时候，这么多线程明显就不行了。每个线程都需要一部分内存，内存会被迅速消耗，同时，线程切换的开销非常大。</li><li>其次，阻塞操作在这里也是一个问题。首先，accept() 是一个阻塞操作，当 accept() 返回的时候，代表有一个连接可以使用了，我们这里是马上就新建线程来处理这个 SocketChannel 了，但是，但是这里不代表对方就将数据传输过来了。所以，SocketChannel#read 方法将阻塞，等待数据，明显这个等待是不值得的。同理，write 方法也需要等待通道可写才能执行写入操作，这边的阻塞等待也是不值得的。</li></ol><h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>说完了阻塞模式的使用及其缺点以后，我们这里就可以介绍非阻塞 IO 了。</p><p>非阻塞 IO 的核心在于使用一个 Selector 来管理多个通道，可以是 SocketChannel，也可以是 ServerSocketChannel，将各个通道注册到 Selector 上，指定监听的事件。</p><p>之后可以只用一个线程来轮询这个 Selector，看看上面是否有通道是准备好的，当通道准备好可读或可写，然后才去开始真正的读写，这样速度就很快了。我们就完全没有必要给每个通道都起一个线程。</p><p>NIO 中 Selector 是对底层操作系统实现的一个抽象，管理通道状态其实都是底层系统实现的，这里简单介绍下在不同系统下的实现。</p><p><strong>select</strong>：上世纪 80 年代就实现了，它支持注册 FD_SETSIZE(1024) 个 socket，在那个年代肯定是够用的，不过现在嘛，肯定是不行了。</p><p><strong>poll</strong>：1997 年，出现了 poll 作为 select 的替代者，最大的区别就是，poll 不再限制 socket 数量。</p><p>select 和 poll 都有一个共同的问题，那就是<strong>它们都只会告诉你有几个通道准备好了，但是不会告诉你具体是哪几个通道</strong>。所以，一旦知道有通道准备好以后，自己还是需要进行一次扫描，显然这个不太好，通道少的时候还行，一旦通道的数量是几十万个以上的时候，扫描一次的时间都很可观了，时间复杂度 O(n)。所以，后来才催生了以下实现。</p><p><strong>epoll</strong>：2002 年随 Linux 内核 2.5.44 发布，epoll 能直接返回具体的准备好的通道，时间复杂度 O(1)。</p><p>除了 Linux 中的 epoll，2000 年 FreeBSD 出现了 <strong>Kqueue</strong>，还有就是，Solaris 中有 <strong>/dev/poll</strong>。</p><blockquote><p>前面说了那么多实现，但是没有出现 Windows，Windows 平台的非阻塞 IO 使用 select，我们也不必觉得 Windows 很落后，在 Windows 中 IOCP 提供的异步 IO 是比较强大的。</p></blockquote><p>我们回到 Selector，毕竟 JVM 就是这么一个屏蔽底层实现的平台，<strong>我们面向 Selector 编程就可以了</strong>。</p><p>之前在介绍 Selector 的时候已经了解过了它的基本用法，这边来一个可运行的实例代码，大家不妨看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class SelectorServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.socket().bind(new InetSocketAddress(8080));</span><br><span class="line"></span><br><span class="line">        // 将其注册到 Selector 中，监听 OP_ACCEPT 事件</span><br><span class="line">        server.configureBlocking(false);</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int readyChannels = selector.select();</span><br><span class="line">            if (readyChannels == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">            // 遍历</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    // 有已经接受的新的到服务端的连接</span><br><span class="line">                    SocketChannel socketChannel = server.accept();</span><br><span class="line"></span><br><span class="line">                    // 有新的连接并不代表这个通道就有数据，</span><br><span class="line">                    // 这里将这个新的 SocketChannel 注册到 Selector，监听 OP_READ 事件，等待数据</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                    // 有数据可读</span><br><span class="line">                    // 上面一个 if 分支中注册了监听 OP_READ 事件的 SocketChannel</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer readBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    int num = socketChannel.read(readBuffer);</span><br><span class="line">                    if (num &gt; 0) &#123;</span><br><span class="line">                        // 处理进来的数据...</span><br><span class="line">                        System.out.println(&quot;收到数据：&quot; + new String(readBuffer.array()).trim());</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.wrap(&quot;返回给客户端的数据...&quot;.getBytes());</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125; else if (num == -1) &#123;</span><br><span class="line">                        // -1 代表连接已经关闭</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于客户端，大家可以继续使用上一节介绍阻塞模式时的客户端进行测试。</p><h2 id="NIO-2-异步-IO"><a href="#NIO-2-异步-IO" class="headerlink" title="NIO.2 异步 IO"></a>NIO.2 异步 IO</h2><p>More New IO，或称 NIO.2，随 JDK 1.7 发布，包括了引入异步 IO 接口和 Paths 等文件访问接口。</p><p>异步这个词，我想对于绝大多数开发者来说都很熟悉，很多场景下我们都会使用异步。</p><p>通常，我们会有一个线程池用于执行异步任务，提交任务的线程将任务提交到线程池就可以立马返回，不必等到任务真正完成。如果想要知道任务的执行结果，通常是通过传递一个回调函数的方式，任务结束后去调用这个函数。</p><p>同样的原理，Java 中的异步 IO 也是一样的，都是由一个线程池来负责执行任务，然后使用回调或自己去查询结果。</p><p>大部分开发者都知道为什么要这么设计了，这里再啰嗦一下。异步 IO 主要是为了控制线程数量，减少过多的线程带来的内存消耗和 CPU 在线程调度上的开销。</p><p><strong>在 Unix/Linux 等系统中，JDK 使用了并发包中的线程池来管理任务</strong>，具体可以查看 AsynchronousChannelGroup 的源码。</p><p>在 Windows 操作系统中，提供了一个叫做 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx" target="_blank" rel="noopener">I/O Completion Ports</a> 的方案，通常简称为 <strong>IOCP</strong>，操作系统负责管理线程池，其性能非常优异，所以<strong>在 Windows 中 JDK 直接采用了 IOCP 的支持</strong>，使用系统支持，把更多的操作信息暴露给操作系统，也使得操作系统能够对我们的 IO 进行一定程度的优化。</p><blockquote><p>在 Linux 中其实也是有异步 IO 系统实现的，但是限制比较多，性能也一般，所以 JDK 采用了自建线程池的方式。</p></blockquote><p>本文还是以实用为主，想要了解更多信息请自行查找其他资料，下面对 Java 异步 IO 进行实践性的介绍。</p><p>总共有三个类需要我们关注，分别是 <strong>AsynchronousSocketChannel</strong>，<strong>AsynchronousServerSocketChannel</strong> 和 <strong>AsynchronousFileChannel</strong>，只不过是在之前介绍的 FileChannel、SocketChannel 和 ServerSocketChannel 的类名上加了个前缀 <strong>Asynchronous</strong>。</p><p>Java 异步 IO 提供了两种使用方式，分别是返回 Future 实例和使用回调函数。</p><h3 id="1、返回-Future-实例"><a href="#1、返回-Future-实例" class="headerlink" title="1、返回 Future 实例"></a>1、返回 Future 实例</h3><p>返回 java.util.concurrent.Future 实例的方式我们应该很熟悉，JDK 线程池就是这么使用的。Future 接口的几个方法语义在这里也是通用的，这里先做简单介绍。</p><ul><li><p>future.isDone();</p><p>判断操作是否已经完成，包括了<strong>正常完成、异常抛出、取消</strong></p></li><li><p>future.cancel(true);</p><p>取消操作，方式是中断。参数 true 说的是，即使这个任务正在执行，也会进行中断。</p></li><li><p>future.isCancelled();</p><p>是否被取消，只有在任务正常结束之前被取消，这个方法才会返回 true</p></li><li><p>future.get();</p><p>这是我们的老朋友，获取执行结果，阻塞。</p></li><li><p>future.get(10, TimeUnit.SECONDS);</p><p>如果上面的 get() 方法的阻塞你不满意，那就设置个超时时间。</p></li></ul><h3 id="2、提供-CompletionHandler-回调函数"><a href="#2、提供-CompletionHandler-回调函数" class="headerlink" title="2、提供 CompletionHandler 回调函数"></a>2、提供 CompletionHandler 回调函数</h3><p>java.nio.channels.CompletionHandler 接口定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface CompletionHandler&lt;V,A&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void completed(V result, A attachment);</span><br><span class="line"></span><br><span class="line">    void failed(Throwable exc, A attachment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，参数上有个 attachment，虽然不常用，我们可以在各个支持的方法中传递这个参数值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel listener = AsynchronousServerSocketChannel.open().bind(null);</span><br><span class="line"></span><br><span class="line">// accept 方法的第一个参数可以传递 attachment</span><br><span class="line">listener.accept(attachment, new CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">    public void completed(</span><br><span class="line">      AsynchronousSocketChannel client, Object attachment) &#123;</span><br><span class="line">          // </span><br><span class="line">      &#125;</span><br><span class="line">    public void failed(Throwable exc, Object attachment) &#123;</span><br><span class="line">          // </span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h3><p>网上关于 Non-Blocking IO 的介绍文章很多，但是 Asynchronous IO 的文章相对就少得多了，所以我这边会多介绍一些相关内容。</p><p>首先，我们就来关注异步的文件 IO，前面我们说了，文件 IO 在所有的操作系统中都不支持非阻塞模式，但是我们可以对文件 IO 采用异步的方式来提高性能。</p><p>下面，我会介绍 AsynchronousFileChannel 里面的一些重要的接口，都很简单，读者要是觉得无趣，直接滑到下一个标题就可以了。</p><p>实例化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(&quot;/Users/hongjie/test.txt&quot;));</span><br></pre></td></tr></table></figure><p>一旦实例化完成，我们就可以着手准备将数据读入到 Buffer 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">Future&lt;Integer&gt; result = channel.read(buffer, 0);</span><br></pre></td></tr></table></figure><blockquote><p>异步文件通道的读操作和写操作都需要提供一个文件的开始位置，文件开始位置为 0</p></blockquote><p>除了使用返回 Future 实例的方式，也可以采用回调函数进行操作，接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract &lt;A&gt; void read(ByteBuffer dst,</span><br><span class="line">                              long position,</span><br><span class="line">                              A attachment,</span><br><span class="line">                              CompletionHandler&lt;Integer,? super A&gt; handler);</span><br></pre></td></tr></table></figure><p>顺便也贴一下写操作的两个版本的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract Future&lt;Integer&gt; write(ByteBuffer src, long position);</span><br><span class="line"></span><br><span class="line">public abstract &lt;A&gt; void write(ByteBuffer src,</span><br><span class="line">                               long position,</span><br><span class="line">                               A attachment,</span><br><span class="line">                               CompletionHandler&lt;Integer,? super A&gt; handler);</span><br></pre></td></tr></table></figure><p>我们可以看到，AIO 的读写主要也还是与 Buffer 打交道，这个与 NIO 是一脉相承的。</p><p>另外，还提供了用于将内存中的数据刷入到磁盘的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void force(boolean metaData) throws IOException;</span><br></pre></td></tr></table></figure><blockquote><p>因为我们对文件的写操作，操作系统并不会直接针对文件操作，系统会缓存，然后周期性地刷入到磁盘。如果希望将数据及时写入到磁盘中，以免断电引发部分数据丢失，可以调用此方法。参数如果设置为 true，意味着同时也将文件属性信息更新到磁盘。</p></blockquote><p>还有，还提供了对文件的锁定功能，我们可以锁定文件的部分数据，这样可以进行排他性的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract Future&lt;FileLock&gt; lock(long position, long size, boolean shared);</span><br></pre></td></tr></table></figure><blockquote><p>position 是要锁定内容的开始位置，size 指示了要锁定的区域大小，shared 指示需要的是共享锁还是排他锁</p></blockquote><p>当然，也可以使用回调函数的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract &lt;A&gt; void lock(long position,</span><br><span class="line">                              long size,</span><br><span class="line">                              boolean shared,</span><br><span class="line">                              A attachment,</span><br><span class="line">                              CompletionHandler&lt;FileLock,? super A&gt; handler);</span><br></pre></td></tr></table></figure><p>文件锁定功能上还提供了 tryLock 方法，此方法会快速返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract FileLock tryLock(long position, long size, boolean shared)</span><br><span class="line">    throws IOException;</span><br></pre></td></tr></table></figure><blockquote><p>这个方法很简单，就是尝试去获取锁，如果该区域已被其他线程或其他应用锁住，那么立刻返回 null，否则返回 FileLock 对象。</p></blockquote><p>AsynchronousFileChannel 操作大体上也就以上介绍的这些接口，还是比较简单的，这里就少一些废话早点结束好了。</p><h3 id="AsynchronousServerSocketChannel"><a href="#AsynchronousServerSocketChannel" class="headerlink" title="AsynchronousServerSocketChannel"></a>AsynchronousServerSocketChannel</h3><p>这个类对应的是非阻塞 IO 的 ServerSocketChannel，大家可以类比下使用方式。</p><p>我们就废话少说，用代码说事吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package com.javadoop.aio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">          // 实例化，并监听端口</span><br><span class="line">        AsynchronousServerSocketChannel server =</span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(8080));</span><br><span class="line"></span><br><span class="line">        // 自己定义一个 Attachment 类，用于传递一些信息</span><br><span class="line">        Attachment att = new Attachment();</span><br><span class="line">        att.setServer(server);</span><br><span class="line"></span><br><span class="line">        server.accept(att, new CompletionHandler&lt;AsynchronousSocketChannel, Attachment&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(AsynchronousSocketChannel client, Attachment att) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    SocketAddress clientAddr = client.getRemoteAddress();</span><br><span class="line">                    System.out.println(&quot;收到新的连接：&quot; + clientAddr);</span><br><span class="line"></span><br><span class="line">                    // 收到新的连接后，server 应该重新调用 accept 方法等待新的连接进来</span><br><span class="line">                    att.getServer().accept(att, this);</span><br><span class="line"></span><br><span class="line">                    Attachment newAtt = new Attachment();</span><br><span class="line">                    newAtt.setServer(server);</span><br><span class="line">                    newAtt.setClient(client);</span><br><span class="line">                    newAtt.setReadMode(true);</span><br><span class="line">                    newAtt.setBuffer(ByteBuffer.allocate(2048));</span><br><span class="line"></span><br><span class="line">                    // 这里也可以继续使用匿名实现类，不过代码不好看，所以这里专门定义一个类</span><br><span class="line">                    client.read(newAtt.getBuffer(), newAtt, new ChannelHandler());</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable t, Attachment att) &#123;</span><br><span class="line">                System.out.println(&quot;accept failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 为了防止 main 线程退出</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.currentThread().join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 ChannelHandler 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.javadoop.aio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class ChannelHandler implements CompletionHandler&lt;Integer, Attachment&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, Attachment att) &#123;</span><br><span class="line">        if (att.isReadMode()) &#123;</span><br><span class="line">            // 读取来自客户端的数据</span><br><span class="line">            ByteBuffer buffer = att.getBuffer();</span><br><span class="line">            buffer.flip();</span><br><span class="line">            byte bytes[] = new byte[buffer.limit()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            String msg = new String(buffer.array()).toString().trim();</span><br><span class="line">            System.out.println(&quot;收到来自客户端的数据: &quot; + msg);</span><br><span class="line"></span><br><span class="line">            // 响应客户端请求，返回数据</span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(&quot;Response from server!&quot;.getBytes(Charset.forName(&quot;UTF-8&quot;)));</span><br><span class="line">            att.setReadMode(false);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            // 写数据到客户端也是异步</span><br><span class="line">            att.getClient().write(buffer, att, this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 到这里，说明往客户端写数据也结束了，有以下两种选择:</span><br><span class="line">            // 1\. 继续等待客户端发送新的数据过来</span><br><span class="line">//            att.setReadMode(true);</span><br><span class="line">//            att.getBuffer().clear();</span><br><span class="line">//            att.getClient().read(att.getBuffer(), att, this);</span><br><span class="line">            // 2\. 既然服务端已经返回数据给客户端，断开这次的连接</span><br><span class="line">            try &#123;</span><br><span class="line">                att.getClient().close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable t, Attachment att) &#123;</span><br><span class="line">        System.out.println(&quot;连接断开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便再贴一下自定义的 Attachment 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Attachment &#123;</span><br><span class="line">    private AsynchronousServerSocketChannel server;</span><br><span class="line">    private AsynchronousSocketChannel client;</span><br><span class="line">    private boolean isReadMode;</span><br><span class="line">    private ByteBuffer buffer;</span><br><span class="line">    // getter &amp; setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的服务端就写好了，接下来可以接收客户端请求了。上面我们用的都是回调函数的方式，读者要是感兴趣，可以试试写个使用 Future 的。</p><h3 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h3><p>其实，说完上面的 AsynchronousServerSocketChannel，基本上读者也就知道怎么使用 AsynchronousSocketChannel 了，和非阻塞 IO 基本类似。</p><p>这边做个简单演示，这样读者就可以配合之前介绍的 Server 进行测试使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.javadoop.aio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        AsynchronousSocketChannel client = AsynchronousSocketChannel.open();</span><br><span class="line">          // 来个 Future 形式的</span><br><span class="line">        Future&lt;?&gt; future = client.connect(new InetSocketAddress(8080));</span><br><span class="line">        // 阻塞一下，等待连接成功</span><br><span class="line">        future.get();</span><br><span class="line"></span><br><span class="line">        Attachment att = new Attachment();</span><br><span class="line">        att.setClient(client);</span><br><span class="line">        att.setReadMode(false);</span><br><span class="line">        att.setBuffer(ByteBuffer.allocate(2048));</span><br><span class="line">        byte[] data = &quot;I am obot!&quot;.getBytes();</span><br><span class="line">        att.getBuffer().put(data);</span><br><span class="line">        att.getBuffer().flip();</span><br><span class="line"></span><br><span class="line">        // 异步发送数据到服务端</span><br><span class="line">        client.write(att.getBuffer(), att, new ClientChannelHandler());</span><br><span class="line"></span><br><span class="line">        // 这里休息一下再退出，给出足够的时间处理数据</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往里面看下 ClientChannelHandler 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.javadoop.aio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line">public class ClientChannelHandler implements CompletionHandler&lt;Integer, Attachment&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, Attachment att) &#123;</span><br><span class="line">        ByteBuffer buffer = att.getBuffer();</span><br><span class="line">        if (att.isReadMode()) &#123;</span><br><span class="line">            // 读取来自服务端的数据</span><br><span class="line">            buffer.flip();</span><br><span class="line">            byte[] bytes = new byte[buffer.limit()];</span><br><span class="line">            buffer.get(bytes);</span><br><span class="line">            String msg = new String(bytes, Charset.forName(&quot;UTF-8&quot;));</span><br><span class="line">            System.out.println(&quot;收到来自服务端的响应数据: &quot; + msg);</span><br><span class="line"></span><br><span class="line">            // 接下来，有以下两种选择:</span><br><span class="line">            // 1\. 向服务端发送新的数据</span><br><span class="line">//            att.setReadMode(false);</span><br><span class="line">//            buffer.clear();</span><br><span class="line">//            String newMsg = &quot;new message from client&quot;;</span><br><span class="line">//            byte[] data = newMsg.getBytes(Charset.forName(&quot;UTF-8&quot;));</span><br><span class="line">//            buffer.put(data);</span><br><span class="line">//            buffer.flip();</span><br><span class="line">//            att.getClient().write(buffer, att, this);</span><br><span class="line">            // 2\. 关闭连接</span><br><span class="line">            try &#123;</span><br><span class="line">                att.getClient().close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 写操作完成后，会进到这里</span><br><span class="line">            att.setReadMode(true);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            att.getClient().read(buffer, att, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable t, Attachment att) &#123;</span><br><span class="line">        System.out.println(&quot;服务器无响应&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码都是可以运行调试的，如果读者碰到问题，请在评论区留言。</p><h3 id="Asynchronous-Channel-Groups"><a href="#Asynchronous-Channel-Groups" class="headerlink" title="Asynchronous Channel Groups"></a>Asynchronous Channel Groups</h3><p>为了知识的完整性，有必要对 group 进行介绍，其实也就是介绍 AsynchronousChannelGroup 这个类。之前我们说过，异步 IO 一定存在一个线程池，这个线程池负责接收任务、处理 IO 事件、回调等。这个线程池就在 group 内部，group 一旦关闭，那么相应的线程池就会关闭。</p><p>AsynchronousServerSocketChannels 和 AsynchronousSocketChannels 是属于 group 的，当我们调用 AsynchronousServerSocketChannel 或 AsynchronousSocketChannel 的 open() 方法的时候，相应的 channel 就属于默认的 group，这个 group 由 JVM 自动构造并管理。</p><p>如果我们想要配置这个默认的 group，可以在 JVM 启动参数中指定以下系统变量：</p><ul><li><p>java.nio.channels.DefaultThreadPool.threadFactory</p><p>此系统变量用于设置 ThreadFactory，它应该是 java.util.concurrent.ThreadFactory 实现类的全限定类名。一旦我们指定了这个 ThreadFactory 以后，group 中的线程就会使用该类产生。</p></li><li><p>java.nio.channels.DefaultThreadPool.initialSize</p><p>此系统变量也很好理解，用于设置线程池的初始大小。</p></li></ul><p>可能你会想要使用自己定义的 group，这样可以对其中的线程进行更多的控制，使用以下几个方法即可：</p><ul><li>AsynchronousChannelGroup.withCachedThreadPool(ExecutorService executor, int initialSize)</li><li>AsynchronousChannelGroup.withFixedThreadPool(int nThreads, ThreadFactory threadFactory)</li><li>AsynchronousChannelGroup.withThreadPool(ExecutorService executor)</li></ul><p>熟悉线程池的读者对这些方法应该很好理解，它们都是 AsynchronousChannelGroup 中的静态方法。</p><p>至于 group 的使用就很简单了，代码一看就懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousChannelGroup group = AsynchronousChannelGroup</span><br><span class="line">        .withFixedThreadPool(10, Executors.defaultThreadFactory());</span><br><span class="line">AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group);</span><br><span class="line">AsynchronousSocketChannel client = AsynchronousSocketChannel.open(group);</span><br></pre></td></tr></table></figure><p><strong>AsynchronousFileChannels 不属于 group</strong>。但是它们也是关联到一个线程池的，如果不指定，会使用系统默认的线程池，如果想要使用指定的线程池，可以在实例化的时候使用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static AsynchronousFileChannel open(Path file,</span><br><span class="line">                                           Set&lt;? extends OpenOption&gt; options,</span><br><span class="line">                                           ExecutorService executor,</span><br><span class="line">                                           FileAttribute&lt;?&gt;... attrs) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，异步 IO 就算介绍完成了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我想，本文应该是说清楚了非阻塞 IO 和异步 IO 了，对于异步 IO，由于网上的资料比较少，所以不免篇幅多了些。</p><p>我们也要知道，看懂了这些，确实可以学到一些东西，多了解一些知识，但是我们还是很少在工作中将这些知识变成工程代码。一般而言，我们需要在网络应用中使用 NIO 或 AIO 来提升性能，但是，在工程上，绝不是了解了一些概念，知道了一些接口就可以的，需要处理的细节还非常多。</p><p>这也是为什么 Netty/Mina 如此盛行的原因，因为它们帮助封装好了很多细节，提供给我们用户友好的接口，后面有时间我也会对 Netty 进行介绍。</p><p>（全文完）</p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解4：浅析NIO包中的Buffer、Channel 和 Selector</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E8%AF%A6%E8%A7%A34%EF%BC%9A%E6%B5%85%E6%9E%90NIO%E5%8C%85%E4%B8%AD%E7%9A%84Buffer%E3%80%81Channel%20%E5%92%8C%20Selector/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程与NIO详解4：浅析NIO包中的Buffer、Channel 和 Selector/</id>
    <published>2019-12-13T15:14:43.000Z</published>
    <updated>2021-11-24T08:03:23.994Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转载自互联网</p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><p>本文将介绍 Java NIO 中三大组件 <strong>Buffer、Channel、Selector</strong> 的使用。</p><p>本来要一起介绍<strong>非阻塞 IO</strong> 和 JDK7 的<strong>异步 IO</strong> 的，不过因为之前的文章真的太长了，有点影响读者阅读，所以这里将它们放到另一篇文章中进行介绍。</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。</p><p>java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。</p><p><img src="https://www.javadoop.com/blogimages/nio/6.png" alt="6"></p><p>其实核心是最后的 <strong>ByteBuffer</strong>，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。</p><p>我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。</p><p>MappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。</p><p>我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。</p><h3 id="position、limit、capacity"><a href="#position、limit、capacity" class="headerlink" title="position、limit、capacity"></a>position、limit、capacity</h3><p>就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。</p><p><img src="https://www.javadoop.com/blogimages/nio/5.png" alt="5"></p><p>最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。</p><p>position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。</p><p><strong>position</strong> 的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。</p><p>从写操作模式到读操作模式切换的时候（<strong>flip</strong>），position 都会归零，这样就可以从头开始读写了。</p><p><strong>Limit</strong>：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。</p><p><img src="https://www.javadoop.com/blogimages/nio/7.png" alt="7"></p><h3 id="初始化-Buffer"><a href="#初始化-Buffer" class="headerlink" title="初始化 Buffer"></a>初始化 Buffer</h3><p>每个 Buffer 实现类都提供了一个静态方法 <code>allocate(int capacity)</code> 帮助我们快速实例化一个 Buffer。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuf = ByteBuffer.allocate(1024);</span><br><span class="line">IntBuffer intBuf = IntBuffer.allocate(1024);</span><br><span class="line">LongBuffer longBuf = LongBuffer.allocate(1024);</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>另外，我们经常使用 wrap 方法来初始化一个 Buffer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ByteBuffer wrap(byte[] array) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="填充-Buffer"><a href="#填充-Buffer" class="headerlink" title="填充 Buffer"></a>填充 Buffer</h3><p>各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 填充一个 byte 值</span><br><span class="line">public abstract ByteBuffer put(byte b);</span><br><span class="line">// 在指定位置填充一个 int 值</span><br><span class="line">public abstract ByteBuffer put(int index, byte b);</span><br><span class="line">// 将一个数组中的值填充进去</span><br><span class="line">public final ByteBuffer put(byte[] src) &#123;...&#125;</span><br><span class="line">public ByteBuffer put(byte[] src, int offset, int length) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会抛 java.nio.BufferOverflowException 异常。</p><p>对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为<strong>读操作</strong>，因为数据是从外部（文件或网络等）读到内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = channel.read(buf);</span><br></pre></td></tr></table></figure><p>上述方法会返回从 Channel 中读入到 Buffer 的数据大小。</p><h3 id="提取-Buffer-中的值"><a href="#提取-Buffer-中的值" class="headerlink" title="提取 Buffer 中的值"></a>提取 Buffer 中的值</h3><p>前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。</p><p>如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。</p><p>调用 Buffer 的 <strong>flip()</strong> 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer flip() &#123;</span><br><span class="line">    limit = position; // 将 limit 设置为实际写入的数据数量</span><br><span class="line">    position = 0; // 重置 position 为 0</span><br><span class="line">    mark = -1; // mark 之后再说</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应写入操作的一系列 put 方法，读操作提供了一系列的 get 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 根据 position 来获取数据</span><br><span class="line">public abstract byte get();</span><br><span class="line">// 获取指定位置的数据</span><br><span class="line">public abstract byte get(int index);</span><br><span class="line">// 将 Buffer 中的数据写入到数组中</span><br><span class="line">public ByteBuffer get(byte[] dst)</span><br></pre></td></tr></table></figure><p>附一个经常使用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(buffer.array()).trim();</span><br></pre></td></tr></table></figure><p>当然了，除了将数据从 Buffer 取出来使用，更常见的操作是将我们写入的数据传输到 Channel 中，如通过 FileChannel 将数据写入到文件中，通过 SocketChannel 将数据写入网络发送到远程机器等。对应的，这种操作，我们称之为<strong>写操作</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = channel.write(buf);</span><br></pre></td></tr></table></figure><h3 id="mark-amp-reset"><a href="#mark-amp-reset" class="headerlink" title="mark() &amp; reset()"></a>mark() &amp; reset()</h3><p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 mark。</p><p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer mark() &#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer reset() &#123;</span><br><span class="line">    int m = mark;</span><br><span class="line">    if (m &lt; 0)</span><br><span class="line">        throw new InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewind-amp-clear-amp-compact"><a href="#rewind-amp-clear-amp-compact" class="headerlink" title="rewind() &amp; clear() &amp; compact()"></a>rewind() &amp; clear() &amp; compact()</h3><p><strong>rewind()</strong>：会重置 position 为 0，通常用于重新从头读写 Buffer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer rewind() &#123;</span><br><span class="line">    position = 0;</span><br><span class="line">    mark = -1;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>clear()</strong>：有点重置 Buffer 的意思，相当于重新实例化了一样。</p><p>通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final Buffer clear() &#123;</span><br><span class="line">    position = 0;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -1;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>compact()</strong>：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p><p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p><p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：</p><p><img src="https://www.javadoop.com/blogimages/nio/8.png" alt="8"></p><ul><li>FileChannel：文件通道，用于文件的读和写</li><li>DatagramChannel：用于 UDP 连接的接收和发送</li><li>SocketChannel：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li><li>ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul><p><strong>这里不是很理解这些也没关系，后面介绍了代码之后就清晰了。还有，我们最应该关注，也是后面将会重点介绍的是 SocketChannel 和 ServerSocketChannel。</strong></p><p>Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p><p><img src="https://www.javadoop.com/blogimages/nio/9.png" alt="9"></p><p><img src="https://www.javadoop.com/blogimages/nio/10.png" alt="10"></p><p>至少读者应该记住一点，这两个方法都是 channel 实例的方法。</p><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>我想文件操作对于大家来说应该是最熟悉的，不过我们在说 NIO 的时候，其实 FileChannel 并不是关注的重点。而且后面我们说非阻塞的时候会看到，FileChannel 是不支持非阻塞的。</p><p><strong>这里算是简单介绍下常用的操作吧，感兴趣的读者瞄一眼就是了。</strong></p><p><strong>初始化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream = new FileInputStream(new File(&quot;/data.txt&quot;));</span><br><span class="line">FileChannel fileChannel = inputStream.getChannel();</span><br></pre></td></tr></table></figure><p>当然了，我们也可以从 RandomAccessFile#getChannel 来得到 FileChannel。</p><p><strong>读取文件内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">int num = fileChannel.read(buffer);</span><br></pre></td></tr></table></figure><p>前面我们也说了，所有的 Channel 都是和 Buffer 打交道的。</p><p><strong>写入文件内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">buffer.put(&quot;随机写入一些内容到 Buffer 中&quot;.getBytes());</span><br><span class="line">// Buffer 切换为读模式</span><br><span class="line">buffer.flip();</span><br><span class="line">while(buffer.hasRemaining()) &#123;</span><br><span class="line">    // 将 Buffer 中的内容写入文件</span><br><span class="line">    fileChannel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>我们前面说了，我们可以将 SocketChannel 理解成一个 TCP 客户端。虽然这么理解有点狭隘，因为我们在介绍 ServerSocketChannel 的时候会看到另一种使用方式。</p><p>打开一个 TCP 连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;https://www.javadoop.com&quot;, 80));</span><br></pre></td></tr></table></figure><p>当然了，上面的这行代码等价于下面的两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打开一个通道</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">// 发起连接</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;https://www.javadoop.com&quot;, 80));</span><br></pre></td></tr></table></figure><p>SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 读取数据</span><br><span class="line">socketChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">// 写入数据到网络连接中</span><br><span class="line">while(buffer.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.write(buffer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要在这里停留太久，先继续往下走。</p><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>之前说 SocketChannel 是 TCP 客户端，这里说的 ServerSocketChannel 就是对应的服务端。</p><p>ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 实例化</span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">// 监听 8080 端口</span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(8080));</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    // 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们可以看到 SocketChannel 的第二个实例化方式</p></blockquote><p>到这里，我们应该能理解 SocketChannel 了，它不仅仅是 TCP 客户端，它代表的是一个网络通道，可读可写。</p><p>ServerSocketChannel 不和 Buffer 打交道了，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为它需要继续监听端口，等待下一个连接。</p><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。</p><blockquote><p>科普一下，UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的</p></blockquote><p><strong>监听端口：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(new InetSocketAddress(9090));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure><p><strong>发送数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot;</span><br><span class="line">                    + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));</span><br></pre></td></tr></table></figure><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>NIO 三大组件就剩 Selector 了，Selector 建立在非阻塞的基础之上，大家经常听到的 <strong>多路复用</strong> 在 Java 世界中指的就是它，用于实现一个线程管理多个 Channel。</p><p>读者在这一节不能消化 Selector 也没关系，因为后续在介绍非阻塞 IO 的时候还得说到这个，这里先介绍一些基本的接口操作。</p><ol><li><p>首先，我们开启一个 Selector。你们爱翻译成<strong>选择器</strong>也好，<strong>多路复用器</strong>也好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></li><li><p>将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，<strong>FileChannel 不支持非阻塞</strong>，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将通道设置为非阻塞模式，因为默认都是阻塞模式的</span><br><span class="line">channel.configureBlocking(false);</span><br><span class="line">// 注册</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>register 方法的第二个 int 型参数（使用二进制的标记位）用于表明需要监听哪些感兴趣的事件，共以下四种事件：</p><ul><li><p>SelectionKey.OP_READ</p><blockquote><p>对应 00000001，通道中有数据可以进行读取</p></blockquote></li><li><p>SelectionKey.OP_WRITE</p><blockquote><p>对应 00000100，可以往通道中写入数据</p></blockquote></li><li><p>SelectionKey.OP_CONNECT</p><blockquote><p>对应 00001000，成功建立 TCP 连接</p></blockquote></li><li><p>SelectionKey.OP_ACCEPT</p><blockquote><p>对应 00010000，接受 TCP 连接</p></blockquote></li></ul><p>我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 000<strong>1</strong>000<strong>1</strong> 即十进制数值 17 即可。</p><p>注册方法返回值是 <strong>SelectionKey</strong> 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</p></li><li><p>调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。</p></li></ol><p>Selector 的操作就是以上 3 步，这里来一个简单的示例，大家看一下就好了。之后在介绍非阻塞 IO 的时候，会演示一份可执行的示例代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">while(true) &#123;</span><br><span class="line">  // 判断是否有事件准备好</span><br><span class="line">  int readyChannels = selector.select();</span><br><span class="line">  if(readyChannels == 0) continue;</span><br><span class="line"></span><br><span class="line">  // 遍历</span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  while(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    if(key.isAcceptable()) &#123;</span><br><span class="line">        // a connection was accepted by a ServerSocketChannel.</span><br><span class="line"></span><br><span class="line">    &#125; else if (key.isConnectable()) &#123;</span><br><span class="line">        // a connection was established with a remote server.</span><br><span class="line"></span><br><span class="line">    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">        // a channel is ready for reading</span><br><span class="line"></span><br><span class="line">    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">        // a channel is ready for writing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Selector，我们还需要非常熟悉以下几个方法：</p><ol><li><p><strong>select()</strong></p><p>调用此方法，会将<strong>上次 select 之后的</strong>准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。</p></li><li><p><strong>selectNow()</strong></p><p>功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。</p></li><li><p><strong>select(long timeout)</strong></p><p>看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会</p></li><li><p><strong>wakeup()</strong></p><p>这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，介绍了 Buffer、Channel 和 Selector 的常见接口。</p><p>Buffer 和数组差不多，它有 position、limit、capacity 几个重要属性。put() 一下数据、flip() 切换到读模式、然后用 get() 获取数据、clear() 一下清空数据、重新回到 put() 写入数据。</p><p>Channel 基本上只和 Buffer 打交道，最重要的接口就是 channel.read(buffer) 和 channel.write(buffer)。</p><p>Selector 用于实现非阻塞 IO，这里仅仅介绍接口使用，后续请关注非阻塞 IO 的介绍。</p><p>（全文完）</p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自互联网&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解1：JAVA 中原生的 socket 通信机制</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A31%EF%BC%9AJAVA%20%E4%B8%AD%E5%8E%9F%E7%94%9F%E7%9A%84%20socket%20%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程和NIO详解1：JAVA 中原生的 socket 通信机制/</id>
    <published>2019-12-13T15:13:43.000Z</published>
    <updated>2021-11-24T08:03:23.995Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转自：<a href="https://github.com/jasonGeng88/blog" target="_blank" rel="noopener">https://github.com/jasonGeng88/blog</a></p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><h2 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a>当前环境</h2><ol><li>jdk == 1.8</li></ol><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E7%9F%A5%E8%AF%86%E7%82%B9" target="_blank" rel="noopener"></a>知识点</h2><ul><li>socket 的连接处理</li><li>IO 输入、输出流的处理</li><li>请求数据格式处理</li><li>请求模型优化</li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener"></a>场景</h2><p>今天，和大家聊一下 JAVA 中的 socket 通信问题。这里采用最简单的一请求一响应模型为例，假设我们现在需要向 baidu 站点进行通信。我们用 JAVA 原生的 socket 该如何实现。</p><h3 id="建立-socket-连接"><a href="#建立-socket-连接" class="headerlink" title="建立 socket 连接"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%BB%BA%E7%AB%8B-socket-%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"></a>建立 socket 连接</h3><p>首先，我们需要建立 socket 连接（_核心代码_）</p><pre>import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;// 初始化 socketSocket socket = new Socket();// 初始化远程连接地址SocketAddress remote = new InetSocketAddress(host, port);// 建立连接socket.connect(remote);</pre><h3 id="处理-socket-输入输出流"><a href="#处理-socket-输入输出流" class="headerlink" title="处理 socket 输入输出流"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%A4%84%E7%90%86-socket-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81" target="_blank" rel="noopener"></a>处理 socket 输入输出流</h3><p>成功建立 socket 连接后，我们就能获得它的输入输出流，通信的本质是对输入输出流的处理。通过输入流，读取网络连接上传来的数据，通过输出流，将本地的数据传出给远端。</p><p><em>socket 连接实际与处理文件流有点类似，都是在进行 IO 操作。</em></p><p>获取输入、输出流代码如下：</p><pre>// 输入流InputStream in = socket.getInputStream();// 输出流OutputStream out = socket.getOutputStream();</pre><p>关于 IO 流的处理，我们一般会用相应的包装类来处理 IO 流，如果直接处理的话，我们需要对 <code>byte[]</code> 进行操作，而这是相对比较繁琐的。如果采用包装类，我们可以直接以<code>string</code>、<code>int</code>等类型进行处理，简化了 IO 字节操作。</p><p>下面以 <code>BufferedReader</code> 与 <code>PrintWriter</code> 作为输入输出的包装类进行处理。</p><pre>// 获取 socket 输入流private BufferedReader getReader(Socket socket) throws IOException {    InputStream in = socket.getInputStream();    return new BufferedReader(new InputStreamReader(in));}// 获取 socket 输出流private PrintWriter getWriter(Socket socket) throws IOException {    OutputStream out = socket.getOutputStream();    return new PrintWriter(new OutputStreamWriter(out));}</pre><h3 id="数据请求与响应"><a href="#数据请求与响应" class="headerlink" title="数据请求与响应"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94" target="_blank" rel="noopener"></a>数据请求与响应</h3><p>有了 socket 连接、IO 输入输出流，下面就该向发送请求数据，以及获取请求的响应结果。</p><p>因为有了 IO 包装类的支持，我们可以直接以字符串的格式进行传输，由包装类帮我们将数据装换成相应的字节流。</p><p>因为我们与 baidu 站点进行的是 HTTP 访问，所有我们不需要额外定义输出格式。采用标准的 HTTP 传输格式，就能进行请求响应了（_某些特定的 RPC 框架，可能会有自定义的通信格式_）。</p><p>请求的数据内容处理如下：</p><pre>public class HttpUtil {    public static String compositeRequest(String host){        return "GET / HTTP/1.1\r\n" +                "Host: " + host + "\r\n" +                "User-Agent: curl/7.43.0\r\n" +                "Accept: */*\r\n\r\n";    }}</pre><p>发送请求数据代码如下：</p><pre>// 发起请求PrintWriter writer = getWriter(socket);writer.write(HttpUtil.compositeRequest(host));writer.flush();</pre><p>接收响应数据代码如下：</p><pre>// 读取响应String msg;BufferedReader reader = getReader(socket);while ((msg = reader.readLine()) != null){    System.out.println(msg);}</pre><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA" target="_blank" rel="noopener"></a>结果展示</h3><p>至此，讲完了原生 socket 下的创建连接、发送请求与接收响应的所有核心代码。</p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import com.test.network.util.HttpUtil; public class SocketHttpClient &#123;     public void start(String host, int port) &#123;         // 初始化 socket        Socket socket = new Socket();         try &#123;            // 设置 socket 连接            SocketAddress remote = new InetSocketAddress(host, port);            socket.setSoTimeout(5000);            socket.connect(remote);             // 发起请求            PrintWriter writer = getWriter(socket);            System.out.println(HttpUtil.compositeRequest(host));            writer.write(HttpUtil.compositeRequest(host));            writer.flush();             // 读取响应            String msg;            BufferedReader reader = getReader(socket);            while ((msg = reader.readLine()) != null)&#123;                System.out.println(msg);            &#125;         &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                socket.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;     &#125; private BufferedReader getReader(Socket socket) throws IOException &#123;        InputStream in = socket.getInputStream();        return new BufferedReader(new InputStreamReader(in));    &#125;     private PrintWriter getWriter(Socket socket) throws IOException &#123;        OutputStream out = socket.getOutputStream();        return new PrintWriter(new OutputStreamWriter(out));    &#125; &#125;</span><br></pre></td></tr></table></figure><p>下面，我们通过实例化一个客户端，来展示 socket 通信的结果。</p><pre>public class Application {    public static void main(String[] args) {        new SocketHttpClient().start("www.baidu.com", 80);    }}</pre><p>结果输出：</p><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-socket-01.png" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-socket-01.png" alt></a></p><h2 id="请求模型优化"><a href="#请求模型优化" class="headerlink" title="请求模型优化"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96" target="_blank" rel="noopener"></a>请求模型优化</h2><p>这种方式，虽然实现功能没什么问题。但是我们细看，发现在 IO 写入与读取过程，是发生了 IO 阻塞的情况。即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 会发生 IO 阻塞writer.write(HttpUtil.compositeRequest(host));reader.readLine();</span><br></pre></td></tr></table></figure><p>所以如果要同时请求10个不同的站点，如下：</p><pre>public class SingleThreadApplication {    public static void main(String[] args) {        // HttpConstant.HOSTS 为 站点集合        for (String host: HttpConstant.HOSTS) {            new SocketHttpClient().start(host, HttpConstant.PORT);        }    }}</pre><p>它一定是第一个请求响应结束后，才会发起下一个站点处理。</p><p><em>这在服务端更明显，虽然这里的代码是客户端连接，但是具体的操作和服务端是差不多的。请求只能一个个串行处理，这在响应时间上肯定不能达标。</em></p><ul><li>多线程处理</li></ul><p>有人觉得这根本不是问题，JAVA 是多线程的编程语言。对于这种情况，采用多线程的模型再合适不过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThreadApplication &#123;     public static void main(String[] args) &#123;         for (final String host: HttpConstant.HOSTS) &#123;             Thread t = new Thread(new Runnable() &#123;                public void run() &#123;                    new SocketHttpClient().start(host, HttpConstant.PORT);                &#125;            &#125;);             t.start();         &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>这种方式起初看起来挺有用的，但并发量一大，应用会起很多的线程。都知道，在服务器上，每一个线程实际都会占据一个文件句柄。而服务器上的句柄数是有限的，而且大量的线程，造成的线程间切换的消耗也会相当的大。所以这种方式在并发量大的场景下，一定是承载不住的。</p><ul><li>多线程 + 线程池 处理</li></ul><p>既然线程太多不行，那我们控制一下线程创建的数目不就行了。只启动固定的线程数来进行 socket 处理，既利用了多线程的处理，又控制了系统的资源消耗。</p><pre>public class ThreadPoolApplication {    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(8);        for (final String host: HttpConstant.HOSTS) {            Thread t = new Thread(new Runnable() {                public void run() {                    new SocketHttpClient().start(host, HttpConstant.PORT);                }            });            executorService.submit(t);            new SocketHttpClient().start(host, HttpConstant.PORT);        }    }}</pre><p><em>关于启动的线程数，一般 CPU 密集型会设置在 N+1（N为CPU核数），IO 密集型设置在 2N + 1。</em></p><p>这种方式，看起来是最优的了。那有没有更好的呢，如果一个线程能同时处理多个 socket 连接，并且在每个 socket 输入输出数据没有准备好的情况下，不进行阻塞，那是不是更优呢。这种技术叫做“IO多路复用”。在 JAVA 的 nio 包中，提供了相应的实现。</p><h2 id="补充1：TCP客户端与服务端"><a href="#补充1：TCP客户端与服务端" class="headerlink" title="补充1：TCP客户端与服务端"></a>补充1：TCP客户端与服务端</h2><pre>public class TCP客户端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                try {                    Socket s = new Socket("127.0.0.1",1234);    //构建IO  InputStream is = s.getInputStream();  OutputStream os = s.getOutputStream();    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));  //向服务器端发送一条消息  bw.write("测试客户端和服务器通信，服务器接收到消息返回到客户端\n");  bw.flush();    //读取服务器返回的消息  BufferedReader br = new BufferedReader(new InputStreamReader(is));  String mess = br.readLine();  System._out_.println("服务器："+mess);  } catch (UnknownHostException e) {                    e.printStackTrace();  } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><pre>public class TCP服务端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                try {                    ServerSocket ss = new ServerSocket(1234); while (true) {                        System._out_.println("启动服务器....");  Socket s = ss.accept();  System._out_.println("客户端:" + s.getInetAddress().getLocalHost() + "已连接到服务器");  BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));  //读取客户端发送来的消息  String mess = br.readLine();  System._out_.println("客户端：" + mess);  BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));  bw.write(mess + "\n");  bw.flush();  }                } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><h2 id="补充2：UDP客户端和服务端"><a href="#补充2：UDP客户端和服务端" class="headerlink" title="补充2：UDP客户端和服务端"></a>补充2：UDP客户端和服务端</h2><pre>public class UDP客户端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                byte []arr = "Hello Server".getBytes(); try {                    InetAddress inetAddress = InetAddress.getLocalHost();  DatagramSocket datagramSocket = new DatagramSocket();  DatagramPacket datagramPacket = new DatagramPacket(arr, arr.length, inetAddress, 1234);  datagramSocket.send(datagramPacket);  System._out_.println("send end");  } catch (UnknownHostException e) {                    e.printStackTrace();  } catch (SocketException e) {                    e.printStackTrace();  } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><pre>public class UDP服务端 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override  public void run() {                try {                    DatagramSocket datagramSocket = new DatagramSocket(1234); byte[] buffer = new byte[1024];  DatagramPacket packet = new DatagramPacket(buffer, buffer.length);  datagramSocket.receive(packet);  System._out_.println("server recv");  String msg = new String(packet.getData(), "utf-8");  System._out_.println(msg);  } catch (SocketException e) {                    e.printStackTrace();  } catch (IOException e) {                    e.printStackTrace();  }            }        }).start();  }}</pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md#%E5%90%8E%E7%BB%AD" target="_blank" rel="noopener"></a>后续</h2><ul><li>JAVA 中是如何实现 IO多路复用</li><li>Netty 下的实现异步请求的</li></ul><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自：&lt;a href=&quot;https://github.com/jasonGeng88/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jasonGeng88/blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程和NIO详解3：IO模型与Java网络编程模型</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A33%EF%BC%9AIO%E6%A8%A1%E5%9E%8B%E4%B8%8EJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程和NIO详解3：IO模型与Java网络编程模型/</id>
    <published>2019-12-13T15:13:43.000Z</published>
    <updated>2021-11-24T08:03:23.996Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><p>基本概念说明</p><p><strong>用户空间与内核空间</strong></p><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><p><strong>进程切换</strong></p><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ul><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ul><p><strong>进程的阻塞</strong></p><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><p><strong>文件描述符</strong></p><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><p><strong>缓存 IO</strong></p><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>缓存 IO 的缺点：</p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="IO模型介绍"><a href="#IO模型介绍" class="headerlink" title="IO模型介绍"></a>IO模型介绍</h2><p>作者：cooffeelis<br>链接：<a href="https://www.jianshu.com/p/511b9cffbdac" target="_blank" rel="noopener">https://www.jianshu.com/p/511b9cffbdac</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>常用的5种IO模型:<br>blocking IO<br>nonblocking IO<br>IO multiplexing<br>signal driven IO<br>asynchronous IO</p><p>再说一下IO发生时涉及的对象和步骤:</p><p><strong><em>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象：</em></strong></p><ul><li>一个是调用这个IO的process (or thread)</li><li>一个就是系统内核(kernel)</li></ul><p><strong><em>当一个read操作发生时，它会经历两个阶段：</em></strong></p><ul><li>等待数据准备,比如accept(), recv()等待数据 <code>(Waiting for the data to be ready)</code></li><li>将数据从内核拷贝到进程中, 比如 accept()接受到请求,recv()接收连接发送的数据后需要复制到内核,再从内核复制到进程用户空间<code>(Copying the data from the kernel to the process)</code></li></ul><p><strong><em>对于socket流而言,数据的流向经历两个阶段：</em></strong></p><ul><li>第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</p><h3 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h3><hr><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-9522cafa9e14abd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/552" alt></p><p>阻塞IO流程</p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到<strong>操作系统内核的缓冲区</strong>中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会<strong>将数据从kernel中拷贝到用户内存</strong>，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h3 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h3><hr><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-0c604ff4a2d8dc5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603" alt></p><p>非阻塞 I/O 流程</p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，<strong>那么它并不会block用户进程，而是立刻返回一个error</strong>。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p></blockquote><p><strong>*值得注意的是,此时的非阻塞IO只是应用到等待数据上,当真正有数据到达执行recvfrom的时候,还是同步阻塞IO来的, 从图中的copy data from kernel to user可以看出 *</strong></p><h3 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h3><hr><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-3b0399b077daf0a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/609" alt></p><p>I/O 多路复用流程</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><blockquote><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p></blockquote><p>IO复用的实现方式目前主要有select、poll和epoll。</p><p>select和poll的原理基本相同：</p><ul><li>注册待侦听的fd(这里的fd创建时最好使用非阻塞)</li><li>每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回</li><li>返回结果中包括已就绪和未就绪的fd</li></ul><p>相比select，poll解决了单个进程能够打开的文件描述符数量有限制这个问题：select受限于FD_SIZE的限制，如果修改则需要修改这个宏重新编译内核；而poll通过一个pollfd数组向内核传递需要关注的事件，避开了文件描述符数量限制。</p><p>此外，select和poll共同具有的一个很大的缺点就是包含大量fd的数组被整体复制于用户态和内核态地址空间之间，开销会随着fd数量增多而线性增大。</p><p>select和poll就类似于上面说的就餐方式。但当你每次都去询问时，老板会把所有你点的饭菜都轮询一遍再告诉你情况，当大量饭菜很长时间都不能准备好的情况下是很低效的。于是，老板有些不耐烦了，就让厨师每做好一个菜就通知他。这样每次你再去问的时候，他会直接把已经准备好的菜告诉你，你再去端。这就是事件驱动IO就绪通知的方式-<strong>epoll</strong>。</p><p>epoll的出现，解决了select、poll的缺点：</p><ul><li>基于事件驱动的方式，避免了每次都要把所有fd都扫描一遍。</li><li>epoll_wait只返回就绪的fd。</li><li>epoll使用nmap内存映射技术避免了内存复制的开销。</li><li>epoll的fd数量上限是操作系统的最大文件句柄数目,这个数目一般和内存有关，通常远大于1024。</li></ul><p>目前，epoll是Linux2.6下最高效的IO复用方式，也是Nginx、Node的IO实现方式。而在freeBSD下，kqueue是另一种类似于epoll的IO复用方式。</p><p>此外，对于IO复用还有一个水平触发和边缘触发的概念：</p><ul><li>水平触发：当就绪的fd未被用户进程处理后，下一次查询依旧会返回，这是select和poll的触发方式。</li><li>边缘触发：无论就绪的fd是否被处理，下一次不再返回。理论上性能更高，但是实现相当复杂，并且任何意外的丢失事件都会造成请求处理错误。epoll默认使用水平触发，通过相应选项可以使用边缘触发。</li></ul><blockquote><p>点评：<br><strong><em>I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，</em></strong>而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。<br><strong><em>所以, IO多路复用，本质上不会有并发的功能，因为任何时候还是只有一个进程或线程进行工作，它之所以能提高效率是因为select\epoll 把进来的socket放到他们的 ‘监视’ 列表里面，当任何socket有可读可写数据立马处理，那如果select\epoll 手里同时检测着很多socket， 一有动静马上返回给进程处理，总比一个一个socket过来,阻塞等待,处理高效率。</em></strong><br>当然也可以多线程/多进程方式，一个连接过来开一个进程/线程处理，这样消耗的内存和进程切换页会耗掉更多的系统资源。<br>所以我们可以结合IO多路复用和多进程/多线程 来高性能并发，IO复用负责提高接受socket的通知效率，收到请求后，交给进程池/线程池来处理逻辑。</p><h3 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h3><p>上文的就餐方式还是需要你每次都去问一下饭菜状况。于是，你再次不耐烦了，就跟老板说，哪个饭菜好了就通知我一声吧。然后就自己坐在桌子那里干自己的事情。更甚者，你可以把手机号留给老板，自己出门，等饭菜好了直接发条短信给你。这就类似信号驱动的IO模型。</p><p><img src="http://www.rowkey.me/images/blog_images/io/sigio.png" alt="bio"></p><p>流程如下：</p><ul><li>开启套接字信号驱动IO功能</li><li>系统调用sigaction执行信号处理函数（非阻塞，立刻返回）</li><li>数据就绪，生成sigio信号，通过信号回调通知应用来读取数据。</li></ul><p>此种io方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据。</p><h3 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h3></blockquote><h3 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h3><hr><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-e707464b299104e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572" alt></p><p>异步IO 流程</p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h2 id="阻塞IO-非阻塞IO-与-同步IO-异步IO的区别和联系"><a href="#阻塞IO-非阻塞IO-与-同步IO-异步IO的区别和联系" class="headerlink" title="阻塞IO,非阻塞IO 与 同步IO, 异步IO的区别和联系"></a>阻塞IO,非阻塞IO 与 同步IO, 异步IO的区别和联系</h2><p>阻塞IO VS 非阻塞IO：</p><p>概念：<br>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong><br>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>例子：你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p><hr><p>分析：<br>阻塞IO会一直block住对应的进程直到操作完成，而非阻塞IO在kernel还准备数据的情况下会立刻返回。</p><p>同步IO VS 异步IO：</p><p>概念：<br>同步与异步同步和异步关注的是<strong>_消息通信机制 _</strong>(synchronous communication/ asynchronous communication)所谓同步，就是在发出一个_调用_时，在没有得到结果之前，该_调用_就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由_调用者_主动等待这个_调用_的结果。而异步则是相反，_调用_在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在_调用_发出后，_被调用者_通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p><hr><p>分析：<br>在说明同步IO和异步IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：</p><blockquote><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>An asynchronous I/O operation does not cause the requesting process to be blocked;</p></blockquote><p>两者的区别就在于同步IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的<strong><em>阻塞IO,非阻塞IO ，IO复用都属于同步IO。</em></strong><br>有人可能会说，非阻塞IO 并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。非阻塞IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而异步IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><h3 id="IO模型的形象举例"><a href="#IO模型的形象举例" class="headerlink" title="IO模型的形象举例"></a>IO模型的形象举例</h3><p>最后，再举几个不是很恰当的例子来说明这四个IO Model:<br>有A，B，C，D四个人在钓鱼：<br>A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；<br>B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；<br>C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；<br>D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。</p><h3 id="Select-Poll-Epoll-轮询机制"><a href="#Select-Poll-Epoll-轮询机制" class="headerlink" title="Select/Poll/Epoll 轮询机制"></a>Select/Poll/Epoll 轮询机制</h3><p><strong><em>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</em></strong><br>Select/Poll/Epoll 都是IO复用的实现方式， 上面说了使用IO复用，会把socket设置成non-blocking，然后放进Select/Poll/Epoll 各自的监视列表里面，那么，他们的对socket是否有数据到达的监视机制分别是怎样的？效率又如何？我们应该使用哪种方式实现IO复用比较好？下面列出他们各自的实现方式，效率，优缺点：</p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><h2 id="Java网络编程模型"><a href="#Java网络编程模型" class="headerlink" title="Java网络编程模型"></a>Java网络编程模型</h2><p>上文讲述了UNIX环境的五种IO模型。基于这五种模型，在Java中，随着NIO和NIO2.0(AIO)的引入，一般具有以下几种网络编程模型：</p><ul><li>BIO</li><li>NIO</li><li>AIO</li></ul><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的过程，步骤如下：</p><ul><li>主线程accept请求阻塞</li><li>请求到达，创建新的线程来处理这个套接字，完成对客户端的响应。</li><li>主线程继续accept下一个请求</li></ul><p>这种模型有一个很大的问题是：当客户端连接增多时，服务端创建的线程也会暴涨，系统性能会急剧下降。因此，在此模型的基础上，类似于 tomcat的bio connector，采用的是线程池来避免对于每一个客户端都创建一个线程。有些地方把这种方式叫做伪异步IO(把请求抛到线程池中异步等待处理)。</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>JDK1.4开始引入了NIO类库，这里的NIO指的是New IO，主要是使用Selector多路复用器来实现。Selector在Linux等主流操作系统上是通过epoll实现的。</p><p>NIO的实现流程，类似于select：</p><ul><li>创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式。</li><li>创建Reactor线程，创建多路复用器(Selector)并启动线程。</li><li>将ServerSocketChannel注册到Reactor线程的Selector上。监听accept事件。</li><li>Selector在线程run方法中无线循环轮询准备就绪的Key。</li><li>Selector监听到新的客户端接入，处理新的请求，完成tcp三次握手，建立物理连接。</li><li>将新的客户端连接注册到Selector上，监听读操作。读取客户端发送的网络消息。</li><li>客户端发送的数据就绪则读取客户端请求，进行处理。</li></ul><p>相比BIO，NIO的编程非常复杂。</p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>JDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。其底层在windows上是通过IOCP，在Linux上是通过epoll来实现的(LinuxAsynchronousChannelProvider.java,UnixAsynchronousServerSocketChannelImpl.java)。</p><ul><li>创建AsynchronousServerSocketChannel，绑定监听端口</li><li>调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler。包括上一步，都是非阻塞的</li><li>连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler。</li><li>数据就绪，触发负责处理数据的CompletionHandler的completed方法。继续做下一步处理即可。</li><li>写入操作类似，也需要传入CompletionHandler。</li></ul><p>其编程模型相比NIO有了不少的简化。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>.</th><th>同步阻塞IO</th><th>伪异步IO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>客户端数目 ：IO线程</td><td>1 : 1</td><td>m : n</td><td>m : 1</td><td>m : 0</td></tr><tr><td>IO模型</td><td>同步阻塞IO</td><td>同步阻塞IO</td><td>同步非阻塞IO</td><td>异步非阻塞IO</td></tr><tr><td>吞吐量</td><td>低</td><td>中</td><td>高</td><td>高</td></tr><tr><td>编程复杂度</td><td>简单</td><td>简单</td><td>非常复杂</td><td>复杂</td></tr></tbody></table><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程与NIO详解2：JAVA NIO 一步步构建IO多路复用的请求模型</title>
    <link href="http://yoursite.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E8%AF%A6%E8%A7%A32%EF%BC%9AJAVA%20NIO%20%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%9E%84%E5%BB%BAIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/12/13/网络编程/Java网络编程与NIO详解2：JAVA NIO 一步步构建IO多路复用的请求模型/</id>
    <published>2019-12-13T15:12:43.000Z</published>
    <updated>2021-11-24T08:03:23.993Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文转载自：<a href="https://github.com/jasonGeng88/blog" target="_blank" rel="noopener">https://github.com/jasonGeng88/blog</a></p><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章将同步到我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><ul><li>文章一：<a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-socket.md" target="_blank" rel="noopener">JAVA 中原生的 socket 通信机制</a></li></ul><h2 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener"></a>当前环境</h2><ol><li>jdk == 1.8</li></ol><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener"></a>代码地址</h2><p>git 地址：<a href="https://github.com/jasonGeng88/java-network-programming" target="_blank" rel="noopener">https://github.com/jasonGeng88/java-network-programming</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E7%9F%A5%E8%AF%86%E7%82%B9" target="_blank" rel="noopener"></a>知识点</h2><ul><li>nio 下 I/O 阻塞与非阻塞实现</li><li>SocketChannel 介绍</li><li>I/O 多路复用的原理</li><li>事件选择器与 SocketChannel 的关系</li><li>事件监听类型</li><li>字节缓冲 ByteBuffer 数据结构</li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener"></a>场景</h2><p>接着上一篇中的站点访问问题，如果我们需要并发访问10个不同的网站，我们该如何处理？</p><p>在上一篇中，我们使用了<code>java.net.socket</code>类来实现了这样的需求，以一线程处理一连接的方式，并配以线程池的控制，貌似得到了当前的最优解。可是这里也存在一个问题，连接处理是同步的，也就是并发数量增大后，大量请求会在队列中等待，或直接异常抛出。</p><p>为解决这问题，我们发现元凶处在“一线程一请求”上，如果一个线程能同时处理多个请求，那么在高并发下性能上会大大改善。这里就借住 JAVA 中的 nio 技术来实现这一模型。</p><h2 id="nio-的阻塞实现"><a href="#nio-的阻塞实现" class="headerlink" title="nio 的阻塞实现"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#nio-%E7%9A%84%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener"></a>nio 的阻塞实现</h2><p>关于什么是 nio，从字面上理解为 New IO，就是为了弥补原本 I/O 上的不足，而在 JDK 1.4 中引入的一种新的 I/O 实现方式。简单理解，就是它提供了 I/O 的阻塞与非阻塞的两种实现方式（_当然，默认实现方式是阻塞的。_）。</p><p>下面，我们先来看下 nio 以阻塞方式是如何处理的。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"></a>建立连接</h3><p>有了上一篇 socket 的经验，我们的第一步一定也是建立 socket 连接。只不过，这里不是采用 <code>new socket()</code> 的方式，而是引入了一个新的概念 <code>SocketChannel</code>。它可以看作是 socket 的一个完善类，除了提供 Socket 的相关功能外，还提供了许多其他特性，如后面要讲到的向选择器注册的功能。</p><p>类图如下： <a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-01.jpg" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-01.jpg" alt></a></p><p>建立连接代码实现：</p><pre>// 初始化 socket，建立 socket 与 channel 的绑定关系SocketChannel socketChannel = SocketChannel.open();// 初始化远程连接地址SocketAddress remote = new InetSocketAddress(this.host, port);// I/O 处理设置阻塞，这也是默认的方式，可不设置socketChannel.configureBlocking(true);// 建立连接socketChannel.connect(remote);</pre><h3 id="获取-socket-连接"><a href="#获取-socket-连接" class="headerlink" title="获取 socket 连接"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E8%8E%B7%E5%8F%96-socket-%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener"></a>获取 socket 连接</h3><p>因为是同样是 I/O 阻塞的实现，所以后面的关于 socket 输入输出流的处理，和上一篇的基本相同。唯一差别是，这里需要通过 channel 来获取 socket 连接。</p><ul><li>获取 socket 连接</li></ul><pre>Socket socket = socketChannel.socket();</pre><ul><li>处理输入输出流</li></ul><pre>PrintWriter pw = getWriter(socketChannel.socket());BufferedReader br = getReader(socketChannel.socket());</pre><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B" target="_blank" rel="noopener"></a>完整示例</h3><pre>package com.jason.network.mode.nio;import com.jason.network.constant.HttpConstant;import com.jason.network.util.HttpUtil;import java.io.*;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import java.nio.channels.SocketChannel;public class NioBlockingHttpClient {    private SocketChannel socketChannel;    private String host;    public static void main(String[] args) throws IOException {        for (String host: HttpConstant.HOSTS) {            NioBlockingHttpClient client = new NioBlockingHttpClient(host, HttpConstant.PORT);            client.request();        }    }    public NioBlockingHttpClient(String host, int port) throws IOException {        this.host = host;        socketChannel = SocketChannel.open();        socketChannel.socket().setSoTimeout(5000);        SocketAddress remote = new InetSocketAddress(this.host, port);        this.socketChannel.connect(remote);    }    public void request() throws IOException {        PrintWriter pw = getWriter(socketChannel.socket());        BufferedReader br = getReader(socketChannel.socket());        pw.write(HttpUtil.compositeRequest(host));        pw.flush();        String msg;        while ((msg = br.readLine()) != null){            System.out.println(msg);        }    }    private PrintWriter getWriter(Socket socket) throws IOException {        OutputStream out = socket.getOutputStream();        return new PrintWriter(out);    }    private BufferedReader getReader(Socket socket) throws IOException {        InputStream in = socket.getInputStream();        return new BufferedReader(new InputStreamReader(in));    }}</pre><h2 id="nio-的非阻塞实现"><a href="#nio-的非阻塞实现" class="headerlink" title="nio 的非阻塞实现"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#nio-%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener"></a>nio 的非阻塞实现</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" target="_blank" rel="noopener"></a>原理分析</h3><p>nio 的阻塞实现，基本与使用原生的 socket 类似，没有什么特别大的差别。</p><p>下面我们来看看它真正强大的地方。到目前为止，我们将的都是阻塞 I/O。何为阻塞 I/O，看下图：</p><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-02.jpg" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-02.jpg" alt></a></p><p><em>我们主要观察图中的前三种 I/O 模型，关于异步 I/O，一般需要依靠操作系统的支持，这里不讨论。</em></p><p>从图中可以发现，阻塞过程主要发生在两个阶段上：</p><ul><li>第一阶段：等待数据就绪；</li><li>第二阶段：将已就绪的数据从内核缓冲区拷贝到用户空间；</li></ul><p>这里产生了一个从内核到用户空间的拷贝，主要是为了系统的性能优化考虑。假设，从网卡读到的数据直接返回给用户空间，那势必会造成频繁的系统中断，因为从网卡读到的数据不一定是完整的，可能断断续续的过来。通过内核缓冲区作为缓冲，等待缓冲区有足够的数据，或者读取完结后，进行一次的系统中断，将数据返回给用户，这样就能避免频繁的中断产生。</p><p>了解了 I/O 阻塞的两个阶段，下面我们进入正题。看看一个线程是如何实现同时处理多个 I/O 调用的。从上图中的非阻塞 I/O 可以看出，仅仅只有第二阶段需要阻塞，第一阶段的数据等待过程，我们是不需要关心的。不过该模型是频繁地去检查是否就绪，造成了 CPU 无效的处理，反而效果不好。如果有一种类似的好莱坞原则— “不要给我们打电话，我们会打给你” 。这样一个线程可以同时发起多个 I/O 调用，并且不需要同步等待数据就绪。在数据就绪完成的时候，会以事件的机制，来通知我们。这样不就实现了单线程同时处理多个 IO 调用的问题了吗？即所说的“I/O 多路复用模型”。</p><hr><p>废话讲了一大堆，下面就来实际操刀一下。</p><h3 id="创建选择器"><a href="#创建选择器" class="headerlink" title="创建选择器"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%88%9B%E5%BB%BA%E9%80%89%E6%8B%A9%E5%99%A8" target="_blank" rel="noopener"></a>创建选择器</h3><p>由上面分析可以，我们得有一个选择器，它能监听所有的 I/O 操作，并且以事件的方式通知我们哪些 I/O 已经就绪了。</p><p>代码如下：</p><pre>import java.nio.channels.Selector;...private static Selector selector;static {    try {        selector = Selector.open();    } catch (IOException e) {        e.printStackTrace();    }}</pre><h3 id="创建非阻塞-I-O"><a href="#创建非阻塞-I-O" class="headerlink" title="创建非阻塞 I/O"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%88%9B%E5%BB%BA%E9%9D%9E%E9%98%BB%E5%A1%9E-io" target="_blank" rel="noopener"></a>创建非阻塞 I/O</h3><p>下面，我们来创建一个非阻塞的 <code>SocketChannel</code>，代码与阻塞实现类型，唯一不同是<code>socketChannel.configureBlocking(false)</code>。</p><p><em><strong>注意：只有在<code>socketChannel.configureBlocking(false)</code>之后的代码，才是非阻塞的，如果<code>socketChannel.connect()</code>在设置非阻塞模式之前，那么连接操作依旧是阻塞调用的。</strong></em></p><pre>SocketChannel socketChannel = SocketChannel.open();SocketAddress remote = new InetSocketAddress(host, port);// 设置非阻塞模式socketChannel.configureBlocking(false);socketChannel.connect(remote);</pre><h3 id="建立选择器与-socket-的关联"><a href="#建立选择器与-socket-的关联" class="headerlink" title="建立选择器与 socket 的关联"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%BB%BA%E7%AB%8B%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8E-socket-%E7%9A%84%E5%85%B3%E8%81%94" target="_blank" rel="noopener"></a>建立选择器与 socket 的关联</h3><p>选择器与 socket 都创建好了，下一步就是将两者进行关联，好让选择器和监听到 Socket 的变化。这里采用了以 <code>SocketChannel</code> 主动注册到选择器的方式进行关联绑定，这也就解释了，为什么不直接<code>new Socket()</code>，而是以<code>SocketChannel</code>的方式来创建 socket。</p><p>代码如下：</p><pre>socketChannel.register(selector,                        SelectionKey.OP_CONNECT                        | SelectionKey.OP_READ                        | SelectionKey.OP_WRITE);</pre><p>上面代码，我们将 socketChannel 注册到了选择器中，并且对它的连接、可读、可写事件进行了监听。</p><p>具体的事件监听类型如下：</p><table><thead><tr><th>操作类型</th><th>值</th><th>描述</th><th>所属对象</th></tr></thead><tbody><tr><td>OP_READ</td><td>1 &lt;&lt; 0</td><td>读操作</td><td>SocketChannel</td></tr><tr><td>OP_WRITE</td><td>1 &lt;&lt; 2</td><td>写操作</td><td>SocketChannel</td></tr><tr><td>OP_CONNECT</td><td>1 &lt;&lt; 3</td><td>连接socket操作</td><td>SocketChannel</td></tr><tr><td>OP_ACCEPT</td><td>1 &lt;&lt; 4</td><td>接受socket操作</td><td>ServerSocketChannel</td></tr></tbody></table><h3 id="选择器监听-socket-变化"><a href="#选择器监听-socket-变化" class="headerlink" title="选择器监听 socket 变化"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E9%80%89%E6%8B%A9%E5%99%A8%E7%9B%91%E5%90%AC-socket-%E5%8F%98%E5%8C%96" target="_blank" rel="noopener"></a>选择器监听 socket 变化</h3><p>现在，选择器已经与我们关心的 socket 进行了关联。下面就是感知事件的变化，然后调用相应的处理机制。</p><p>这里与 Linux 下的 selector 有点不同，nio 下的 selecotr 不会去遍历所有关联的 socket。我们在注册时设置了我们关心的事件类型，每次从选择器中获取的，只会是那些符合事件类型，并且完成就绪操作的 socket，减少了大量无效的遍历操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void select() throws IOException &#123;</span><br><span class="line">// 获取就绪的 socket 个数</span><br><span class="line">    while (selector.select() &gt; 0)&#123;</span><br><span class="line"></span><br><span class="line">    // 获取符合的 socket 在选择器中对应的事件句柄 key</span><br><span class="line">        Set keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">// 遍历所有的key</span><br><span class="line">        Iterator it = keys.iterator();</span><br><span class="line">        while (it.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">// 获取对应的 key，并从已选择的集合中移除</span><br><span class="line">            SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">            it.remove();</span><br><span class="line"></span><br><span class="line">            if (key.isConnectable())&#123;</span><br><span class="line">            // 进行连接操作</span><br><span class="line">                connect(key);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key.isWritable())&#123;</span><br><span class="line">            // 进行写操作</span><br><span class="line">                write(key);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key.isReadable())&#123;</span><br><span class="line">            // 进行读操作</span><br><span class="line">                receive(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注意：这里的<code>selector.select()</code>是同步阻塞的，等待有事件发生后，才会被唤醒。这就防止了 CPU 空转的产生。当然，我们也可以给它设置超时时间，<code>selector.select(long timeout)</code>来结束阻塞过程。</strong></em></p><h3 id="处理连接就绪事件"><a href="#处理连接就绪事件" class="headerlink" title="处理连接就绪事件"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener"></a>处理连接就绪事件</h3><p>下面，我们分别来看下，一个 socket 是如何来处理连接、写入数据和读取数据的（_这些操作都是阻塞的过程，只是我们将等待就绪的过程变成了非阻塞的了_）。</p><p>处理连接代码：</p><pre>// SelectionKey 代表 SocketChannel 在选择器中注册的事件句柄private void connect(SelectionKey key) throws IOException {    // 获取事件句柄对应的 SocketChannel    SocketChannel channel = (SocketChannel) key.channel();   // 真正的完成 socket 连接    channel.finishConnect();   // 打印连接信息    InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();    String host = remote.getHostName();    int port = remote.getPort();    System.out.println(String.format("访问地址: %s:%s 连接成功!", host, port));}</pre><h3 id="处理写入就绪事件"><a href="#处理写入就绪事件" class="headerlink" title="处理写入就绪事件"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%A4%84%E7%90%86%E5%86%99%E5%85%A5%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener"></a>处理写入就绪事件</h3><pre>// 字符集处理类private Charset charset = Charset.forName("utf8");private void write(SelectionKey key) throws IOException {    SocketChannel channel = (SocketChannel) key.channel();    InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();    String host = remote.getHostName();    // 获取 HTTP 请求，同上一篇    String request = HttpUtil.compositeRequest(host);    // 向 SocketChannel 写入事件     channel.write(charset.encode(request));    // 修改 SocketChannel 所关心的事件    key.interestOps(SelectionKey.OP_READ);}</pre><p>这里有两个地方需要注意：</p><ul><li>第一个是使用 <code>channel.write(charset.encode(request));</code> 进行数据写入。有人会说，为什么不能像上面同步阻塞那样，通过<code>PrintWriter</code>包装类进行操作。因为<code>PrintWriter</code>的 <code>write()</code> 方法是阻塞的，也就是说要等数据真正从 socket 发送出去后才返回。</li></ul><p>这与我们这里所讲的阻塞是不一致的，这里的操作虽然也是阻塞的，但它发生的过程是在数据从用户空间到内核缓冲区拷贝过程。至于系统将缓冲区的数据通过 socket 发送出去，这不在阻塞范围内。也解释了为什么要用 <code>Charset</code> 对写入内容进行编码了，因为缓冲区接收的格式是<code>ByteBuffer</code>。</p><ul><li><p>第二，选择器用来监听事件变化的两个参数是 <code>interestOps</code> 与 <code>readyOps</code>。</p><ul><li><p>interestOps：表示 <code>SocketChannel</code> 所关心的事件类型，也就是告诉选择器，当有这几种事件发生时，才来通知我。这里通过<code>key.interestOps(SelectionKey.OP_READ);</code>告诉选择器，之后我只关心“读就绪”事件，其他的不用通知我了。</p></li><li><p>readyOps：表示 <code>SocketChannel</code> 当前就绪的事件类型。以<code>key.isReadable()</code>为例，判断依据就是：<code>return (readyOps() &amp; OP_READ) != 0;</code></p></li></ul></li></ul><h3 id="处理读取就绪事件"><a href="#处理读取就绪事件" class="headerlink" title="处理读取就绪事件"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%A4%84%E7%90%86%E8%AF%BB%E5%8F%96%E5%B0%B1%E7%BB%AA%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener"></a>处理读取就绪事件</h3><pre>private void receive(SelectionKey key) throws IOException {    SocketChannel channel = (SocketChannel) key.channel();    ByteBuffer buffer = ByteBuffer.allocate(1024);    channel.read(buffer);    buffer.flip();    String receiveData = charset.decode(buffer).toString();    // 当再没有数据可读时，取消在选择器中的关联，并关闭 socket 连接    if ("".equals(receiveData)) {        key.cancel();        channel.close();        return;    }    System.out.println(receiveData);}</pre><p>这里的处理基本与写入一致，唯一要注意的是，这里我们需要自行处理去缓冲区读取数据的操作。首先会分配一个固定大小的缓冲区，然后从内核缓冲区中，拷贝数据至我们刚分配固定缓冲区上。这里存在两种情况：</p><ul><li>我们分配的缓冲区过大，那多余的部分以0补充（_初始化时，其实会自动补0_）。</li><li>我们分配的缓冲去过小，因为选择器会不停的遍历。只要 <code>SocketChannel</code> 处理读就绪状态，那下一次会继续读取。当然，分配过小，会增加遍历次数。</li></ul><p>最后，将一下 <code>ByteBuffer</code> 的结构，它主要有 position, limit,capacity 以及 mark 属性。以 <code>buffer.flip();</code> 为例，讲下各属性的作用（_mark 主要是用来标记之前 position 的位置，是在当前 postion 无法满足的情况下使用的，这里不作讨论_）。</p><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-03.png" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-03.png" alt></a></p><p>从图中看出，</p><ul><li>容量（capacity）：表示缓冲区可以保存的数据容量；</li><li>极限（limit）：表示缓冲区的当前终点，即写入、读取都不可超过该重点；</li><li>位置（position）：表示缓冲区下一个读写单元的位置；</li></ul><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener"></a>完整代码</h3><pre>package com.jason.network.mode.nio;import com.jason.network.constant.HttpConstant;import com.jason.network.util.HttpUtil;import java.io.IOException;import java.net.InetSocketAddress;import java.net.SocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.nio.charset.Charset;import java.util.Iterator;import java.util.Set;public class NioNonBlockingHttpClient {    private static Selector selector;    private Charset charset = Charset.forName("utf8");    static {        try {            selector = Selector.open();        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws IOException {        NioNonBlockingHttpClient client = new NioNonBlockingHttpClient();        for (String host: HttpConstant.HOSTS) {            client.request(host, HttpConstant.PORT);        }        client.select();    }    public void request(String host, int port) throws IOException {        SocketChannel socketChannel = SocketChannel.open();        socketChannel.socket().setSoTimeout(5000);        SocketAddress remote = new InetSocketAddress(host, port);        socketChannel.configureBlocking(false);        socketChannel.connect(remote);        socketChannel.register(selector,                        SelectionKey.OP_CONNECT                        | SelectionKey.OP_READ                        | SelectionKey.OP_WRITE);    }    public void select() throws IOException {        while (selector.select(500) > 0){            Set keys = selector.selectedKeys();            Iterator it = keys.iterator();            while (it.hasNext()){                SelectionKey key = (SelectionKey)it.next();                it.remove();                if (key.isConnectable()){                    connect(key);                }                else if (key.isWritable()){                    write(key);                }                else if (key.isReadable()){                    receive(key);                }            }        }    }    private void connect(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();        channel.finishConnect();        InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();        String host = remote.getHostName();        int port = remote.getPort();        System.out.println(String.format("访问地址: %s:%s 连接成功!", host, port));    }    private void write(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();        InetSocketAddress remote = (InetSocketAddress) channel.socket().getRemoteSocketAddress();        String host = remote.getHostName();        String request = HttpUtil.compositeRequest(host);        System.out.println(request);        channel.write(charset.encode(request));        key.interestOps(SelectionKey.OP_READ);    }    private void receive(SelectionKey key) throws IOException {        SocketChannel channel = (SocketChannel) key.channel();        ByteBuffer buffer = ByteBuffer.allocate(1024);        channel.read(buffer);        buffer.flip();        String receiveData = charset.decode(buffer).toString();        if ("".equals(receiveData)) {            key.cancel();            channel.close();            return;        }        System.out.println(receiveData);    }}</pre><h3 id="示例效果"><a href="#示例效果" class="headerlink" title="示例效果"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E7%A4%BA%E4%BE%8B%E6%95%88%E6%9E%9C" target="_blank" rel="noopener"></a>示例效果</h3><p><a href="https://github.com/jasonGeng88/blog/blob/master/201708/assets/java-nio-04.png" target="_blank" rel="noopener"><img src="https://github.com/jasonGeng88/blog/raw/master/201708/assets/java-nio-04.png" alt></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener"></a>总结</h2><p>本文从 nio 的阻塞方式讲起，介绍了阻塞 I/O 与非阻塞 I/O 的区别，以及在 nio 下是如何一步步构建一个 IO 多路复用的模型的客户端。文中需要理解的内容比较多，如果有理解错误的地方，欢迎指正~</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a><a href="https://github.com/jasonGeng88/blog/blob/master/201708/java-nio.md#%E5%90%8E%E7%BB%AD" target="_blank" rel="noopener"></a>后续</h2><ul><li>Netty 下的异步请求实现</li></ul><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://github.com/jasonGeng88/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jasonGeng88/blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章将同步到我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《不可轻视的Java网络编程》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从计算机网络的基础知识入手，一步步地学习Java网络基础，从socket到nio、bio、aio和netty等网络编程知识，并且进行实战，网络编程是每一个Java后端工程师必须要学习和理解的知识点，进一步来说，你还需要掌握Linux中的网络编程原理，包括IO模型、网络编程框架netty的进阶原理，才能更完整地了解整个Java网络编程的知识体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供部分知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界16：极简配置的SpringBoot</title>
    <link href="http://yoursite.com/2019/10/28/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C16%EF%BC%9A%E6%9E%81%E7%AE%80%E9%85%8D%E7%BD%AE%E7%9A%84SpringBoot/"/>
    <id>http://yoursite.com/2019/10/28/走进JavaWeb技术世界/走进JavaWeb技术世界16：极简配置的SpringBoot/</id>
    <published>2019-10-28T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.009Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/7896890-9323041dd0ce883e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="Spring-Boot-概述"><a href="#Spring-Boot-概述" class="headerlink" title="Spring Boot 概述"></a>Spring Boot 概述</h2><blockquote><p><strong>Build Anything with Spring Boot：</strong>Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.</p></blockquote><p>上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p><h4 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot"></a>什么是 Spring Boot</h4><ul><li>它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。</li><li>它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架（引自：<a href="http://www.ityouknow.com/springboot/2016/01/06/springboot(%E4%B8%80)-%E5%85%A5%E9%97%A8%E7%AF%87.html" target="_blank" rel="noopener">springboot(一)：入门篇——纯洁的微笑</a>）</li></ul><h4 id="使用-Spring-Boot-有什么好处"><a href="#使用-Spring-Boot-有什么好处" class="headerlink" title="使用 Spring Boot 有什么好处"></a>使用 Spring Boot 有什么好处</h4><p>回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：</p><ul><li>1）配置 web.xml，加载 spring 和 spring mvc</li><li>2）配置数据库连接、配置日志文件</li><li>3）配置家在配置文件的读取，开启注解</li><li>4）配置mapper文件</li><li><strong>…..</strong></li></ul><p>而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了…</p><ul><li>划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。</li></ul><hr><h2 id="Spring-Boot-快速搭建"><a href="#Spring-Boot-快速搭建" class="headerlink" title="Spring Boot 快速搭建"></a>Spring Boot 快速搭建</h2><h4 id="第一步：新建项目"><a href="#第一步：新建项目" class="headerlink" title="第一步：新建项目"></a>第一步：新建项目</h4><p>选择 Spring Initializr ，然后选择默认的 url 点击【Next】：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-3e2c9c5742c10c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后修改一下项目的信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-28dbe478ff25a3a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>勾选上 Web 模板：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-532868b7e6760e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>选择好项目的位置，点击【Finish】：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-931cc2fb5c8964e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>如果是第一次配置 Spring Boot 的话可能需要等待一会儿 IDEA 下载相应的 依赖包，默认创建好的项目结构如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-9ac7acc56d5a32f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>项目结构还是看上去挺清爽的，少了很多配置文件，我们来了解一下默认生成的有什么：</p><ul><li>SpringbootApplication： 一个带有 main() 方法的类，用于启动应用程序</li><li>SpringbootApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文</li><li>application.properties：一个空的 properties 文件，可以根据需要添加配置属性</li><li>pom.xml： Maven 构建说明文件</li></ul><h4 id="第二步：HelloController"><a href="#第二步：HelloController" class="headerlink" title="第二步：HelloController"></a>第二步：HelloController</h4><p>在【cn.wmyskxz.springboot】包下新建一个【HelloController】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package cn.wmyskxz.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试控制器</span><br><span class="line"> *</span><br><span class="line"> * @author: @我没有三颗心脏</span><br><span class="line"> * @create: 2018-05-08-下午 16:46</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello Spring Boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@RestController 注解：</strong> 该注解是 @Controller 和 @ResponseBody 注解的合体版</li></ul><h4 id="第三步：利用-IDEA-启动-Spring-Boot"><a href="#第三步：利用-IDEA-启动-Spring-Boot" class="headerlink" title="第三步：利用 IDEA 启动 Spring Boot"></a>第三步：利用 IDEA 启动 Spring Boot</h4><p>我们回到 SpringbootApplication 这个类中，然后右键点击运行：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-bf1aa6ed5c0db7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><strong>注意</strong>：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat</li></ul><p>等待一会儿就会看到下方的成功运行的提示信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-63e43dc6a277de3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “<code>/hello</code>” 地址试一下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-6111e1913c5bf6d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到页面成功显示出我们返回的信息。</p><hr><h2 id="解析-Spring-Boot-项目"><a href="#解析-Spring-Boot-项目" class="headerlink" title="解析 Spring Boot 项目"></a>解析 Spring Boot 项目</h2><blockquote><p>这一部分参考自：<a href="http://tengj.top/2017/02/26/springboot1/" target="_blank" rel="noopener">Spring Boot干货系列（一）优雅的入门篇 ——嘟嘟独立博客</a></p></blockquote><h4 id="解析-pom-xml-文件"><a href="#解析-pom-xml-文件" class="headerlink" title="解析 pom.xml 文件"></a>解析 pom.xml 文件</h4><p>让我们来看看默认生成的 pom.xml 文件中到底有一些什么特别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt;</span><br><span class="line">    springboot</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;springboot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        spring-boot-starter-parent</span><br><span class="line">        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            spring-boot-starter-web</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            spring-boot-starter-test</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                spring-boot-maven-plugin</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到一个比较陌生一些的标签 <code>&lt;parent&gt;</code> ，这个标签是在配置 Spring Boot 的父级依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    spring-boot-starter-parent</span><br><span class="line">    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>有了这个，当前的项目才是 Spring Boot 项目，spring-boot-starter-parent 是一个特殊的 starter ，它用来提供相关的 Maven 默认依赖，<strong>使用它之后，常用的包依赖就可以省去 version 标签。</strong></p><p>关于具体 Spring Boot 提供了哪些 jar 包的依赖，我们可以查看本地 Maven 仓库下：\repository\org\springframework\boot\spring-boot-dependencies\2.0.1.RELEASE\spring-boot-dependencies-2.0.1.RELEASE.pom 文件来查看，挺长的…</p><h4 id="应用入口类"><a href="#应用入口类" class="headerlink" title="应用入口类"></a>应用入口类</h4><p>Spring Boot 项目通常有一个名为 <em>Application 的入口类，入口类里有一个 main 方法， *</em>这个 main 方法其实就是一个标准的 Javay 应用的入口方法。**</p><p><strong>@SpringBootApplication</strong> 是 Spring Boot 的核心注解，它是一个组合注解，该注解组合了：<strong>@Configuration、@EnableAutoConfiguration、@ComponentScan；</strong> 若不是用 @SpringBootApplication 注解也可以使用这三个注解代替。</p><ul><li>其中，<strong>@EnableAutoConfiguration 让 Spring Boot 根据类路径中的 jar 包依赖为当前项目进行自动配置</strong>，例如，添加了 spring-boot-starter-web 依赖，会自动添加 Tomcat 和 Spring MVC 的依赖，那么 Spring Boot 会对 Tomcat 和 Spring MVC 进行自动配置。</li><li><strong>Spring Boot 还会自动扫描 @SpringBootApplication 所在类的同级包以及下级包里的 Bean</strong> ，所以入口类建议就配置在 grounpID + arctifactID 组合的包名下（这里为 cn.wmyskxz.springboot 包）</li></ul><h4 id="Spring-Boot-的配置文件"><a href="#Spring-Boot-的配置文件" class="headerlink" title="Spring Boot 的配置文件"></a>Spring Boot 的配置文件</h4><p>Spring Boot 使用一个全局的配置文件 application.properties 或 application.yml，放置在【src/main/resources】目录或者类路径的 /config 下。</p><p>Spring Boot 不仅支持常规的 properties 配置文件，还支持 yaml 语言的配置文件。yaml 是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p><p>Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。</p><blockquote><ul><li>简单实例一下</li></ul></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7896890-bcd65f7469b06608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们同样的将 Tomcat 默认端口设置为 8080 ，并将默认的访问路径从 “<code>/</code>” 修改为 “<code>/hello</code>” 时，使用 properties 文件和 yml 文件的区别如上图。</p><ul><li>注意： yml 需要在 “<code>:</code>” 后加一个空格，幸好 IDEA 很好地支持了 yml 文件的格式有良好的代码提示；</li></ul><blockquote><ul><li>我们可以自己配置多个属性</li></ul></blockquote><p>我们直接把 .properties 后缀的文件删掉，使用 .yml 文件来进行简单的配置，然后使用 @Value 来获取配置属性：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-0e808a82254d6a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>重启 Spring Boot ，输入地址：localhost:8080/hello 能看到正确的结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-c85216e8ea7910f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><strong>注意：</strong> 我们并没有在 yml 文件中注明属性的类型，而是在使用的时候定义的。</li></ul><p>你也可以在配置文件中使用当前配置：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-37e91abbc4550982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>仍然可以得到正确的结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-eabc3cd39b44fd0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><strong>问题：</strong> 这样写配置文件繁琐而且可能会造成类的臃肿，因为有许许多多的 @Value 注解。</li></ul><blockquote><ul><li>封装配置信息</li></ul></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7896890-2599817d8f2f50d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们可以把配置信息封装成一个类，首先在我们的 name 和 age 前加一个 student 前缀，然后新建一个 StudentProperties 的类用来封装这些信息，并用上两个注解：</p><ul><li>@Component：表明当前类是一个 Java Bean</li><li>@ConfigurationProperties(prefix = “student”)：表示获取前缀为 sutdent 的配置信息</li></ul><p>这样我们就可以在控制器中使用，重启得到正确信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-84dc1215d01f3fa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="Spring-Boot-热部署"><a href="#Spring-Boot-热部署" class="headerlink" title="Spring Boot 热部署"></a>Spring Boot 热部署</h4><p>在目前的 Spring Boot 项目中，当发生了任何修改之后我们都需要重新启动才能够正确的得到效果，这样会略显麻烦，Spring Boot 提供了热部署的方式，当发现任何类发生了改变，就会通过 JVM 类加载的方式，加载最新的类到虚拟机中，这样就不需要重新启动也能看到修改后的效果了。</p><blockquote><ul><li>做法也很简单，修改 pom.xml 即可！</li></ul></blockquote><p>我们往 pom.xml 中添加一个依赖就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    spring-boot-devtools</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这个需要为 true 热部署才有效 --&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>重新启动 Spring Boot ，然后修改任意代码，就能观察到控制台的自动重启现象：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-cec869956c3cf158.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>关于如何在 IDEA 中配置热部署：<a href="https://blog.csdn.net/xusheng_Mr/article/details/78771746" target="_blank" rel="noopener">传送门</a></p></blockquote><hr><h2 id="Spring-Boot-使用"><a href="#Spring-Boot-使用" class="headerlink" title="Spring Boot 使用"></a>Spring Boot 使用</h2><p>上面已经完成了 Spring Boot 项目的简单搭建，我们仅仅需要进行一些简单的设置，写一个 HelloController 就能够直接运行了，不要太简单…接下来我们再深入了解一下 Spring Boot 的使用。</p><h4 id="Spring-Boot-支持-JSP"><a href="#Spring-Boot-支持-JSP" class="headerlink" title="Spring Boot 支持 JSP"></a>Spring Boot 支持 JSP</h4><p>Spring Boot 的默认视图支持是 Thymeleaf 模板引擎，但是这个我们不熟悉啊，我们还是想要使用 JSP 怎么办呢？</p><blockquote><ul><li>第一步：修改 pom.xml 增加对 JSP 文件的支持</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- servlet依赖. --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    javax.servlet-api</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    jstl</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tomcat的支持.--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">    tomcat-embed-jasper</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第二步：配置试图重定向 JSP 文件的位置</li></ul></blockquote><p>修改 application.yml 文件，将我们的 JSP 文件重定向到 /WEB-INF/views/ 目录下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-7c17f7e10cfb2629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><ul><li>第三步：修改 HelloController</li></ul></blockquote><p>修改 @RestController 注解为 @Controller ，然后将 hello 方法修改为：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-2dc2c39cd962edc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><ul><li>第四步：新建 hello.jsp 文件</li></ul></blockquote><p>在【src/main】目录下依次创建 webapp、WEB-INF、views 目录，并创建一个 hello.jsp 文件：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-a180556d7ead9605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><ul><li>第五步：刷新网页</li></ul></blockquote><p>因为我们部署了热部署功能，所以只需要等待控制台重启信息完成之后再刷新网页就可以看到正确效果了：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-cfd20f747ffca978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>关于 404，使用 spring-boot:run 运行项目可以解决：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/7896890-27c1bf46487ba5eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="集成-MyBatis"><a href="#集成-MyBatis" class="headerlink" title="集成 MyBatis"></a>集成 MyBatis</h4><blockquote><ul><li>第一步：修改 pom.xml 增加对 MySql和 MyBatis 的支持</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    mybatis-spring-boot-starter</span><br><span class="line">    &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- mysql --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    mysql-connector-java</span><br><span class="line">    &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第二步：新增数据库链接参数</li></ul></blockquote><p>这里我们就直接使用之前创建好的 student 表了吧：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-1eda563cfdfbae65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><ul><li>第三步：创建 Student 实体类和 StudentMapper 映射类</li></ul></blockquote><p>在【cn.wmyskxz.springboot】下新建一个【pojo】包，然后在其下创建一个 Student 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private Integer student_id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Date birthday;</span><br><span class="line"></span><br><span class="line">    /* getter and setter */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在【cn.wmyskxz.springboot】下新建一个【mapper】包，然后在其下创建一个 StudentMapper 映射类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package cn.wmyskxz.springboot.mapper;</span><br><span class="line"></span><br><span class="line">import cn.wmyskxz.springboot.pojo.Student;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;SELECT * FROM student&quot;)</span><br><span class="line">    List&lt;Student&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第四步：编写 StudentController</li></ul></blockquote><p>在【cn.wmyskxz.springboot】下新建一个【controller】包，然后在其下创建一个 StudentController ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package cn.wmyskxz.springboot.controller;</span><br><span class="line"></span><br><span class="line">import cn.wmyskxz.springboot.mapper.StudentMapper;</span><br><span class="line">import cn.wmyskxz.springboot.pojo.Student;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Student 控制器</span><br><span class="line"> *</span><br><span class="line"> * @author: @我没有三颗心脏</span><br><span class="line"> * @create: 2018-05-08-下午 20:25</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">public class StudentController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/listStudent&quot;)</span><br><span class="line">    public String listStudent(Model model) &#123;</span><br><span class="line">        List&lt;Student&gt; students = studentMapper.findAll();</span><br><span class="line">        model.addAttribute(&quot;students&quot;, students);</span><br><span class="line">        return &quot;listStudent&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第五步：编写 listStudent.jsp 文件</p></blockquote><p>我们简化一下 JSP 的文件，仅显示两个字段的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">         pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;table align=&apos;center&apos; border=&apos;1&apos; cellspacing=&apos;0&apos;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;id&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;name&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;c:forEach items=&quot;$&#123;students&#125;&quot; var=&quot;s&quot; varStatus=&quot;st&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;$&#123;s.id&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;s.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第六步：重启服务器运行</li></ul></blockquote><p>因为往 pom.xml 中新增加了依赖的包，所以自动重启服务器没有作用，我们需要手动重启一次，然后在地址输入：localhost:8080/listStudent 查看效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/7896890-5fd3c075d07b5840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote><h2 id="springMVC和springboot的区别"><a href="#springMVC和springboot的区别" class="headerlink" title="springMVC和springboot的区别"></a>springMVC和springboot的区别</h2><p>Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。</p><p>说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。</p><p><strong>Spring MVC的功能</strong></p><p>Spring MVC提供了一种轻度耦合的方式来开发web应用。</p><p>Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。</p><p><strong>Spring Boot的功能</strong></p><p>Spring Boot实现了自动配置，降低了项目搭建的复杂度。</p><p>众所周知Spring框架需要进行大量的配置，Spring Boot引入自动配置的概念，让项目设置变得很容易。Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p><p>Spring Boot只是承载者，辅助你简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。</p><p>对使用者来说，换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。</p><p>所以，用最简练的语言概括就是：</p><p>Spring 是一个“引擎”；</p><p>Spring MVC 是基于Spring的一个 MVC 框架 ；</p><p>Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/ThinkVenus/p/8026633.html" target="_blank" rel="noopener">https://www.cnblogs.com/ThinkVenus/p/8026633.html</a><br><a href="https://www.jianshu.com/p/f8b0b8616d4f" target="_blank" rel="noopener">https://www.jianshu.com/p/f8b0b8616d4f</a><br><a href="https://blog.csdn.net/qq_29229567/article/details/89209719" target="_blank" rel="noopener">https://blog.csdn.net/qq_29229567/article/details/89209719</a><br><a href="https://www.jianshu.com/p/ffe5ebe17c3a" target="_blank" rel="noopener">https://www.jianshu.com/p/ffe5ebe17c3a</a><br><a href="https://blog.csdn.net/qq_30258957/article/details/81700960" target="_blank" rel="noopener">https://blog.csdn.net/qq_30258957/article/details/81700960</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>深入JavaWeb技术世界15:深入浅出Mybatis基本原理</title>
    <link href="http://yoursite.com/2019/10/26/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E6%B7%B1%E5%85%A5JavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C15%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMybatis%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/26/走进JavaWeb技术世界/深入JavaWeb技术世界15：深入浅出Mybatis基本原理/</id>
    <published>2019-10-26T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.005Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在mybatis的基础知识中我们已经可以对mybatis的工作方式窥斑见豹（参考：《MyBatis————基础知识》）。</p><p>但是，为什么还要要学习mybatis的工作原理？因为，随着mybatis框架的不断发展，如今已经越来越趋于自动化，从代码生成，到基本使用，我们甚至不需要动手写一句SQL就可以完成一个简单应用的全部CRUD操作。</p><p>从原生mybatis到mybatis-spring，到mybatis-plus再到mybatis-plus-spring-boot-starter。spring在发展，mybatis同样在随之发展。</p><p>万变的外表终将迷惑人们的双眼，只要抓住核心我们永远不会迷茫！</p><h2 id="工作原理原型图"><a href="#工作原理原型图" class="headerlink" title="工作原理原型图"></a>工作原理原型图</h2><p>用最直观的图，来征服你的心！</p><p><img src="https://img-blog.csdn.net/20180624002302854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ3NDUwNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h2 id="工作原理解析"><a href="#工作原理解析" class="headerlink" title="工作原理解析"></a>工作原理解析</h2><p>mybatis应用程序通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件（也可以用Java文件配置的方式，需要添加@Configuration）中构建出SqlSessionFactory（SqlSessionFactory是线程安全的）；</p><p>然后，SqlSessionFactory的实例直接开启一个SqlSession，再通过SqlSession实例获得Mapper对象并运行Mapper映射的SQL语句，完成对数据库的CRUD和事务提交，之后关闭SqlSession。</p><p>说明：SqlSession是单线程对象，因为它是非线程安全的，是持久化操作的独享对象，类似jdbc中的Connection，底层就封装了jdbc连接。</p><p>详细流程如下：</p><p>1、加载mybatis全局配置文件（数据源、mapper映射文件等），解析配置文件，MyBatis基于XML配置文件生成Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着&lt;select | update | delete | insert&gt;标签项。</p><p>2、SqlSessionFactoryBuilder通过Configuration对象生成SqlSessionFactory，用来开启SqlSession。</p><p>3、SqlSession对象完成和数据库的交互：<br>a、用户程序调用mybatis接口层api（即Mapper接口中的方法）<br>b、SqlSession通过调用api的Statement ID找到对应的MappedStatement对象<br>c、通过Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql参数转化、动态sql拼接，生成jdbc Statement对象<br>d、JDBC执行sql。</p><p>e、借助MappedStatement中的结果映射关系，将返回结果转化成HashMap、JavaBean等存储结构并返回。</p><h2 id="mybatis层次图："><a href="#mybatis层次图：" class="headerlink" title="mybatis层次图："></a>mybatis层次图：</h2><p><img src="https://img-blog.csdn.net/20180625095624918?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ3NDUwNjk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h3 id="MyBatis框架及原理分析"><a href="#MyBatis框架及原理分析" class="headerlink" title="MyBatis框架及原理分析"></a><a href="https://www.cnblogs.com/adolfmc/p/8997281.html" target="_blank" rel="noopener">MyBatis框架及原理分析</a></h3><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架，其主要就完成2件事情：</p><ol><li>封装JDBC操作</li><li>利用反射打通Java类与SQL语句之间的相互转换</li></ol><p>MyBatis的主要设计目的就是让我们对执行SQL语句时对输入输出的数据管理更加方便，所以方便地写出SQL和方便地获取SQL的执行结果才是MyBatis的核心竞争力。</p><h2 id="MyBatis的配置"><a href="#MyBatis的配置" class="headerlink" title="MyBatis的配置"></a>MyBatis的配置</h2><p>MyBatis框架和其他绝大部分框架一样，需要一个配置文件，其配置文件大致如下：</p><pre><code>&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&gt;        &lt;!--&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &amp;lt;!&amp;ndash; 打印日志信息 &amp;ndash;&amp;gt;--&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;typeAlias type=&quot;com.luo.dao.UserDao&quot; alias=&quot;User&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!--事务管理类型--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;username&quot; value=&quot;luoxn28&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.1.150/ssh_study&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;userMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>以上配置中，最重要的是数据库参数的配置，比如用户名密码等，如果配置了数据表对应的mapper文件，则需要将其加入到<mappers>节点下。 </mappers></p><h2 id="MyBatis的主要成员"><a href="#MyBatis的主要成员" class="headerlink" title="MyBatis的主要成员"></a>MyBatis的主要成员</h2><ul><li>Configuration        MyBatis所有的配置信息都保存在Configuration对象之中，配置文件中的大部分配置都会存储到该类中</li><li>SqlSession            作为MyBatis工作的主要顶层API，表示和数据库交互时的会话，完成必要数据库增删改查功能</li><li>Executor               MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li><li>StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等</li><li>ParameterHandler  负责对用户传递的参数转换成JDBC Statement 所对应的数据类型</li><li>ResultSetHandler   负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</li><li>TypeHandler          负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换</li><li>MappedStatement  MappedStatement维护一条&lt;select|update|delete|insert&gt;节点的封装</li><li>SqlSource              负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li><li>BoundSql              表示动态生成的SQL语句以及相应的参数信息</li></ul><p>以上主要成员在一次数据库操作中基本都会涉及，在SQL操作中重点需要关注的是SQL参数什么时候被设置和结果集怎么转换为JavaBean对象的，这两个过程正好对应StatementHandler和ResultSetHandler类中的处理逻辑。</p><p><img src="http://img.blog.csdn.net/20141028140852531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVhbmxvdWlz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p><sub>(图片来自<a href="http://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的架构设计以及实例分析</a>)</sub></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/e398435fc1c4" target="_blank" rel="noopener">https://www.jianshu.com/p/e398435fc1c4</a><br><a href="https://segmentfault.com/a/1190000015117926?utm_source=tag-newest#articleHeader4" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015117926?utm_source=tag-newest#articleHeader4</a><br><a href="https://blog.csdn.net/u014745069/article/details/80788127" target="_blank" rel="noopener">https://blog.csdn.net/u014745069/article/details/80788127</a><br><a href="https://blog.csdn.net/u014297148/article/details/78696096" target="_blank" rel="noopener">https://blog.csdn.net/u014297148/article/details/78696096</a><br><a href="https://blog.csdn.net/weixin_43184769/article/details/91126687" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43184769/article/details/91126687</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界14：Mybatis入门</title>
    <link href="http://yoursite.com/2019/10/26/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C14%EF%BC%9AMybatis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/10/26/走进JavaWeb技术世界/走进JavaWeb技术世界14：Mybatis入门/</id>
    <published>2019-10-26T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.008Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。<br>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个Java Web技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习一个新东西前，如果能对他有一个比较直观的印象与定位，那么接下来的学习过程就会顺畅很多。所以本文主要是我对Mybatis的一个简单入门性的总结介绍（前提还是需要些必要的概念认知）。<br><em>PS:文末有参考列表</em></p><h2 id="Mybatis是什么"><a href="#Mybatis是什么" class="headerlink" title="Mybatis是什么"></a>Mybatis是什么</h2><p>Mybatis是一个持久层框架，用于数据的持久化。主要表现为将SQL与POJO进行一个映射，将SQL从代码中解耦。基本概念如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/4226917-700b83c25876d6d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/462/format/webp" alt></p><p>使用时，以User为例，UserMapper定义了<code>findById</code>接口，该接口返回一个User对象，接口的实现为一个xml配置文件。该xml文件中定义对应接口中的实现所需要的SQL。从而达到将SQL与代码解耦的目标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;   </span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  </span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;com.mybatis.UserMapper&quot;&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt;  </span><br><span class="line">        select user_id id,user_name userName,user_age age from t_user where user_id=#&#123;id&#125;  </span><br><span class="line">    &lt;/select&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><pre><code>MyBatis 是Apache的一个Java开源项目，是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。Mybatis可以将Sql语句配置在XML文件中，避免将Sql语句硬编码在Java类中。</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.Mybatis通过参数映射方式，可以将参数灵活的配置在SQL语句中的配置文件中，避免在Java类中配置参数（JDBC）</p><p>2.Mybatis通过输出映射机制，将结果集的检索自动映射成相应的Java对象，避免对结果集手工检索（JDBC）</p><p>3.Mybatis可以通过Xml配置文件对数据库连接进行管理</p><h3 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h3><p>1.SqlSessionaFactoryBuilder ：该类主要用于创建 SqlSessionFactory, 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。</p><p>2.SqlSessionFactory ：该类的作用了创建 SqlSession, 从名字上我们也能看出, 该类使用了工厂模式, 每次应用程序访问数据库, 我们就要通过 SqlSessionFactory 创建 SqlSession, 所以 SqlSessionFactory 和整个 Mybatis 的生命周期是相同的. 这也告诉我们不能创建多个同一个数据的 SqlSessionFactory, 如果创建多个, 会消耗尽数据库的连接资源, 导致服务器夯机. 应当使用单例模式. 避免过多的连接被消耗, 也方便管理。</p><p>3.SqlSession ：SqlSession 相当于一个会话, 每次访问数据库都需要这样一个会话, 大家可能会想起了 JDBC 中的 Connection, 很类似, 但还是有区别的, 何况现在几乎所有的连接都是使用的连接池技术, 用完后直接归还而不会像 Session 一样销毁. 注意: 他是一个线程不安全的对象, 在设计多线程的时候我们需要特别的当心, 操作数据库需要注意其隔离级别, 数据库锁等高级特性, 此外, 每次创建的 SqlSession 都必须及时关闭它, 它长期存在就会使数据库连接池的活动资源减少, 对系统性能的影响很大, 我们一般在 finally 块中将其关闭. 还有, SqlSession 存活于一个应用的请求和操作, 可以执行多条 Sql, 保证事务的一致性。SqlSession在执行过程中，有包含了几大对象：</p><pre><code>3.1.Executor ：执行器，由它调度 StatementHandler、ParameterHandler、ResultSetHandler 等来执行对应的 SQL。其中 StatementHandler 是最重要的。3.2.StatementHandler ：作用是使用数据库的 Statement（PreparedStatement）执行操作，它是四大对象的核心，起到承上启下的作用，许多重要的插件都是通过拦截它来实现的。3.3.ParamentHandler ：用来处理 SQL 参数的。3.4.ResultSetHandler ：进行数据集的封装返回处理的。</code></pre><p>4.Mapper ：映射器是一些由你创建的、绑定你映射的语句的接口。映射器接口的实例是从 SqlSession 中获得的, 他的作用是发送 SQL, 然后返回我们需要的结果. 或者执行 SQL 从而更改数据库的数据, 因此它应该在 SqlSession 的事务方法之内, 在 Spring 管理的 Bean 中, Mapper 是单例的。</p><h3 id="功能架构：我们把Mybatis的功能架构分为三层"><a href="#功能架构：我们把Mybatis的功能架构分为三层" class="headerlink" title="功能架构：我们把Mybatis的功能架构分为三层"></a>功能架构：我们把Mybatis的功能架构分为三层</h3><p>(1)API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</p><p>(2)数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</p><p>(3)基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJkc3RhdGljLmNvbS8tNG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzAlM0RiYWlrZTgwJTJDNSUyQzUlMkM4MCUyQzI2L3NpZ249NGRmM2FiMTQzOWRiYjZmZDMxNTZlZDc0Njg0ZGMwN2QvMGI0NmYyMWZiZTA5NmI2M2VhMGQ0MWJmMGMzMzg3NDRlYWY4YWNjYy5qcGc" alt></p><h3 id="框架结构："><a href="#框架结构：" class="headerlink" title="框架结构："></a>框架结构：</h3><p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</p><p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</p><p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p><p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MxLmJkc3RhdGljLmNvbS85dm8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzAlM0RiYWlrZTgwJTJDNSUyQzUlMkM4MCUyQzI2L3NpZ249ZjZjYzY5NzY4MjI2Y2ZmYzdkMjdiN2UwZDg2ODIxZjUvNjQzODBjZDc5MTIzOTdkZGUwY2Q4N2ViNTk4MmIyYjdkMWEyODdhYy5qcGc" alt></p><h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><p>1.获取SqlsessionFactory：根据配置文件（全局、sql映射）初始化configuration对象，</p><p>2.获取sqlSession：创建一个DefaultSqlSession对象，包含Configuration及Executor（根据全局配置文件中defaultExecutorType创建对应的Executor）</p><p>3.获取接口代理对象MapperProxy：DefaultSqlSession.getMapper拿到Mapper接口对应的MapperProxy</p><p>4.执行增删改查</p><pre><code>1、调用DefaultSqlSession增删改查2、创建StatementHandler （同时创建ParameterHandler,ResultSetHandler）3、调用StatementHandler预编译参数以及设置参数值，使用ParameterHandler给sql设置参数4、调用StatementHandler增删改查5、ResultSetHandler封装结果</code></pre><p><img src="https://img-blog.csdnimg.cn/20190821203129674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGViYWk=,size_16,color_FFFFFF,t_70" alt></p><h2 id="与Hibernate的异同"><a href="#与Hibernate的异同" class="headerlink" title="与Hibernate的异同"></a>与Hibernate的异同</h2><p>Mybatis开始逐渐流行起来，必然有其原因，简单了解了一下它与同为持久层框架的Hibernate的异同。</p><ul><li>映射模式<br>从上面的简单概念可以知道Mybatis实际上着力点在POJO与SQL的映射。而Hibernate则主要是POJO与数据库表的对象关系映射。前者掌控力度更细，代码量会相对多一点，后者灵活性则差一点，更为自动化一些，与PHP里的<code>Eloquent</code>属于同类型。</li><li>性能<br>Mybatis基于原生JDBC，相比于对JDBC进行二次封装的Hibernate性能会更好一点。</li><li>开发与维护<br>Hibernate配置好实体类后，使用起来是比较简洁，舒服的，但是前期学习曲线比较陡，后期调优比较麻烦。Mybatis对SQL掌控的颗粒更细一点，相比较而言看上去简陋些。由于直接映射SQL，迁移性是个问题。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000009707894" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009707894</a></p><p><a href="https://www.cnblogs.com/hysum/p/7100874.html" target="_blank" rel="noopener">https://www.cnblogs.com/hysum/p/7100874.html</a></p><p><a href="http://c.biancheng.net/view/939.html" target="_blank" rel="noopener">http://c.biancheng.net/view/939.html</a></p><p><a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p><p><a href="https://blog.csdn.net/android_hl/article/details/53228348" target="_blank" rel="noopener">https://blog.csdn.net/android_hl/article/details/53228348</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：黄小斜"><a href="#个人公众号：黄小斜" class="headerlink" title="个人公众号：黄小斜"></a>个人公众号：黄小斜</h3><p>黄小斜是跨考软件工程的 985 硕士，自学 Java 两年，拿到了 BAT 等近十家大厂 offer，从技术小白成长为阿里工程师。</p><p>作者专注于 JAVA 后端技术栈，热衷于分享程序员干货、学习经验、求职心得和程序人生，目前黄小斜的CSDN博客有百万+访问量，知乎粉丝2W+，全网已有10W+读者。</p><p>黄小斜是一个斜杠青年，坚持学习和写作，相信终身学习的力量，希望和更多的程序员交朋友，一起进步和成长！</p><p><strong>原创电子书:</strong><br>关注公众号【黄小斜】后回复【原创电子书】即可领取我原创的电子书《菜鸟程序员修炼手册：从技术小白到阿里巴巴Java工程师》</p><p><strong>程序员3T技术学习资源：</strong> 一些程序员学习技术的资源大礼包，关注公众号后，后台回复关键字 <strong>“资料”</strong> 即可免费无套路获取。    </p><p><strong>考研复习资料：</strong><br>计算机考研大礼包，都是我自己考研复习时用的一些复习资料,包括公共课和专业的复习视频，这里也推荐给大家，关注公众号后，后台回复关键字 <strong>“考研”</strong> 即可免费获取。    </p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h1 id="mybatis新手上路"><a href="#mybatis新手上路" class="headerlink" title="mybatis新手上路"></a>mybatis新手上路</h1><h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><p>Mybatis是Apache的一个Java开源项目，是一个支持动态Sql语句的持久层框架。Mybatis可以将Sql语句配置在XML文件中，避免将Sql语句硬编码在Java类中。与JDBC相比：</p><ol><li>Mybatis通过参数映射方式，可以将参数灵活的配置在SQL语句中的配置文件中，避免在Java类中配置参数（JDBC）</li><li>Mybatis通过输出映射机制，将结果集的检索自动映射成相应的Java对象，避免对结果集手工检索（JDBC）</li><li>Mybatis可以通过Xml配置文件对数据库连接进行管理。</li></ol><h2 id="MyBatis整体架构及运行流程"><a href="#MyBatis整体架构及运行流程" class="headerlink" title="MyBatis整体架构及运行流程"></a>MyBatis整体架构及运行流程</h2><p>Mybatis整体构造由 数据源配置文件、Sql映射文件、会话工厂、会话、执行器和底层封装对象组成。</p><h3 id="1-数据源配置文件"><a href="#1-数据源配置文件" class="headerlink" title="1.数据源配置文件"></a>1.数据源配置文件</h3><p>通过配置的方式将数据库的配置信息从应用程序中独立出来，由独立的模块管理和配置。Mybatis的数据源配置文件包含数据库驱动、数据库连接地址、用户名密码、事务管理等，还可以配置连接池的连接数、空闲时间等。</p><p>一个SqlMapConfig.xml基本的配置信息如下：</p><pre><configuration>    <!-- 加载数据库属性文件 -->    <properties resource="db.properties"></properties>    <environments default="development">        <environment id="development">            <!--使用JDBC实务管理-->            <transactionmanager type="JDBC"></transactionmanager>            <!--连接池 -->            <datasource type="POOLED">                <property name="driver" value="${jdbc.driver}"></property>                <property name="url" value="${jdbc.url}"></property>                <property name="username" value="${jdbc.username}">                <property name="password" value="${jdbc.password}">            </property></property></datasource>        </environment>    </environments></configuration></pre><h3 id="2-Sql映射文件"><a href="#2-Sql映射文件" class="headerlink" title="2.Sql映射文件"></a>2.Sql映射文件</h3><p>Mybatis中所有数据库的操作都会基于该映射文件和配置的sql语句，在这个配置文件中可以配置任何类型的sql语句。框架会根据配置文件中的参数配置，完成对sql语句以及输入输出参数的映射配置。</p><p>Mapper.xml配置文件大致如下：</p><pre><!DOCTYPE mapper     PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"     "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.sl.dao.ProductDao">    <!-- 根据id查询product表        resultType:返回值类型，一条数据库记录也就对应实体类的一个对象        parameterType:参数类型，也就是查询条件的类型 -->    <select id="selectProductById" resulttype="com.sl.po.Product" parametertype="int">     <!-- 这里和普通的sql 查询语句差不多，对于只有一个参数，后面的 #{id}表示占位符，里面不一定要写id,写啥都可以，但是不要空着，如果有多个参数则必须写pojo类里面的属性 --> select * from products where id = #{id} </select></mapper></pre><h3 id="3-会话工厂与会话"><a href="#3-会话工厂与会话" class="headerlink" title="3.会话工厂与会话"></a>3.会话工厂与会话</h3><p>Mybatis中会话工厂SqlSessionFactory类可以通过加载资源文件，读取数据源配置SqlMapConfig.xml信息，从而产生一种可以与数据库交互的会话实例SqlSession，会话实例SqlSession根据Mapper.xml文件中配置的sql,对数据库进行操作。</p><h3 id="4-运行流程"><a href="#4-运行流程" class="headerlink" title="4.运行流程"></a>4.运行流程</h3><p>会话工厂SqlSessionFactory通过加载资源文件获取SqlMapConfig.xml配置文件信息，然后生成可以与数据库交互的会话实例SqlSession。</p><p>会话实例可以根据Mapper配置文件中的Sql配置去执行相应的增删改查操作。</p><p>在SqlSession会话实例内部，通过执行器Executor对数据库进行操作，Executor依靠封装对象Mappered Statement，它分装了从mapper.xml文件中读取的信息（sql语句，参数，结果集类型）。</p><p>Mybatis通过执行器与Mappered Statement的结合实现与数据库的交互。</p><p>执行流程图：</p><p><img src="https://images2018.cnblogs.com/blog/577318/201807/577318-20180702181255132-2135681101.png" alt></p><h2 id="测试工程搭建"><a href="#测试工程搭建" class="headerlink" title="测试工程搭建"></a>测试工程搭建</h2><ol><li>新建maven工程</li></ol><p><img src="https://images2018.cnblogs.com/blog/577318/201807/577318-20180702181320571-1138935145.png" alt></p><p>2. 添加依赖pom.xml</p><pre><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">    <modelversion>4.0.0</modelversion>    <groupid>com.sl</groupid>    <artifactid>mybatis-demo</artifactid>    <version>0.0.1-SNAPSHOT</version>    <properties>        <junit.version>4.12</junit.version>        <mybatis.version>3.4.1</mybatis.version>        <mysql.version>5.1.32</mysql.version>        <log4j.version>1.2.17</log4j.version>    </properties>    <dependencies>        <!-- 单元测试 -->        <dependency>            <groupid>junit</groupid>            <artifactid>junit</artifactid>            <version>${junit.version}</version>            <!-- <scope>test</scope> -->        </dependency>        <!-- Mybatis -->        <dependency>            <groupid>org.mybatis</groupid>            <artifactid>mybatis</artifactid>            <version>${mybatis.version}</version>        </dependency>        <!-- mysql -->        <dependency>            <groupid>mysql</groupid>            <artifactid>mysql-connector-java</artifactid>            <version>${mysql.version}</version>        </dependency>        <!-- 日志处理 -->        <dependency>            <groupid>log4j</groupid>            <artifactid>log4j</artifactid>            <version>${log4j.version}</version>        </dependency>    </dependencies></project></pre><p>3.编写数据源配置文件SqlMapConfig.xml</p><pre><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"><configuration><!-- 加载配置文件 -->    <properties resource="db.properties"></properties>    <environments default="development">        <!-- id属性必须和上面的defaut一致 -->        <environment id="development">            <transactionmanager type="JDBC"></transactionmanager>            <!--dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象源 -->            <datasource type="POOLED">                <property name="driver" value="${jdbc.driver}"></property>                <property name="url" value="${jdbc.url}"></property>                <property name="username" value="${jdbc.username}">                <property name="password" value="${jdbc.password}">            </property></property></datasource>        </environment>    </environments>     <!—申明mapper文件 -->        <mappers>        <!-- xml实现    注册productMapper.xml文件 -->        <mapper resource="mapper/productMapper.xml"></mapper>    </mappers></configuration></pre><p>4.编写SQL映射配置文件productMapper.xml</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt></p><pre><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE mapper     PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"     "http://mybatis.org/dtd/mybatis-3-mapper.dtd"><mapper namespace="com.sl.mapper.ProductMapper">    <select id="selectAllProduct" resulttype="com.sl.po.Product"> select * from products </select></mapper></pre><p>5.编写测试代码TestClient.java</p><pre>//使用productMapper.xml配置文件public class TestClient { //定义会话SqlSession    SqlSession session =null;    @Before public void init() throws IOException { //定义mabatis全局配置文件        String resource = "SqlMapConfig.xml"; //加载mybatis全局配置文件 //InputStream inputStream = TestClient.class.getClassLoader().getResourceAsStream(resource); InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        SqlSessionFactory factory = builder.build(inputStream); //根据sqlSessionFactory产生会话sqlsession        session = factory.openSession();        } //查询所有user表所有数据 @Test public void testSelectAllUser() {        String statement = "com.sl.mapper.ProductMapper.selectAllProduct";        List<product> listProduct =session.selectList(statement); for(Product product:listProduct)        {            System.out.println(product);        } //关闭会话 session.close();        }}</product></pre><pre>public class Product { private int Id; private String Name; private String Description; private BigDecimal UnitPrice; private String ImageUrl; private Boolean IsNew; public int getId() { return Id;    } public void setId(int id) { this.Id = id;    } public String getName() { return Name;    } public void setName(String name) { this.Name = name;    } public String getDescription() { return Description;    } public void setDescription(String description) { this.Description = description;    } public BigDecimal getUnitPrice() { return UnitPrice;    } public void setUnitPrice(BigDecimal unitprice) { this.UnitPrice = unitprice;    } public String getImageUrl() { return Name;    } public void setImageUrl(String imageurl) { this.ImageUrl = imageurl;    } public boolean getIsNew() { return IsNew;    } public void setIsNew(boolean isnew) { this.IsNew = isnew;    }    @Override public String toString() { return "Product [id=" + Id + ", Name=" + Name + ", Description=" + Description + ", UnitPrice=" + UnitPrice + ", ImageUrl=" + ImageUrl + ", IsNew=" + IsNew+ "]";    }}</pre><p>6.运行测试用例</p><p><img src="https://images2018.cnblogs.com/blog/577318/201807/577318-20180702181558003-1700599553.png" alt></p><h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/06f68617fc04" target="_blank" rel="noopener">https://www.jianshu.com/p/06f68617fc04</a><br><a href="https://blog.csdn.net/tao5375/article/details/81774161" target="_blank" rel="noopener">https://blog.csdn.net/tao5375/article/details/81774161</a><br><a href="https://blog.csdn.net/qq_42897427/article/details/89191524" target="_blank" rel="noopener">https://blog.csdn.net/qq_42897427/article/details/89191524</a><br><a href="https://www.cnblogs.com/cailijia52o/p/8725850.html" target="_blank" rel="noopener">https://www.cnblogs.com/cailijia52o/p/8725850.html</a><br><a href="https://www.jianshu.com/p/f35598c769d9" target="_blank" rel="noopener">https://www.jianshu.com/p/f35598c769d9</a></p><h2 id="微信公众号-1"><a href="#微信公众号-1" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;br&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个Java Web技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界13：Hibernate入门经典与注解式开发</title>
    <link href="http://yoursite.com/2019/10/25/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C13%EF%BC%9AHibernate%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/10/25/走进JavaWeb技术世界/走进JavaWeb技术世界13：Hibernate入门经典与注解式开发/</id>
    <published>2019-10-25T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.008Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博文主要讲解介绍Hibernate框架，ORM的概念和Hibernate入门，相信你们看了就会使用Hibernate了!</p><p>什么是Hibernate框架？<br>Hibernate是一种ORM框架，全称为 Object_Relative DateBase-Mapping，在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象！</p><p>为什么要使用Hibernate？<br>既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是我们MVC中的数据持久层-&gt;在编写程序中的DAO层…</p><p>首先，我们来回顾一下我们在DAO层写程序的历程吧：</p><p>在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD<br>在DAO层使用原生JDBC连接数据库，实现CRUD<br>嫌弃JDBC的ConnectionStatementResultSet等对象太繁琐，使用对原生JDBC的封装组件–&gt;DbUtils组件<br>我们来看看使用DbUtils之后，程序的代码是怎么样的：</p><pre><code>public class CategoryDAOImpl implements zhongfucheng.dao.CategoryDao {    @Override    public void addCategory(Category category) {        QueryRunner queryRunner = new QueryRunner(Utils2DB.getDataSource());        String sql = &quot;INSERT INTO category (id, name, description) VALUES(?,?,?)&quot;;        try {            queryRunner.update(sql, new Object[]{category.getId(), category.getName(), category.getDescription()});        } catch (SQLException e) {            throw new RuntimeException(e);        }    }    @Override    public Category findCategory(String id) {        QueryRunner queryRunner = new QueryRunner(Utils2DB.getDataSource());        String sql = &quot;SELECT * FROM category WHERE id=?&quot;;        try {            Category category = (Category) queryRunner.query(sql, id, new BeanHandler(Category.class));            return category;        } catch (SQLException e) {            throw new RuntimeException(e);        }    }    @Override    public List&lt;Category&gt; getAllCategory() {        QueryRunner queryRunner = new QueryRunner(Utils2DB.getDataSource());        String sql = &quot;SELECT * FROM category&quot;;        try {            List&lt;Category&gt; categories = (List&lt;Category&gt;) queryRunner.query(sql, new BeanListHandler(Category.class));            return categories;        } catch (SQLException e) {            throw  new RuntimeException(e);        }    }}</code></pre><p>其实使用DbUtils时，DAO层中的代码编写是很有规律的。</p><p>当插入数据的时候，就将JavaBean对象拆分，拼装成SQL语句<br>当查询数据的时候，用SQL把数据库表中的列组合，拼装成JavaBean对象<br>也就是说：javaBean对象和数据表中的列存在映射关系!如果程序能够自动生成SQL语句就好了….那么Hibernate就实现了这个功能！</p><p>简单来说：我们使用Hibernate框架就不用我们写很多繁琐的SQL语句，从而简化我们的开发！</p><h2 id="ORM概述"><a href="#ORM概述" class="headerlink" title="ORM概述"></a>ORM概述</h2><p>在介绍Hibernate的时候，说了Hibernate是一种ORM的框架。那什么是ORM呢？ORM是一种思想</p><p>O代表的是Objcet<br>R代表的是Relative<br>M代表的是Mapping<br>ORM-&gt;对象关系映射….ORM关注是对象与数据库中的列的关系</p><p>Hibernate快速入门<br>学习一个框架无非就是三个步骤：</p><p>引入jar开发包<br>配置相关的XML文件<br>熟悉API<br>引入相关jar包<br>我们使用的是Hibernate3.6的版本</p><p>hibernate3.jar核心 + required 必须引入的(6个) + jpa 目录 + 数据库驱动包</p><p>编写对象和对象映射<br>编写一个User对象-&gt;User.java</p><pre><code>public class User {    private int id;    private String username;    private String password;    private String cellphone;    //各种setter和getter}</code></pre><p>编写对象映射-&gt;User.hbm.xml。一般它和JavaBean对象放在同一目录下</p><p>我们是不知道该XML是怎么写的，可以搜索一下Hibernate文件夹中后缀为.hbm.xml。看看它们是怎么写的。然后复制一份过来</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC     &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!--   This mapping demonstrates content-based discrimination for the  table-per-hierarchy mapping strategy, using a formula  discriminator.--&gt;&lt;hibernate-mapping     package=&quot;org.hibernate.test.array&quot;&gt;    &lt;class name=&quot;A&quot; lazy=&quot;true&quot; table=&quot;aaa&quot;&gt;        &lt;id name=&quot;id&quot;&gt;            &lt;generator class=&quot;native&quot;/&gt;        &lt;/id&gt;            &lt;key column=&quot;a_id&quot;/&gt;            &lt;list-index column=&quot;idx&quot;/&gt;            &lt;one-to-many class=&quot;B&quot;/&gt;    &lt;/class&gt;    &lt;class name=&quot;B&quot; lazy=&quot;true&quot; table=&quot;bbb&quot;&gt;        &lt;id name=&quot;id&quot;&gt;            &lt;generator class=&quot;native&quot;/&gt;        &lt;/id&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;</code></pre><p>在上面的模板上修改～下面会具体讲解这个配置文件!</p><pre><code>&lt;!--在domain包下--&gt;    &lt;hibernate-mapping package=&quot;zhongfucheng.domain&quot;&gt;        &lt;!--类名为User，表名也为User--&gt;        &lt;class name=&quot;User&quot;  table=&quot;user&quot;&gt;            &lt;!--主键映射，属性名为id，列名也为id--&gt;            &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;                &lt;!--根据底层数据库主键自动增长--&gt;                &lt;generator class=&quot;native&quot;/&gt;            &lt;/id&gt;            &lt;!--非主键映射，属性和列名一一对应--&gt;            &lt;property name=&quot;username&quot; column=&quot;username&quot;/&gt;            &lt;property name=&quot;cellphone&quot; column=&quot;cellphone&quot;/&gt;            &lt;property name=&quot;password&quot; column=&quot;password&quot;/&gt;        &lt;/class&gt;    &lt;/hibernate-mapping&gt;</code></pre><p>如果使用Intellij Idea生成的Hibernate可以指定生成出主配置文件hibernate.cfg.xml，它是要放在src目录下的</p><p>如果不是自动生成的，我们可以在Hibernate的hibernate-distribution-3.6.0.Final\project\etc这个目录下可以找到</p><p>它长得这个样子：</p><pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;property name=&quot;connection.url.&quot;/&gt;        &lt;property name=&quot;connection.driver_class&quot;/&gt;        &lt;property name=&quot;connection.username&quot;/&gt;        &lt;property name=&quot;connection.password&quot;/&gt;        &lt;!-- DB schema will be updated if needed --&gt;        &lt;!-- &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; --&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;</code></pre><p>通过上面的模板进行修改，后面会有对该配置文件进行讲解！</p><pre><code>&lt;hibernate-configuration&gt;    &lt;!-- 通常，一个session-factory节点代表一个数据库 --&gt;    &lt;session-factory&gt;        &lt;!-- 1\. 数据库连接配置 --&gt;        &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///zhongfucheng&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt;        &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt;        &lt;!--            数据库方法配置， hibernate在运行的时候，会根据不同的方言生成符合当前数据库语法的sql         --&gt;        &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;        &lt;!-- 2\. 其他相关配置 --&gt;        &lt;!-- 2.1 显示hibernate在运行时候执行的sql语句 --&gt;        &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;        &lt;!-- 2.2 格式化sql --&gt;        &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;        &lt;!-- 2.3 自动建表  --&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/property&gt;        &lt;!--3\. 加载所有映射--&gt;        &lt;mapping resource=&quot;zhongfucheng/domain/User.hbm.xml&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>package zhongfucheng.domain;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.hibernate.classic.Session;/** * Created by ozc on 2017/5/6. */public class App {    public static void main(String[] args) {        //创建对象        User user = new User();        user.setPassword(&quot;123&quot;);        user.setCellphone(&quot;122222&quot;);        user.setUsername(&quot;nihao&quot;);        //获取加载配置管理类        Configuration configuration = new Configuration();        //不给参数就默认加载hibernate.cfg.xml文件，        configuration.configure();        //创建Session工厂对象        SessionFactory factory = configuration.buildSessionFactory();        //得到Session对象        Session session = factory.openSession();        //使用Hibernate操作数据库，都要开启事务,得到事务对象        Transaction transaction = session.getTransaction();        //开启事务        transaction.begin();        //把对象添加到数据库中        session.save(user);        //提交事务        transaction.commit();        //关闭Session        session.close();    }}</code></pre><p>值得注意的是：JavaBean的主键类型只能是int类型，因为在映射关系中配置是自动增长的，String类型是不能自动增长的。如果是你设置了String类型，又使用了自动增长，那么就会报出下面的错误！</p><pre><code>Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table &apos;zhongfucheng.user&apos; does</code></pre><p>执行完程序后，Hibernate就为我们创建对应的表，并把数据存进了数据库了</p><p>我们看看快速入门案例的代码用到了什么对象吧，然后一个一个讲解</p><pre><code>public static void main(String[] args) {    //创建对象    User user = new User();    user.setPassword(&quot;123&quot;);    user.setCellphone(&quot;122222&quot;);    user.setUsername(&quot;nihao&quot;);    //获取加载配置管理类    Configuration configuration = new Configuration();    //不给参数就默认加载hibernate.cfg.xml文件，    configuration.configure();    //创建Session工厂对象    SessionFactory factory = configuration.buildSessionFactory();    //得到Session对象    Session session = factory.openSession();    //使用Hibernate操作数据库，都要开启事务,得到事务对象    Transaction transaction = session.getTransaction();    //开启事务    transaction.begin();    //把对象添加到数据库中    session.save(user);    //提交事务    transaction.commit();    //关闭Session    session.close();}</code></pre><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><p>Configuration<br>配置管理类：主要管理配置文件的一个类</p><p>它拥有一个子类AnnotationConfiguration，也就是说：我们可以使用注解来代替XML配置文件来配置相对应的信息</p><p>configure方法<br>configure()方法用于加载配置文件</p><p>加载主配置文件的方法</p><p>如果指定参数，那么加载参数的路径配置文件<br>如果不指定参数，默认加载src/目录下的hibernate.cfg.xml</p><p>buildSessionFactory方法<br>buildSessionFactory()用于创建Session工厂</p><p>SessionFactory<br>SessionFactory–&gt;Session的工厂，也可以说代表了hibernate.cfg.xml这个文件…hibernate.cfg.xml的就有<session-factory>这么一个节点</session-factory></p><p>openSession方法<br>创建一个Session对象</p><p>getCurrentSession方法<br>创建Session对象或取出Session对象</p><p>Session<br>Session是Hibernate最重要的对象，Session维护了一个连接（Connection），只要使用Hibernate操作数据库，都需要用到Session对象</p><p>通常我们在DAO层中都会有以下的方法，Session也为我们提供了对应的方法来实现！</p><pre><code>public interface IEmployeeDao {    void save(Employee emp);    void update(Employee emp);    Employee findById(Serializable id);    List&lt;Employee&gt; getAll();    List&lt;Employee&gt; getAll(String employeeName);    List&lt;Employee&gt; getAll(int index, int count);    void delete(Serializable id);}</code></pre><p>更新操作</p><p>我们在快速入门中使用到了save(Objcet o)方法，调用了这个方法就把对象保存在数据库之中了。Session对象还提供着其他的方法来进行对数据库的更新</p><p>session.save(obj); 【保存一个对象】<br>session.update(obj); 【更新一个对象】<br>session.saveOrUpdate(obj); 【保存或者更新的方法】</p><p>没有设置主键，执行保存；<br>有设置主键，执行更新操作;<br>如果设置主键不存在报错！<br>我们来使用一下update()方法吧….既然是更新操作了，那么肯定需要设置主键的，不设置主键，数据库怎么知道你要更新什么。将id为1的记录修改成如下：</p><pre><code>user.setId(1);user.setPassword(&quot;qwer&quot;);user.setCellphone(&quot;1111&quot;);user.setUsername(&quot;zhongfucheng&quot;);</code></pre><p>主键查询</p><p>通过主键来查询数据库的记录，从而返回一个JavaBean对象</p><p>session.get(javaBean.class, int id); 【传入对应的class和id就可以查询】<br>session.load(javaBean.class, int id); 【支持懒加载】<br>User重写toString()来看一下效果：</p><pre><code>User user1 = (User) session.get(User.class, 1); System.out.println(user1);</code></pre><p>HQL查询</p><p>HQL:hibernate query language 即hibernate提供的面向对象的查询语言</p><p>查询的是对象以及对象的属性【它查询的是对象以及属性，因此是区分大小写的！】。</p><pre><code>SQL：Struct query language 结构化查询语言</code></pre><p>查询的是表以及列【不区分大小写】<br>HQL是面向对象的查询语言，可以用来查询全部的数据！</p><pre><code>Query query = session.createQuery(&quot;FROM User&quot;);List list = query.list();System.out.println(list);</code></pre><p>当然啦，它也可以传递参数进去查询</p><pre><code>Query query = session.createQuery(&quot;FROM User WHERE id=?&quot;);//这里的？号是从0开始的，并不像JDBC从1开始的！query.setParameter(0, user.getId());List list = query.list();System.out.println(list);</code></pre><p>QBC查询</p><p>QBC查询: query by criteria 完全面向对象的查询</p><p>从上面的HQL查询，我们就可以发现：HQL查询是需要SQL的基础的，因为还是要写少部分的SQL代码….QBC查询就是完全的面向对象查询…但是呢，我们用得比较少</p><p>我们来看一下怎么使用吧：</p><pre><code>//创建关于user对象的criteria对象Criteria criteria = session.createCriteria(User.class);//添加条件criteria.add(Restrictions.eq(&quot;id&quot;, 1));//查询全部数据List list = criteria.list();System.out.println(list);</code></pre><p>本地SQL查询</p><p>有的时候，如果SQL是非常复杂的，我们不能靠HQL查询来实现功能的话，我们就需要使用原生的SQL来进行复杂查询了！</p><p>但是呢，它有一个缺陷：它是不能跨平台的…因此我们在主配置文件中已经配置了数据库的“方言“了。</p><p>我们来简单使用一下把：</p><pre><code>//将所有的记录封装成User对象存进List集合中SQLQuery sqlQuery = session.createSQLQuery(&quot;SELECT * FROM user&quot;).addEntity(User.class);List list = sqlQuery.list();System.out.println(list);</code></pre><p>beginTransaction方法</p><p>开启事务，返回的是一个事务对象….Hibernate规定所有的数据库操作都必须在事务环境下进行，否则报错！</p><p>Hibernate注解开发</p><p>在Hibernate中我们一般都会使用注解，这样可以帮助我们大大简化hbm映射文件的配置。下面我就来为大家详细介绍。</p><p>PO类注解配置</p><p>首先肯定是搭建好Hibernate的开发环境啦，我在此也不过多赘述，读者自行实践。接着在src目录下创建一个cn.itheima.domain包，并在该包下创建一个Book实体类，由于Book实体类中写有注解配置，所以就不用编写那个映射配置文件啦！</p><pre><code>@Entity // 定义了一个实体@Table(name=&quot;t_book&quot;,catalog=&quot;hibernateTest&quot;)public class Book {@Id // 这表示一个主键// @GeneratedValue 相当于native主键生成策略@GeneratedValue(strategy=GenerationType.IDENTITY) // 相当于identity主键生成策略private Integer id; // 主键@Column(name=&quot;c_name&quot;, length=30, nullable=true)private String name;@Temporal(TemporalType.TIMESTAMP) // 是用来定义日期类型private Date publicationDate; // 出版日期@Type(type=&quot;double&quot;) // 允许你去指定Hibernate里面的一些类型private Double price; // 价格，如果没有添加注解，也会自动的生成在表中public Integer getId() {    return id;}public void setId(Integer id) {    this.id = id;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public Date getPublicationDate() {    return publicationDate;}public void setPublicationDate(Date publicationDate) {    this.publicationDate = publicationDate;}public Double getPrice() {    return price;}public void setPrice(Double price) {    this.price = price;}</code></pre><p>}</p><p>下面我就来详细说一下Book实体类中的注解。</p><pre><code>@Entity：声明一个实体。@Table：来描述类与表之间的对应关系。@Entity // 定义了一个实体@Table(name=&quot;t_book&quot;,catalog=&quot;hibernateTest&quot;)public class Book {    ......}@id：声明一个主键。@GeneratedValue：用它来声明一个主键生成策略。默认情况是native主键生成策略。可以选择的主键生成策略有：AUTO、IDENTITY、SEQUENCE@Id // 这表示一个主键// @GeneratedValue 相当于native主键生成策略@GeneratedValue(strategy=GenerationType.IDENTITY) // 相当于identity主键生成策略private Integer id; // 主键@Column：定义列。@Column(name=&quot;c_name&quot;, length=30, nullable=true)private String name;</code></pre><p><strong>注意：对于PO类中所有属性，如果你不写注解，默认情况下也会在表中生成对应的列，列的名称就是属性的名称，列的类型也即属性的类型</strong>。<br>    @Temporal：声明日期类型。</p><pre><code>@Temporal(TemporalType.TIMESTAMP) // 是用来定义日期类型private Date publicationDate; // 出版日期</code></pre><p>日期类型可以选择的有：</p><pre><code>*   TemporalType.DATA：只有年月日。*   TemporalType.TIME：只有小时分钟秒。*   TemporalType.TIMESTAMP：有年月日小时分钟秒。@Type：可允许你去指定Hibernate里面的一些类型。@Type(type=&quot;double&quot;) // 允许你去指定Hibernate里面的一些类型private Double price; // 价格，如果没有添加注解，也会自动的生成在表中</code></pre><p>最后我们在src目录下创建一个cn.itheima.test包，在该包下编写一个HibernateAnnotationTest单元测试类，并在该类中编写一个用于测试PO类的注解开发的方法：</p><pre><code>public class HibernateAnnotationTest {    // 测试PO的注解开发    @Test    public void test1() {        Session session = HibernateUtils.openSession();        session.beginTransaction();        Book b = new Book();        b.setName(&quot;情书&quot;);        b.setPrice(56.78);        b.setPublicationDate(new Date());        session.save(b);        session.getTransaction().commit();        session.close();    }}</code></pre><p>现在来思考两个问题：</p><p>如果主键生成策略我们想使用UUID类型呢？<br>如何设定类的属性不在表中映射？<br>这两个问题我们一起解决。废话不多说，直接上例子。在cn.itheima.domain包下再编写一个Person实体类，同样使用注解配置。</p><pre><code>@Entity@Table(name=&quot;t_person&quot;, catalog=&quot;hibernateTest&quot;)public class Person {    // 生成UUID的主键生成策略    @Id    @GenericGenerator(name=&quot;myuuid&quot;, strategy=&quot;uuid&quot;) // 声明一种主键生成策略(uuid)    @GeneratedValue(generator=&quot;myuuid&quot;) // 引用uuid主键生成策略    private String id;    @Type(type=&quot;string&quot;) // 允许你去指定Hibernate里面的一些类型    private String name;    @Transient    private String msg; // 现在这个属性不想生成在表中    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }}</code></pre><p>最后在HibernateAnnotationTest单元测试类中编写如下一个方法：</p><pre><code>public class HibernateAnnotationTest {    // 测试uuid的主键生成策略及不生成表中映射    @Test    public void test2() {        Session session = HibernateUtils.openSession();        session.beginTransaction();        Person p = new Person();        p.setName(&quot;李四&quot;);        p.setMsg(&quot;这是一个好人&quot;);        session.save(p);        session.getTransaction().commit();        session.close();    }}</code></pre><p>至此，两个问题就解决了。<br>注意：对于我们以上讲解的关于属性配置的注解，我们也可以在其对应的getXxx方法去使用。</p><p>Hibernate关联映射——一对多（多对一）<br>仍以客户(Customer)和订单(Order)为例来开始我的表演。<br>在src目录下创建一个cn.itheima.oneToMany包，并在该包编写这两个实体类：</p><p>客户(Customer)类</p><pre><code>    // 客户 ---- 一的一方    @Entity    @Table(name=&quot;t_customer&quot;)    public class Customer {    @Id    @GeneratedValue(strategy=GenerationType.IDENTITY)    private Integer id; // 主键    private String name; // 姓名    // 描述客户可以有多个订单    /*     * targetEntity=&quot;...&quot;：相当于&lt;one-to-many &gt;     */    @OneToMany(targetEntity=Order.class,mappedBy=&quot;c&quot;)    private Set&lt;Order&gt; orders = new HashSet&lt;Order&gt;();    public Set&lt;Order&gt; getOrders() {        return orders;    }    public void setOrders(Set&lt;Order&gt; orders) {        this.orders = orders;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    }    订单(Order)类    // 订单 ---- 多的一方    @Entity    @Table(name=&quot;t_order&quot;)    public class Order {    @Id    @GeneratedValue(strategy=GenerationType.IDENTITY)    private Integer id;    private Double money;    private String receiverInfo; // 收货地址    // 订单与客户关联    @ManyToOne(targetEntity=Customer.class)    @JoinColumn(name=&quot;c_customer_id&quot;) // 指定外键列    private Customer c; // 描述订单属于某一个客户    public Customer getC() {        return c;    }    public void setC(Customer c) {        this.c = c;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public Double getMoney() {        return money;    }    public void setMoney(Double money) {        this.money = money;    }    public String getReceiverInfo() {        return receiverInfo;    }    public void setReceiverInfo(String receiverInfo) {        this.receiverInfo = receiverInfo;    }}</code></pre><p>这儿用到了<code>@OneToMany</code>和<code>@ManyToOne</code>这两个注解。<br>以上两个实体类编写好之后，可以很明显的看出我们不需要写它们对应的映射配置文件了，是不是很爽呢！接下来，我就要编写测试程序测试一下了。现在我的需求是保存客户时，顺便保存订单，对于这种情况我们需要在Customer类中配置cascade操作，即配置cascade=”save-update”，配置的方式有两种，下面我细细说来：</p><p>第一种方式，可以使用JPA提供的注解。<br>那么@OneToMany注解就应修改为：</p><pre><code>@OneToMany(targetEntity=Order.class,mappedBy=&quot;c&quot;,cascade=CascadeType.ALL)private Set&lt;Order&gt; orders = new HashSet&lt;Order&gt;();</code></pre><p>第二种方式，可以使用Hibernate提供的注解。<br>那么@OneToMany注解就应修改为：</p><pre><code>@OneToMany(targetEntity=Order.class,mappedBy=&quot;c&quot;)@Cascade(CascadeType.SAVE_UPDATE)private Set&lt;Order&gt; orders = new HashSet&lt;Order&gt;();</code></pre><p>两种方式都可以，口味任君选择，不过我倾向于第二种方式。<br>接下来在HibernateAnnotationTest单元测试类中编写如下方法进行测试：</p><pre><code>public class HibernateAnnotationTest {    // 测试one-to-many注解操作(保存客户时级联保存订单)    @Test    public void test3() {        Session session = HibernateUtils.openSession();        session.beginTransaction();        // 1.创建一个客户        Customer c = new Customer();        c.setName(&quot;叶子&quot;);        // 2.创建两个订单        Order o1 = new Order();        o1.setMoney(1000d);        o1.setReceiverInfo(&quot;武汉&quot;);        Order o2 = new Order();        o2.setMoney(2000d);        o2.setReceiverInfo(&quot;天门&quot;);        // 3.建立关系        c.getOrders().add(o1);        c.getOrders().add(o2);        // 4.保存客户，并级联保存订单        session.save(c);        session.getTransaction().commit();        session.close();    }}</code></pre><p>这时运行以上方法，会发现虽然客户表的那条记录插进去了，但是订单表就变成这个鬼样了： </p><p>订单表中没有关联客户的id，这是为什么呢？原因是我们在Customer类中配置了mappedBy=”c”，它代表的是外键的维护由Order方来维护，而Customer不维护，这时你在保存客户时，级联保存订单，是可以的，但是不能维护外键，所以，我们必须在代码中添加订单与客户之间的关系。所以须将test3方法修改为：</p><pre><code>public class HibernateAnnotationTest {    // 测试one-to-many注解操作(保存客户时级联保存订单)    @Test    public void test3() {        Session session = HibernateUtils.openSession();        session.beginTransaction();        // 1.创建一个客户        Customer c = new Customer();        c.setName(&quot;叶子&quot;);        // 2.创建两个订单        Order o1 = new Order();        o1.setMoney(1000d);        o1.setReceiverInfo(&quot;武汉&quot;);        Order o2 = new Order();        o2.setMoney(2000d);        o2.setReceiverInfo(&quot;天门&quot;);        // 3.建立关系        // 原因：是为了维护外键，不然的话，外键就不能正确的生成！！！        o1.setC(c);        o2.setC(c);        // 原因：是为了进行级联操作        c.getOrders().add(o1);        c.getOrders().add(o2);        // 4.保存客户，并级联保存订单        session.save(c);        session.getTransaction().commit();        session.close();    }}</code></pre><p>这时再测试，就没有任何问题啦！</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Hibernate注解@Cascade中的DELETE_ORPHAN已经过时了，如下： </p><p>可使用下面方案来替换过时方案： </p><p>Hibernate关联映射——多对多<br>以学生与老师为例开始我的表演，我是使用注解完成这种多对多的配置。使用@ManyToMany注解来配置多对多，只需要在一端配置中间表，另一端使用mappedBy表示放置外键的维护权。<br>在src目录下创建一个cn.itheima.manyToMany包，并在该包编写这两个实体类：</p><p>学生类</p><pre><code>@Entity@Table(name=&quot;t_student&quot;)public class Student {    @Id    @GeneratedValue(strategy=GenerationType.IDENTITY)    private Integer id;    private String name;    @ManyToMany(targetEntity=Teacher.class)    // @JoinTable：使用@JoinTable来描述中间表，并描述中间表中外键与Student、Teacher的映射关系    // joinColumns：它是用来描述Student与中间表的映射关系    // inverseJoinColumns：它是用来描述Teacher与中间表的映射关系    @JoinTable(name=&quot;s_t&quot;, joinColumns={@JoinColumn(name=&quot;c_student_id&quot;,referencedColumnName=&quot;id&quot;)}, inverseJoinColumns={@JoinColumn(name=&quot;c_teacher_id&quot;)})     private Set&lt;Teacher&gt; teachers = new HashSet&lt;Teacher&gt;();    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Set&lt;Teacher&gt; getTeachers() {        return teachers;    }    public void setTeachers(Set&lt;Teacher&gt; teachers) {        this.teachers = teachers;    }}</code></pre><p>老师类</p><pre><code>@Entity@Table(name=&quot;t_teacher&quot;)public class Teacher {    @Id    @GeneratedValue(strategy=GenerationType.IDENTITY)    private Integer id;    private String name;    @ManyToMany(targetEntity=Student.class, mappedBy=&quot;teachers&quot;) // 代表由对方来维护外键    private Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Set&lt;Student&gt; getStudents() {        return students;    }    public void setStudents(Set&lt;Student&gt; students) {        this.students = students;    }}</code></pre><p>接下来，我就要编写测试程序测试一下了。 从上面可看出我们将外键的维护权利交由Student类来维护，现在我们演示保存学生时，将老师也级联保存，对于这种情况我们需要在Student类中配置cascade操作，即配置cascade=”save-update”，如下：</p><pre><code>@JoinTable(name=&quot;s_t&quot;, joinColumns={@JoinColumn(name=&quot;c_student_id&quot;,referencedColumnName=&quot;id&quot;)}, inverseJoinColumns={@JoinColumn(name=&quot;c_teacher_id&quot;)}) @Cascade(CascadeType.SAVE_UPDATE)private Set&lt;Teacher&gt; teachers = new HashSet&lt;Teacher&gt;();</code></pre><p>接下来在HibernateAnnotationTest单元测试类中编写如下方法进行测试：</p><pre><code>public class HibernateAnnotationTest {    // 测试多对多级联保存(保存学生时同时保存老师)    @Test    public void test4() {        Session session = HibernateUtils.openSession();        session.beginTransaction();        // 1.创建两个老师        Teacher t1 = new Teacher();        t1.setName(&quot;Tom&quot;);        Teacher t2 = new Teacher();        t2.setName(&quot;Fox&quot;);        // 2.创建两个学生        Student s1 = new Student();        s1.setName(&quot;张丹&quot;);        Student s2 = new Student();        s2.setName(&quot;叶紫&quot;);        // 3.学生关联老师        s1.getTeachers().add(t1);        s1.getTeachers().add(t2);        s2.getTeachers().add(t1);        s2.getTeachers().add(t2);        // 保存学生同时保存老师        session.save(s1);        session.save(s2);        session.getTransaction().commit();        session.close();    }}</code></pre><p>运行以上方法，一切正常。<br>接着我们测试级联删除操作。见下图：<br>这里写图片描述</p><p>可在HibernateAnnotationTest单元测试类中编写如下方法进行测试：</p><pre><code>public class HibernateAnnotationTest {    // 测试多对多级联删除(前提是建立了双向的级联)    @Test    public void test5() {        Session session = HibernateUtils.openSession();        session.beginTransaction();        Student s = session.get(Student.class, 1);        session.delete(s);        session.getTransaction().commit();        session.close();    }}</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000009707894" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009707894</a></p><p><a href="https://www.cnblogs.com/hysum/p/7100874.html" target="_blank" rel="noopener">https://www.cnblogs.com/hysum/p/7100874.html</a></p><p><a href="http://c.biancheng.net/view/939.html" target="_blank" rel="noopener">http://c.biancheng.net/view/939.html</a></p><p><a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p><p><a href="https://blog.csdn.net/android_hl/article/details/53228348" target="_blank" rel="noopener">https://blog.csdn.net/android_hl/article/details/53228348</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="hibernate" scheme="http://yoursite.com/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界12：从手动编译打包到项目构建工具Maven</title>
    <link href="http://yoursite.com/2019/10/24/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C12%EF%BC%9A%E4%BB%8E%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E5%88%B0%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Maven/"/>
    <id>http://yoursite.com/2019/10/24/走进JavaWeb技术世界/走进JavaWeb技术世界12：从手动编译打包到项目构建工具Maven/</id>
    <published>2019-10-24T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.007Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><h2 id="maven简介"><a href="#maven简介" class="headerlink" title="maven简介"></a>maven简介</h2><h3 id="1-1-Maven是什么"><a href="#1-1-Maven是什么" class="headerlink" title="1.1 Maven是什么"></a>1.1 Maven是什么</h3><p>Maven是一个项目管理和综合工具。 Maven提供了开发人员构建一个完整的生命周期框架。开发者团队可以自动完成项目的基础工具建设， Maven使用标准的目录结构和默认构建生命周期。</p><p>在多个开发者团队环境时， Maven可以设置按标准在非常短的时间里完成配置工作。 由于大部分项目的设置都很简单， 并且可重复使用， Maven让开发人员的工作更轻松， 同时创建报表， 检查， 构建和测试自动化设置。</p><p>用过GitHub的同学看到这里应该感觉似曾相识，对，Maven和git的作用很相似，都是为了方便项目的创建与管理。</p><p>概括地说， Maven简化和标准化项目建设过程。 处理编译， 分配， 文档， 团队协作和其他任务的无缝连接。 Maven增加可重用性并负责建立相关的任务。</p><h3 id="1-2-Maven发展史"><a href="#1-2-Maven发展史" class="headerlink" title="1.2 Maven发展史"></a>1.2 Maven发展史</h3><p>Maven设计之初， 是为了简化Jakarta Turbine项目的建设。 在几个项目， 每个项目包含了不同的Ant构建文件。 JAR检查到CVS。 Apache组织开发Maven可以建立多个项目， 发布项目信息， 项目部署， 在几个项目中JAR文件提供团队合作和帮助。</p><p>Maven的经历了Maven-&gt; Maven2 -&gt; Maven3的发展。</p><h3 id="1-3-为什么要用Maven"><a href="#1-3-为什么要用Maven" class="headerlink" title="1.3 为什么要用Maven"></a>1.3 为什么要用Maven</h3><p>Maven之前我们经常使用Ant来进行Java项目的构建， 然后Ant仅是一个构建工具， 它并未对项目的中的工程依赖以及项目本身进行管理， 并且Ant作为构建工具未能消除软件构建的重复性， 因为不同的项目需要编写对应的Ant任务。</p><p>Maven作为后来者， 继承了Ant的项目构建功能， 并且提供了依赖关系， 项目管理的功能， 因此它是一个项目管理和综合工具， 其核心的依赖管理， 项目信息管理， 中央仓库， 约定大于配置的核心功能使得Maven成为当前Java项目构建和管理工具的标准选择。</p><p>学习Maven的理由是非常多：</p><p>主流IDE（Eclipse,IDEA,Netbean） 够内置了Maven</p><p>SpringFramework已经不再提供jar的下载， 直接通过Maven进行依赖下载。</p><p>在github， 开源社区几乎所有流行的Java项目都是通过Maven进行构建和管理的。</p><h2 id="Maven-新手入门"><a href="#Maven-新手入门" class="headerlink" title="Maven 新手入门"></a>Maven 新手入门</h2><h3 id="Maven概念"><a href="#Maven概念" class="headerlink" title="Maven概念"></a>Maven概念</h3><p>Maven作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现;它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。</p><p>Maven不仅是构建工具，还是一个依赖管理工具和项目管理工具，它提供了中央仓库，能帮我自动下载构件。</p><h3 id="maven的安装"><a href="#maven的安装" class="headerlink" title="maven的安装"></a>maven的安装</h3><p>一：因为本人是window系统，所以这里只介绍window下如何安装，在安装Maven之前，先确认已经安装了JDK.<br><a href="http://upload-images.jianshu.io/upload_images/5811881-5a7737962f83f677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/221/09092452baf3edd653f387516fb8be0d.png" alt="image.png" title="image.png"></a></p><p>二：接着去<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven官网</a>下载界面下载想要的版本解压到你想要的目录就行<br><a href="http://upload-images.jianshu.io/upload_images/5811881-16d9fd82c7f938ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/434/28b5fb0701c54ac4ada5500ed99bdc12.png" alt="image.png" title="image.png"></a></p><p><a href="http://upload-images.jianshu.io/upload_images/5811881-7482108a7ff71031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/370/fb1719c12ec1fec62d766168eb5fb2d2.png" alt="image.png" title="image.png"></a></p><p>三：最后设置一下环境变量，将Maven安装配置到操作系统环境中，主要就是配置M2_HOME 和PATH两项，如图<br><a href="http://upload-images.jianshu.io/upload_images/5811881-ffdf167e64415703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/162/46a29661ccbce3f798e931c61c9b39aa.png" alt="image.png" title="image.png"></a></p><p>都搞定后，验证一下，打开doc输入 mvn -v如何得到下面信息就说明配置成功了<br><a href="http://upload-images.jianshu.io/upload_images/5811881-c473853017951ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/496/373fd8fcc75b3e1af5f038ea33c36aa0.png" alt="image.png" title="image.png"></a></p><h3 id="maven目录"><a href="#maven目录" class="headerlink" title="maven目录"></a>maven目录</h3><p><a href="http://upload-images.jianshu.io/upload_images/5811881-8a4c77bcc9a4565a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/307/3244327db95e1096a8f82cf2fc66e62b.png" alt="image.png" title="image.png"></a></p><ul><li>bin目录：<br>该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。</li><li>boot目录:<br>该目录只包含一个文件，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库。</li><li>conf目录:<br>该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为，一般情况下，我们更偏向于复制该文件至<del>/.m2/目录下（</del>表示用户目录），然后修改该文件，在用户范围定制Maven的行为。</li><li>lib目录:<br>该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如commons-cli-1.2.jar、commons-lang-2.6.jar等等。</li></ul><h3 id="Maven常用命令说明"><a href="#Maven常用命令说明" class="headerlink" title="Maven常用命令说明"></a>Maven常用命令说明</h3><pre><code>mvn clean：表示运行清理操作（会默认把target文件夹中的数据清理）。mvn clean compile：表示先运行清理之后运行编译，会将代码编译到target文件夹中。mvn clean test：运行清理和测试。mvn clean package：运行清理和打包。mvn clean install：运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用。mvn clean deploy：运行清理和发布（发布到私服上面）。</code></pre><p>上面的命令大部分都是连写的，大家也可以拆分分别执行，这是活的，看个人喜好以及使用需求，Eclipse Run as对maven项目会提供常用的命令。</p><h3 id="Maven使用"><a href="#Maven使用" class="headerlink" title="Maven使用"></a>Maven使用</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.tengj&lt;/groupId&gt;    &lt;artifactId&gt;springBootDemo1&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;springBootDemo1&lt;/name&gt;&lt;/project&gt;</code></pre><p>代码的第一行是XML头，指定了该xml文档的版本和编码方式。<br>project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素。<br>根元素下的第一个子元素modelVersion指定了当前的POM模型的版本，对于Maven3来说，它只能是4.0.0<br>代码中最重要是包含了groupId,artifactId和version了。这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者jar都是以基于这些基本的坐标进行区分的。</p><p>groupId定义了项目属于哪个组，随意命名，比如谷歌公司的myapp项目，就取名为 com.google.myapp</p><p>artifactId定义了当前Maven项目在组中唯一的ID,比如定义hello-world。</p><p>version指定了项目当前的版本0.0.1-SNAPSHOT,SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的。</p><p>name元素生命了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name,以方便信息交流</p><h2 id="依赖的配置"><a href="#依赖的配置" class="headerlink" title="依赖的配置"></a><a href="http://tengj.top/2018/01/01/maven/#%E4%BE%9D%E8%B5%96%E7%9A%84%E9%85%8D%E7%BD%AE" title="依赖的配置" target="_blank" rel="noopener"></a>依赖的配置</h2><pre><code>&lt;project&gt;...&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;实际项目&lt;/groupId&gt;　　　　 &lt;artifactId&gt;模块&lt;/artifactId&gt;　　　　 &lt;version&gt;版本&lt;/version&gt;　　　　 &lt;type&gt;依赖类型&lt;/type&gt;　　　　 &lt;scope&gt;依赖范围&lt;/scope&gt;　　　　 &lt;optional&gt;依赖是否可选&lt;/optional&gt;　　　　 &lt;!—主要用于排除传递性依赖--&gt;　　　　 &lt;exclusions&gt;　　　　     &lt;exclusion&gt;　　　　　　　    &lt;groupId&gt;…&lt;/groupId&gt;　　　　　　　　　 &lt;artifactId&gt;…&lt;/artifactId&gt;　　　　　　　&lt;/exclusion&gt;　　　　 &lt;/exclusions&gt;　　&lt;/dependency&gt;&lt;dependencies&gt;...&lt;/project&gt;</code></pre><p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p><ul><li>grounpId、artifactId和version:以来的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</li><li>type:依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li><li>scope:依赖的范围</li><li>optional:标记依赖是否可选</li><li>exclusions:用来排除传递性依赖</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a><a href="http://tengj.top/2018/01/01/maven/#%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4" title="依赖范围" target="_blank" rel="noopener"></a>依赖范围</h2><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</p><ul><li>compile:编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</li><li>test: 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。</li><li>provided:已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。</li><li>runtime:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li><li>system:系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</li></ul><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.sql&lt;/groupId&gt;    &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt;    &lt;Version&gt;2.0&lt;/Version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${java.home}/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt;</code></pre><ul><li>import:导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。<br>上述除import以外的各种依赖范围与三种classpath的关系如下:</li></ul><p><a href="http://upload-images.jianshu.io/upload_images/5811881-e7cdb7800f523b6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/89/9304bde50143be84e01bb47451e00a99.png" alt="image.png" title="image.png"></a></p><h3 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h3><p>比如一个account-email项目为例，account-email有一个compile范围的spring-code依赖，spring-code有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖</p><p>有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p><h3 id="依赖范围-1"><a href="#依赖范围-1" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。</p><p><a href="http://upload-images.jianshu.io/upload_images/5811881-9e1e45b117656aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" title="image.png" target="_blank" rel="noopener"><img src="http://www.pianshen.com/images/361/15e6b876f6226edf630f3fc9f92c9ec9.png" alt="image.png" title="image.png"></a></p><p>从上图中，我们可以发现这样的规律：</p><ul><li>当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；</li><li>当第二直接依赖的范围是test的时候，依赖不会得以传递；</li><li>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided;</li><li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime.</li></ul><h2 id="Maven和Gradle的比较"><a href="#Maven和Gradle的比较" class="headerlink" title="Maven和Gradle的比较"></a>Maven和Gradle的比较</h2><p>Java生态体系中有三大构建工具：Ant、Maven和Gradle。其中，Ant是由Apache软件基金会维护；Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程；Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具，它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。</p><p>经过几年的发展，Ant几乎销声匿迹，而Maven由于较为不灵活的配置也渐渐被遗忘，而由于Gradle是基于Ant和Maven的一个优化版本，变得如日中天。</p><p>Maven的主要功能主要分为依赖管理系统、多模块构建、一致的项目结构、一致的构建模型和插件机制。这里通过这五个方面介绍两者的不同：</p><h3 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h3><p>在Maven的管理体系中，用GroupID、ArtifactID和Version组成的Coordination唯一标识一个依赖项。任何基于Maven构建的项目自身也必须定义这三项属性，生成的包可以是Jar包，也可以是War包或Ear包。</p><p>一个典型的引用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        spring-boot-starter-data-jpa</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        spring-boot-starter-thymeleaf</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        spring-boot-starter-test</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>这里 GroupID类似于C#中的namespace或者Java中的package，而ArtifactID相当于Class，Version相当于不同版本，如果Version忽略掉，将选择最新的版本链接。</p><p>同时，存储这些组件的仓库有远程仓库和本地仓库之分，远程仓库可以是使用世界公用的central仓库，也可以使用Apache Nexus自建的私有仓库；本地仓库则在本地计算机上。通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库地址。Gradle在设计时沿用了Maven这种依赖管理体系，同时也引入了改进，让依赖变得更加简洁：</p><pre><code>dependencies {// This dependency is exported to consumers, that is to say found on their compile classpath.api &apos;org.apache.commons:commons-math3:3.6.1&apos;// This dependency is used internally, and not exposed to consumers on their own compile classpath.implementation &apos;com.google.guava:guava:23.0&apos;// Use JUnit test frameworktestImplementation &apos;junit:junit:4.12&apos;compile &apos;org.hibernate:hibernate-core:3.6.7.Final&apos;testCompile ‘junit:junit:4.+&apos;}</code></pre><p>另外，Maven和Gradle对依赖项的审视也有所不同。在Maven中，一个依赖项有6种scope，分别是compile、provided、runtime、test、system、import。其中compile为默认。而gradle将其简化为4种，compile、runtime、testCompile、testRuntime。如上述代码“testCompile ‘junit:junit:4.+’”，在Gradle中支持动态的版本依赖，在版本号后面使用+号可以实现动态的版本管理。在解决依赖冲突方面Gradle的实现机制更加明确，两者都采用的是传递性依赖，而如果多个依赖项指向同一个依赖项的不同版本时可能会引起依赖冲突，Maven处理起来较为繁琐，而Gradle先天具有比较明确的策略。</p><h3 id="多模块构建"><a href="#多模块构建" class="headerlink" title="多模块构建"></a>多模块构建</h3><p>在面向服务的架构中，通常将一个项目分解为多个模块。在Maven中需要定义parent POM(Project Object Model)作为一组module的通用配置模型，在POM文件中可以使用<modules>标签来定义一组子模块。parent POM中的build配置以及依赖配置会自动继承给子module。</modules></p><p>Gradle也支持多模块构建，在parent的build.gradle中可以使用allprojects和subprojects代码块分别定义应用于所有项目或子项目中的配置。对于子模块中的定义放置在settings.gradle文件中，每一个模块代表project的对象实例，在parent的build.gradle中通过allproject或subprojects对这些对象进行操作，相比Maven更显灵活。</p><pre><code>allprojects {task nice &lt;&lt; { task -&gt; println &quot;I&apos;m $task.project.name&quot; }}</code></pre><p>执行命令gradle -q nice会依次打印出各模块的项目名称。</p><h3 id="一致的项目结构"><a href="#一致的项目结构" class="headerlink" title="一致的项目结构"></a>一致的项目结构</h3><p>Maven指定了一套项目目录结构作为标准的java项目结构，Gradle也沿用了这一标准的目录结构。如果在Gradle项目中使用了Maven项目结构的话，在Gradle中无需进行多余的配置，只需在文件中包括apply plugin:’java’，系统会自动识别source、resource、test source、test resource等相应资源。</p><p>同时，Gradle作为JVM上的构建工具，也支持Groovy、Scala等源代码的构建，同样功能Maven通过一些插件也能达到目的，但配置方面Gradle更灵活。</p><h3 id="一致的构建模型"><a href="#一致的构建模型" class="headerlink" title="一致的构建模型"></a>一致的构建模型</h3><p>为了解决Ant中对项目构建缺乏标准化的问题，Maven设置了标准的项目周期，构建周期：验证、初始化、生成原始数据、处理原始数据、生成资源、处理资源、编译、处理类、生成测试原始数据、处理测试原始数据、生成测试资源、处理测试资源、测试编译、处理测试类、测试、预定义包、生成包文件、预集成测试、集成测试、后集成测试、核实、安装、部署。但这种构建周期也是Maven应用的劣势。因为Maven将项目的构建周期限制过严，无法在构建周期中添加新的阶段，只能将插件绑定到已有的阶段上。而Gradle在构建模型上非常灵活，可以创建一个task，并随时通过depends建立与已有task的依赖关系。</p><h3 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h3><p>两者都采用了插件机制，Maven是基于XML进行配置，而在Gradle中更加灵活。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.pianshen.com/article/4537698845" target="_blank" rel="noopener">http://www.pianshen.com/article/4537698845</a><br><a href="https://www.jianshu.com/p/7248276d3bb5" target="_blank" rel="noopener">https://www.jianshu.com/p/7248276d3bb5</a><br><a href="https://www.cnblogs.com/lykbk/p/erwerwerwerwerwerwe.html" target="_blank" rel="noopener">https://www.cnblogs.com/lykbk/p/erwerwerwerwerwerwe.html</a><br><a href="https://blog.csdn.net/u012131888/article/details/78209514" target="_blank" rel="noopener">https://blog.csdn.net/u012131888/article/details/78209514</a><br><a href="https://blog.csdn.net/belvine/article/details/81073365" target="_blank" rel="noopener">https://blog.csdn.net/belvine/article/details/81073365</a><br><a href="https://blog.csdn.net/u012131888/article/details/78209514" target="_blank" rel="noopener">https://blog.csdn.net/u012131888/article/details/78209514</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script><p>​                     </p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界11：单元测试框架Junit</title>
    <link href="http://yoursite.com/2019/10/23/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C11%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Junit/"/>
    <id>http://yoursite.com/2019/10/23/走进JavaWeb技术世界/走进JavaWeb技术世界11：单元测试框架Junit/</id>
    <published>2019-10-23T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.006Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>测试 在软件开发中是一个很重要的方面，良好的测试可以在很大程度决定一个应用的命运。<br>软件测试中，主要有3大种类：</p><ul><li><a href="https://en.wikipedia.org/wiki/Unit_testing" target="_blank" rel="noopener">单元测试</a><br>单元测试主要是用于测试程序模块，确保代码运行正确。单元测试是由开发者编写并进行运行测试。一般使用的测试框架是 <a href="http://junit.org/junit4/" target="_blank" rel="noopener">JUnit</a> 或者 <a href="https://github.com/cbeust/testng" target="_blank" rel="noopener">TestNG</a>。测试用例一般是针对<em>方法</em> 级别的测试。</li><li><a href="https://en.wikipedia.org/wiki/Integration_testing" target="_blank" rel="noopener">集成测试</a><br>集成测试用于检测系统是否能正常工作。集成测试也是由开发者共同进行测试，与单元测试专注测试个人代码组件不同的是，集成测试是系统进行跨组件测试。</li><li><a href="https://en.wikipedia.org/wiki/Functional_testing" target="_blank" rel="noopener">功能性测试</a><br>功能性测试是一种质量保证过程以及基于测试软件组件的规范下的由输入得到输出的一种黑盒测试。功能性测试通常由不同的测试团队进行测试，测试用例的编写要遵循组件规范，然后根据测试输入得到的实际输出与期望值进行对比，判断功能是否正确运行。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文只对 <a href="https://en.wikipedia.org/wiki/Unit_testing" target="_blank" rel="noopener">单元测试</a> 进行介绍，主要介绍如何在 <a href="https://developer.android.com/studio/index.html?gclid=Cj0KCQjwgIPOBRDnARIsAHA1X3SC5vOHyIHQnIIfJ8hqJSuTiCG6p3u2ff_ti3EIVeCIGJLnP82YCKoaArSPEALw_wcB" target="_blank" rel="noopener">Android Studio</a> 下进行单元测试，单元测试使用的测试框架为 <a href="http://junit.org/junit4/" target="_blank" rel="noopener">JUnit</a></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>可能目前仍有很大一部分开发者未使用 <a href="https://en.wikipedia.org/wiki/Unit_testing" target="_blank" rel="noopener">单元测试</a> 对他们的代码进行测试，一方面可能是觉得没有必要，因为即使没有进行单元测试，程序照样运行得很好；另一方面，也许有些人也认同单元测试的好处，但是由于需要额外的学习成本，所以很多人也是没有时间或者说是没有耐心进行学习······<br>这里我想说的是，如果大家去看下 <a href="https://www.jianshu.com/p/www.github.com" target="_blank" rel="noopener">github</a> 上目前主流的开源框架，star 数比较多的项目，一般都有很详尽的测试用例。所以说，单元测试对于我们的项目开发，还是挺有好处的。<br>至于单元测试的好处，我这里提及几点：</p><ul><li>保证代码运行与我们预想的一样，代码正确性可以得到保证</li><li>程序运行出错时，有利于我们对错误进行查找（因为我们忽略我们测试通过的代码）</li><li>有利于提升代码架构设计（用于测试的用例应力求简单低耦合，因此编写代码的时候，开发者往往会为了对代码进行测试，将其他耦合的部分进行解耦处理）<br>······</li></ul><h2 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h2><p>本文实例讲述了java单元测试JUnit框架原理与用法。分享给大家供大家参考，具体如下：</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>JUnit是一个Java语言的单元测试框架，它由 Kent Beck 和 Erich Gamma 建立，逐渐成为 xUnit 家族中最为成功的一个。</p><p>JUnit有它自己的JUnit扩展生态圈，多数Java的开发环境都已经集成了JUnit作为单元测试的工具。在这里，一个单元可以是一个方法、类、包或者子系统。</p><p>因此，单元测试是指对代码中的最小可测试单元进行检查和验证，以便确保它们正常工作。例如，我们可以给予一定的输入测试输出是否是所希望得到的结果。在本篇博客中，作者将着重介绍 JUnit 4.X 版本的特性，这也是我们在日常开发中使用最多的版本。</p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2 特点"></a>2 特点</h3><pre><code>JUnit提供了注释以及确定的测试方法；JUnit提供了断言用于测试预期的结果；JUnit测试优雅简洁不需要花费太多的时间；JUnit测试让大家可以更快地编写代码并且提高质量；JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件；Junit显示测试进度，如果测试是没有问题条形是绿色的，测试失败则会变成红色；JUnit测试可以自动运行，检查自己的结果，并提供即时反馈，没有必要通过测试结果报告来手动梳理。</code></pre><h3 id="3-内容"><a href="#3-内容" class="headerlink" title="3 内容"></a>3 内容</h3><h4 id="3-1-注解"><a href="#3-1-注解" class="headerlink" title="3.1 注解"></a>3.1 注解</h4><p>@Test ：该注释表示，用其附着的公共无效方法（即用public修饰的void类型的方法 ）可以作为一个测试用例；</p><p>@Before ：该注释表示，用其附着的方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件；</p><p>@BeforeClass ：该注释表示，用其附着的静态方法必须执行一次并在类的所有测试之前，发生这种情况时一般是测试计算共享配置方法，如连接到数据库；</p><p>@After ：该注释表示，用其附着的方法在执行每项测试后执行，如执行每一个测试后重置某些变量，删除临时变量等；</p><p>@AfterClass ：该注释表示，当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，如断开数据库连接，注意：附有此批注（类似于BeforeClass）的方法必须定义为静态；</p><p>@Ignore ：该注释表示，当想暂时禁用特定的测试执行可以使用忽略注释，每个被注解为@Ignore的方法将不被执行。</p><pre><code>/* JUnit 注解示例*/@Testpublic void testYeepay(){  Syetem.out.println(&quot;用@Test标示测试方法！&quot;);}@AfterClasspublic static void paylus(){  Syetem.out.println(&quot;用@AfterClass标示的方法在测试用例类执行完之后！&quot;);}</code></pre><h4 id="3-2-断言"><a href="#3-2-断言" class="headerlink" title="3.2 断言"></a>3.2 断言</h4><p>在这里，作者将介绍一些断言方法，所有这些方法都来自 org.junit.Assert 类，其扩展了 java.lang.Object 类并为它们提供编写测试，以便检测故障。简而言之，我们就是通过断言方法来判断实际结果与我们预期的结果是否相同，如果相同，则测试成功，反之，则测试失败。</p><pre><code>void assertEquals([String message], expected value, actual value) ：断言两个值相等，值的类型可以为int、short、long、byte、char 或者java.lang.Object，其中第一个参数是一个可选的字符串消息；void assertTrue([String message], boolean condition) ：断言一个条件为真；void assertFalse([String message],boolean condition) ：断言一个条件为假；void assertNotNull([String message], java.lang.Object object) ：断言一个对象不为空(null)；void assertNull([String message], java.lang.Object object) ：断言一个对象为空(null)；void assertSame([String message], java.lang.Object expected, java.lang.Object actual) ：断言两个对象引用相同的对象；void assertNotSame([String message], java.lang.Object unexpected, java.lang.Object actual) ：断言两个对象不是引用同一个对象；void assertArrayEquals([String message], expectedArray, resultArray) ：断言预期数组和结果数组相等，数组的类型可以为int、long、short、char、byte 或者 java.lang.Object</code></pre><h3 id="4-JUnit-3-X-和-JUnit-4-X-的区别"><a href="#4-JUnit-3-X-和-JUnit-4-X-的区别" class="headerlink" title="4 JUnit 3.X 和 JUnit 4.X 的区别"></a>4 JUnit 3.X 和 JUnit 4.X 的区别</h3><h4 id="4-1-JUnit-3-X"><a href="#4-1-JUnit-3-X" class="headerlink" title="4.1 JUnit 3.X"></a>4.1 JUnit 3.X</h4><p>（1）使用 JUnit 3.X 版本进行单元测试时，测试类必须要继承于 TestCase 父类；<br>（2）测试方法需要遵循的原则：</p><p>① public的；<br>② void的；<br>③ 无方法参数；<br>④方法名称必须以 test 开头；</p><p>（3）不同的测试用例之间一定要保持完全的独立性，不能有任何的关联；</p><p>（4）要掌握好测试方法的顺序，不能依赖于测试方法自己的执行顺序。</p><pre><code>/* 用 JUnit 3.X 进行测试*/import junit.framework.Assert;import junit.framework.TestCase;public class TestOperation extends TestCase {  private Operation operation;  public TestOperation(String name) { // 构造函数    super(name);  }  @Override  public void setUp() throws Exception { // 在每个测试方法执行 [之前] 都会被调用，多用于初始化    System.out.println(&quot;欢迎使用Junit进行单元测试...&quot;);    operation = new Operation();  }  @Override  public void tearDown() throws Exception { // 在每个测试方法执行 [之后] 都会被调用，多用于释放资源    System.out.println(&quot;Junit单元测试结束...&quot;);  }  public void testDivideByZero() {    Throwable te = null;    try {      operation.divide(6, 0);      Assert.fail(&quot;测试失败&quot;); //断言失败    } catch (Exception e) {      e.printStackTrace();      te = e;    }    Assert.assertEquals(Exception.class, te.getClass());    Assert.assertEquals(&quot;除数不能为 0 &quot;, te.getMessage());  }}</code></pre><h4 id="4-2-JUnit-4-X"><a href="#4-2-JUnit-4-X" class="headerlink" title="4.2 JUnit 4.X"></a>4.2 JUnit 4.X</h4><p>（1）使用 JUnit 4.X 版本进行单元测试时，不用测试类继承TestCase父类；<br>（2）JUnit 4.X 版本，引用了注解的方式进行单元测试；<br>（3）JUnit 4.X 版本我们常用的注解包括：</p><p>@Before 注解：与JUnit 3.X 中的 setUp() 方法功能一样，在每个测试方法之前执行，多用于初始化；</p><p>@After 注解：与 JUnit 3.X 中的 tearDown() 方法功能一样，在每个测试方法之后执行，多用于释放资源；</p><p>@Test(timeout = xxx) 注解：设置当前测试方法在一定时间内运行完，否则返回错误；</p><p>@Test(expected = Exception.class) 注解：设置被测试的方法是否有异常抛出。抛出异常类型为：Exception.class；</p><p>此外，我们可以通过阅读上面的第二部分“2 注解”了解更多的注解。</p><pre><code>/* 用 JUnit 4.X 进行测试*/import static org.junit.Assert.*;import org.junit.After;import org.junit.AfterClass;import org.junit.Before;import org.junit.BeforeClass;import org.junit.Test;public class TestOperation {  private Operation operation;  @BeforeClass  public static void globalInit() { // 在所有方法执行之前执行    System.out.println(&quot;@BeforeClass标注的方法，在所有方法执行之前执行...&quot;);  }  @AfterClass  public static void globalDestory() { // 在所有方法执行之后执行    System.out.println(&quot;@AfterClass标注的方法，在所有方法执行之后执行...&quot;);  }  @Before  public void setUp() { // 在每个测试方法之前执行    System.out.println(&quot;@Before标注的方法，在每个测试方法之前执行...&quot;);    operation = new Operation();  }  @After  public void tearDown() { // 在每个测试方法之后执行    System.out.println(&quot;@After标注的方法，在每个测试方法之后执行...&quot;);  }  @Test(timeout=600)  public void testAdd() { // 设置限定测试方法的运行时间 如果超出则返回错误    System.out.println(&quot;测试 add 方法...&quot;);    int result = operation.add(2, 3);    assertEquals(5, result);  }  @Test  public void testSubtract() {    System.out.println(&quot;测试 subtract 方法...&quot;);    int result = operation.subtract(1, 2);    assertEquals(-1, result);  }  @Test  public void testMultiply() {    System.out.println(&quot;测试 multiply 方法...&quot;);    int result = operation.multiply(2, 3);    assertEquals(6, result);  }  @Test  public void testDivide() {    System.out.println(&quot;测试 divide 方法...&quot;);    int result = 0;    try {      result = operation.divide(6, 2);    } catch (Exception e) {      fail();    }    assertEquals(3, result);  }  @Test(expected = Exception.class)  public void testDivideAgain() throws Exception {    System.out.println(&quot;测试 divide 方法，除数为 0 的情况...&quot;);    operation.divide(6, 0);    fail(&quot;test Error&quot;);  }  public static void main(String[] args) {  }}</code></pre><h4 id="4-3-特别提醒"><a href="#4-3-特别提醒" class="headerlink" title="4.3 特别提醒"></a>4.3 特别提醒</h4><p>通过以上两个例子，我们已经可以大致知道 JUnit 3.X 和 JUnit 4.X 两个版本的区别啦！</p><p>首先，如果我们使用 JUnit 3.X，那么在我们写的测试类的时候，一定要继承 TestCase 类，但是如果我们使用 JUnit 4.X，则不需继承 TestCase 类，直接使用注解就可以啦！</p><p>在 JUnit 3.X 中，还强制要求测试方法的命名为“ testXxxx ”这种格式；</p><p>在 JUnit 4.X 中，则不要求测试方法的命名格式，但作者还是建议测试方法统一命名为“ testXxxx ”这种格式，简洁明了。</p><p>此外，在上面的两个示例中，我们只给出了测试类，但是在这之前，还应该有一个被测试类，也就是我们真正要实现功能的类。现在，作者将给出上面示例中被测试的类，即 Operation 类：</p><pre><code>/* 定义了加减乘除的法则*/public class Operation {  public static void main(String[] args) {    System.out.println(&quot;a + b = &quot; + add(1,2));    System.out.println(&quot;a - b = &quot; + subtract(1,2));    System.out.println(&quot;a * b = &quot; + multiply(1,2));    System.out.println(&quot;a / b = &quot; + divide(4,2));    System.out.println(&quot;a / b = &quot; + divide(1,0));  }  public static int add(int a, int b) {    return a + b;  }  public static int subtract(int a, int b) {    return a - b;  }  public static int multiply(int a, int b) {    return a * b;  }  public static int divide(int a, int b) {    return a / b;  }}</code></pre><h3 id="5-测试示例"><a href="#5-测试示例" class="headerlink" title="5 测试示例"></a>5 测试示例</h3><h4 id="5-1-示例一：简单的-JUnit-3-X-测试"><a href="#5-1-示例一：简单的-JUnit-3-X-测试" class="headerlink" title="5.1 示例一：简单的 JUnit 3.X 测试"></a>5.1 示例一：简单的 JUnit 3.X 测试</h4><pre><code>import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.util.ArrayList;import java.util.Collection;/ * 1、创建一个测试类，继承TestCase类 */public class SimpleTestDemo extends TestCase {  public SimpleTestDemo(String name) {    super(name);  }  /   * 2、写一个测试方法，断言期望的结果   */  public void testEmptyCollection(){    Collection collection = new ArrayList();    assertTrue(collection.isEmpty());  }  /   * 3、写一个suite()方法，它会使用反射动态的创建一个包含所有的testXxxx方法的测试套件   */  public static Test suit(){    return new TestSuite(SimpleTestDemo.class);  }  /   * 4、写一个main()方法，以文本运行器的方式方便的运行测试   */  public static void main(String[] args) {    junit.textui.TestRunner.run(suit());  }}</code></pre><h3 id="6-个人建议"><a href="#6-个人建议" class="headerlink" title="6 个人建议"></a>6 个人建议</h3><p>有些童鞋可能会有一些误解，认为写测试代码没有用，而且还会增大自己的压力，浪费时间。但事实上，写测试代码与否，还是有很大区别的，如果是在小的项目中，或许这种区别还不太明显，但如果在大型项目中，一旦出现错误或异常，用人力去排查的话，那将会浪费很多时间，而且还不一定排查的出来，但是如果用测试代码的话，JUnit 就是自动帮我们判断一些代码的结果正确与否，从而节省的时间将会远远超过你写测试代码的时间。</p><p>因此，个人建议：要养成编写测试代码的习惯，码一点、测一点；再码一点，再测一点，如此循环。在我们不断编写与测试代码的过程中，我们将会对类的行为有一个更为深入的了解，从而可以有效的提高我们的工作效率。下面，作者就给出一些具体的编写测试代码的技巧和较好的实践方法：</p><p>1. 不要用 TestCase 的构造函数初始化 Fixture，而要用 setUp() 和 tearDown() 方法；<br>2. 不要依赖或假定测试运行的顺序，因为 JUnit 会利用 Vector 保存测试方法，所以不同的平台会按不同的顺序从 Vector 中取出测试方法；<br>3. 避免编写有副作用的 TestCase，例如：如果随后的测试依赖于某些特定的交易数据，就不要提交交易数据，只需要简单的回滚就可以了；<br>4. 当继承一个测试类时，记得调用父类的 setUp() 和 tearDown() 方法；<br>5. 将测试代码和工作代码放在一起，同步编译和更新；<br>6. 测试类和测试方法应该有一致的命名方案，如在工作类名前加上 test 从而形成测试类名；<br>7. 确保测试与时间无关，不要使用过期的数据进行测试，以至于导致在随后的维护过程中很难重现测试；<br>8. 如果编写的软件面向国际市场，那么编写测试时一定要考虑国际化的因素；<br>9. 尽可能地利用 JUnit 提供地 assert 和 fail 方法以及异常处理的方法，其可以使代码更为简洁；<br>10. 测试要尽可能地小，执行速度快；<br>11. 不要硬性规定数据文件的路径；<br>12. 使用文档生成器做测试文档。</p><h2 id="8-大单元测试框架"><a href="#8-大单元测试框架" class="headerlink" title="8 大单元测试框架"></a>8 大单元测试框架</h2><p><img src="http://img.mp.itc.cn/upload/20170601/4310fd169d4d464db44fa73f25a241c3.jpg" alt></p><p>1.Arquillian</p><p>Arquillian是一个基于JVM的高度可扩展的测试平台，允许开发人员创建Java的自动化集成，功能和验收测试。Arquillian允许你在运行态时执行测试。Arquillian可用于管理容器（或容器）的生命周期，绑定测试用例，依赖类和资源。它还能够将压缩包部署到容器中，并在容器中执行测试并捕获结果并创建报告。</p><p>Arquillian集成了熟悉的测试框架，如JUnit 4、TestNG 5，并允许使用现有的IDE启动测试。并且由于其模块化设计，它能够运行Ant和Maven测试插件。Arquillian目的是简化项目集成测试和功能测试的编写，让它们能像单元测试一样简单。</p><p><img src="http://img.mp.itc.cn/upload/20170601/8c78fe84d7fa46b9b6dd9fc8ab001e00.jpg" alt></p><p>2.JTEST</p><p>JTest也被称为“Parasoft JTest”，是Parasoft公司生产的自动化Java软件测试和静态分析软件。 JTest包括用于单元测试用例生成和执行，静态代码分析，数据流静态分析和度量分析，回归测试，运行时错误检测的功能。</p><p>还可以进行结对的代码审查流程自动化和运行时错误检测，例如：条件，异常，资源和内存泄漏，安全攻击漏洞等。</p><p><img src="http://img.mp.itc.cn/upload/20170601/582197f6e97549bd894380f2b7320cc9.jpg" alt></p><p>3.The Grinder</p><p>“The Grinder”是一个Java负载测试框架。并且通过使用大量负载注射器来为分布式测试提供便利。Grinder可以对具有Java API的任何内容加载测试。这包括HTTP Web服务器，SOAP、REST Web服务、应用程序服务器，包括自定义协议。测试脚本用强大的Jython和Clojure语言编写。Grinder的GUI控制台允许对多个负载注射器进行监控和控制，并自动管理客户端连接和Cookie，SSL，代理感知和连接限制。您可以在这里找到关于磨床功能的更多深入信息。</p><p><img src="http://img.mp.itc.cn/upload/20170601/2d5c47277d254ad783c08b5f03a42372_th.jpg" alt></p><p>4.TestNG</p><p><img src="http://img.mp.itc.cn/upload/20170601/0e1f6408b31d4665b4cc75b47750d58d.jpg" alt></p><p>TestNG受JUnit和NUnit的启发，是为Java编程语言而设计的测试框架。TestNG主要设计用于覆盖更广泛的测试类别，如单元，功能，端到端，集成等。它还引入了一些新功能，使其更强大，更易于使用，如：注解，运行在大线程池中进行各种策略测试，多线程安全验证代码测试，灵活的测试配置，数据驱动的参数测试支持等等。</p><p>TestNG有各种工具和插件（如Eclipse，IDEA，Maven等）支持。</p><p><img src="http://img.mp.itc.cn/upload/20170601/21bc4cc5fd924b16b29be4880f9cfeab_th.jpg" alt></p><p>5.JUnit</p><p>JUnit是为Java编程语言设计的单元测试框架。JUnit在测试驱动开发框架的开发中发挥了重要作用。它是单元测试框架之一，统称为由SUnit起源的xUnit。</p><p><img src="http://img.mp.itc.cn/upload/20170601/9a6d602756f94c1ea8682fc811d679ef.jpg" alt></p><p>6.JWalk</p><p>JWalk被设计为用于Java编程语言的单元测试工具包。它被设计为支持称为“Lazy系统单元测试”的测试范例。</p><p><img src="http://img.mp.itc.cn/upload/20170601/5d6b9c4de39c43df9eabc2fc5eecca5e_th.jpg" alt></p><p>JWalkTester工具对任何由程序员提供的编译的Java类执行任何测试。它能够通过静态和动态分析以及来自程序员的提示来测试懒惰Lazy规范的一致性。</p><p><img src="http://img.mp.itc.cn/upload/20170601/34c2bae3fea44fd9a2ec54c7447207d5.jpg" alt></p><p>7.Mockito</p><p>Mockito被设计为用于Java的开源测试框架，MIT许可证。Mockito允许程序员为了测试驱动开发（TDD）或行为驱动开发（BDD）而在自动化单元测试中创建和测试双对象（Mock对象）。</p><p><img src="http://img.mp.itc.cn/upload/20170601/cdef7a64440c499a865249fcbc91e38e.jpg" alt></p><p>8 Powermock</p><p>PowerMock是用于对源代码进行单元测试的Java框架，它可以作为其他模拟框架的扩展，比如原型Mockito或EasyMock，但具有更强大的功能。PowerMock利用自定义的类加载器和字节码操纵器来实现静态方法，构造函数，最终类和方法以及私有方法等的模拟。它主要是为了扩展现有的API，使用少量的方法和注解来实现额外的功能。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/0530cb31c3b2" target="_blank" rel="noopener">https://www.jianshu.com/p/0530cb31c3b2</a><br><a href="https://blog.csdn.net/Dream_Weave/article/details/83859750" target="_blank" rel="noopener">https://blog.csdn.net/Dream_Weave/article/details/83859750</a><br><a href="https://blog.csdn.net/qq_26295547/article/details/83145642" target="_blank" rel="noopener">https://blog.csdn.net/qq_26295547/article/details/83145642</a><br><a href="https://www.jianshu.com/p/0530cb31c3b2" target="_blank" rel="noopener">https://www.jianshu.com/p/0530cb31c3b2</a><br><a href="http://www.sohu.com/a/145107423_731023" target="_blank" rel="noopener">http://www.sohu.com/a/145107423_731023</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="JUnit" scheme="http://yoursite.com/tags/JUnit/"/>
    
      <category term="单元测试" scheme="http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界10：从JavaBean讲到Spring</title>
    <link href="http://yoursite.com/2019/10/22/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C10%EF%BC%9A%E4%BB%8EJavaBean%E8%AE%B2%E5%88%B0Spring/"/>
    <id>http://yoursite.com/2019/10/22/走进JavaWeb技术世界/走进JavaWeb技术世界10：从JavaBean讲到Spring/</id>
    <published>2019-10-22T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.005Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><h2 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a><strong>Java Bean</strong></h2><p>Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。</p><p>举个例子，假如有人要用Java实现一个单向链表类，可能会这样写：</p><p><img src="https://upload-images.jianshu.io/upload_images/9915352-8a35b591c3c78ed3.png" alt></p><p>上述实现为了能够快速获取链表的大小，把链表大小缓存在size变量中。用法如下：</p><p>JavaIntList myList = new JavaIntList( );</p><p>System.out.println(myList.size);</p><p>要节省内存，不要缓存size变量了，把代码改成这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/9915352-55f1e5d91f50eb68.png" alt></p><p>发现找不到什么size变量。如果要找到size变量，你就必须保持向后兼容性。所以Java标准库中，绝对不会出现public int size这样的代码，而一定会一开始就写成：</p><p>private int size;</p><p>public int getSize( ){return size;}</p><p>让用户一开始就使用getSize，以便有朝一日修改getSize实现时，不破坏向后兼容性。这种public int getSize() { return size; }的惯用手法，就是Java Bean。</p><h2 id="JSP-Java-Bean"><a href="#JSP-Java-Bean" class="headerlink" title="JSP + Java Bean"></a><strong>JSP + Java Bean</strong></h2><p>在jsp上，  可以用java bean 来封装业务逻辑，保存数据到数据库， 像这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/9915352-8793c939542d7910.png" alt></p><p>其中jsp 直接用来接受用户的请求， 然后通过java bean 来处理业务， 具体的使用方法是：</p><p>这就能把HTTP request中的所有参数都设置到 user 这个java bean 对应的属性上去。 </p><p>只要保证 http request中的参数名和 java bean 中的属性名是一样的。 </p><p>这个叫做JSP Model 1 的模型受到了很多Java程序员的欢迎 ,  因为他们的应用规模都很小， 用Model 1 使得开发很快速，实际上， 这种方式和微软的asp , 以及和开源的php 几乎一样。 </p><p>但在项目中频繁使用了Model 1 导致整个系统的崩溃，因为系统中有好几千个jsp， 这些jsp互相调用(通过GET/POST), 到了最后调用关系无人能搞懂。 </p><p>为了解决这个问题，又推出了 ：JSP Model 2 ,    这是个模型真正的体现了Model-View-Controller的思想：</p><p><img src="https://upload-images.jianshu.io/upload_images/9915352-b5fe81e22fca9339.png" alt></p><p>Servlet 充当Controller ,  jsp 充当 View ，Java bean 当然就是Model 了！</p><p>业务逻辑， 页面显示， 和处理过程做了很好的分离。 </p><p>基于这个模型的扩展和改进，  很多Web开发框架开始如雨后春笋一样出现， 其中最著名的就是 SpringMVC了。</p><h2 id="Enterprise-Java-bean"><a href="#Enterprise-Java-bean" class="headerlink" title="Enterprise Java bean"></a>Enterprise Java bean</h2><p>越来越多企业程序员提出诉求：要分布式、要安全、要事务、要高可用性。</p><p>诉求可以归结为：“我们只想关注我们的业务逻辑， 我们不想， 也不应该由我们来处理‘低级’的事务， 多线程，连接池，以及其他各种各种的‘低级’API， 此外Java帝国一定得提供集群功能， 这样我们的一台机器死机以后，整个系统还能运转。 ”</p><p>于是推出了J2EE， 像Java bean 一样， 这还是一个规范， 但是比Java bean 复杂的多， 其中有：</p><p><strong>JDBC</strong>:  Java 数据库连接</p><p><strong>JNDI</strong> :  Java 命名和目录接口， 通过一个名称就可以定位到一个数据源， 连jdbc连接都不用了</p><p><strong>RMI</strong>：  远程过程调用，  让一个机器上的java 对象可以调用另外一个机器上的java 对象 </p><p><strong>JMS</strong> :   Java 消息服务，  可以使用消息队列了</p><p><strong>JTA</strong>：  Java 事务管理， 支持分布式事务， 能在访问、更新多个数据库的时候，仍然保证事务， 还是分布式。</p><p><strong>Java mail</strong> : 收发邮件</p><p>J2EE 后来改成了Java EE。</p><p>当然最重要的是， java bean 变成了 <strong>Enterprise Java bean *<em>, 简称 *</em>EJB</strong>。</p><p>使用了EJB， 你就可以把精力只放在业务上了， 那些烦人的事务管理， 安全管理，线程 统统交给容器（应用服务器）来处理吧。 </p><p>我们还提供了额外的福利， 只要你的应用服务器是由多个机器组成的集群， EJB就可以无缝的运行在这个集群上， 你完全不用考虑一个机器死掉了应用该怎么办。我们都帮你搞定了。 </p><p>使用Session Bean ， 可以轻松的处理你的业务。</p><p>使用实体Bean (Entity bean ) , 你和数据库打交道会变得极为轻松， 甚至sql 都不用写了。</p><p>使用消息驱动Bean(Message Driven bean ) , 你可以轻松的和一个消息队列连接， 处理消息。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>然而，大部分的程序员就发现，  EJB中用起来极为繁琐和笨重， 性能也不好， 为了获得所谓的分布式，反而背上了沉重的枷锁。 </p><p>实体Bean很快没人用了， 就连简单的无状态Session bean 也被大家所诟病， 其中一条罪状就是“代码的侵入性”。</p><p>在定义EJB的时候没考虑那么多，程序员在定义一个Session bean的时候，需要写一大堆和业务完全没有关系的类。 </p><p>还需要被迫实现一些根本不应该实现的接口及其方法： </p><p><img src="https://upload-images.jianshu.io/upload_images/9915352-535d649b27315b2a.png" alt></p><p>他们希望这个样子：</p><p>public class HelloworldBean{</p><pre><code>public String hello(){    return &quot;hello world&quot;</code></pre><p>   }</p><p>}</p><p>与此同时，他们还过分的要求保留事务、 安全这些必备的东西。 </p><p>Spring 框架顺应了POJO的潮流， 提供了一个spring 的容器来管理这些POJO, 也叫bean 。</p><p>对于一个Bean 来说，如果你依赖别的Bean , 只需要声明即可， spring 容器负责把依赖的bean 给“注入进去“， 起初大家称之为控制反转(IoC)。</p><p>后来 Martin flower 给这种方式起来个更好的名字，叫“依赖注入”（DI）。</p><p>如果一个Bean 需要一些像事务，日志，安全这样的通用的服务， 也是只需要声明即可， spring 容器在运行时能够动态的“织入”这些服务， 这叫面向切面（AOP）。 </p><p>总之，spring和spring mvc极大的增加了Java对web开发领地的统治力。</p><h2 id="JavaBean-和-Spring中Bean的区别"><a href="#JavaBean-和-Spring中Bean的区别" class="headerlink" title="JavaBean 和 Spring中Bean的区别"></a>JavaBean 和 Spring中Bean的区别</h2><p>先了解一下各自是什么吧!</p><h3 id="Jave-bean"><a href="#Jave-bean" class="headerlink" title="Jave bean"></a>Jave bean</h3><p>javaBean简单的讲就是实体类，用来封装对象，这个类里面全部都是属性值，和get，set方法。简单笼统的说就是一个类，一个可复用的类。javaBean在MVC设计模型中是model，又称模型层，在一般的程序中，我们称它为数据层，就是用来设置数据的属性和一些行为，然后我会提供获取属性和设置属性的get/set方法JavaBean是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。</p><h3 id="spring-bean"><a href="#spring-bean" class="headerlink" title="spring bean"></a>spring bean</h3><p>对于使用Spring框架的开发人员来说，我们主要做的主要有两件事情：①开发Bean;②配置Bean;而Spring帮我们做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法来完成“依赖注入”，可以把Spring容器理解成一个大型工厂，Bean就是该工厂的产品，工厂(Spirng容器)里能生产出来什么样的产品（Bean），完全取决于我们在配置文件中的配置。其实就是根据配置文件产生对象,而不需要人为的手动去创造对象,降低了耦合.</p><p>用处不同：传统javabean更多地作为值传递参数，而spring中的bean用处几乎无处不在，任何组件都可以被称为bean。</p><p>写法不同：传统javabean作为值对象，要求每个属性都提供getter和setter方法；但spring中的bean只需为接受设值注入的属性提供setter方法。</p><p>javabean的写法:</p><pre><code>public class A{private String a;private void setA(String a){this.a = a;}private String getA(){return a;}}spring bean的写法&lt;bean id=&quot;p1&quot; class=&quot;com.zking.Pojo.Person&quot; scope=&quot;prototype&quot;&gt;//及时加载 加载你的xml配置文件ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;);//getbean输入你配置类的别名得到 person对象 Person p = (Person) applicationContext.getBean(&quot;p1&quot;);</code></pre><p>id是给这个对象定的别名 class是这个实体类的全路径名 根据配置文件来创建Bean实例，并调用Bean实例的方法 bean里面还有很多属性</p><p>生命周期不同：传统javabean作为值对象传递，不接受任何容器管理其生命周期；spring中的bean有spring管理其生命周期行为。</p><p>所有可以被spring容器实例化并管理的java类都可以称为bean。</p><p>原来服务器处理页面返回的值都是直接使用request对象，后来增加了javabean来管理对象，所有页面值只要是和javabean对应，就可以用类.GET属性方法来获取值。javabean不只可以传参数，也可以处理数据，相当与把一个服务器执行的类放到了页面上，使对象管理相对不那么乱（对比asp的时候所有内容都在页面上完成）。</p><p>spring中的bean，是通过配置文件、javaconfig等的设置，有spring自动实例化，用完后自动销毁的对象。让我们只需要在用的时候使用对象就可以，不用考虑如果创建类对象（这就是spring的注入）。一般是用在服务器端代码的执行上。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>微信公众号【码农翻身】<br><a href="https://blog.csdn.net/hmh13548571896/article/details/100628104" target="_blank" rel="noopener">https://blog.csdn.net/hmh13548571896/article/details/100628104</a><br><a href="https://www.cnblogs.com/xll1025/p/11366413.html" target="_blank" rel="noopener">https://www.cnblogs.com/xll1025/p/11366413.html</a><br><a href="https://blog.csdn.net/qqqnzhky/article/details/82747333" target="_blank" rel="noopener">https://blog.csdn.net/qqqnzhky/article/details/82747333</a><br><a href="https://www.cnblogs.com/mike-mei/p/9712836.html" target="_blank" rel="noopener">https://www.cnblogs.com/mike-mei/p/9712836.html</a><br><a href="https://blog.csdn.net/qq_42245219/article/details/82748460" target="_blank" rel="noopener">https://blog.csdn.net/qq_42245219/article/details/82748460</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界9：Java日志系统的诞生与发展</title>
    <link href="http://yoursite.com/2019/10/21/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C9%EF%BC%9AJava%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E5%8F%91%E5%B1%95/"/>
    <id>http://yoursite.com/2019/10/21/走进JavaWeb技术世界/走进JavaWeb技术世界9：Java日志系统的诞生与发展/</id>
    <published>2019-10-21T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.015Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><h2 id="Java日志系统的演变史"><a href="#Java日志系统的演变史" class="headerlink" title="Java日志系统的演变史"></a>Java日志系统的演变史</h2><p>我们先看一个故事。项目经理A带着一帮兄弟开发了一套复杂的企业ERP系统，这个系统一连开发了好几年，开发人员也换了好几拨。</p><h3 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h3><p>最开始的时候，项目经理A安排小B在系统中添加日志功能，在控制台上打印一些必要的信息。最开始的时候，由于项目的功能比较少，于是小B就是用System.out.println的方式打印日志信息。经理A感觉这样使用比较方便，也便于项目小组人员的使用，于是就沿用了下来。</p><h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><p>此时小B被借调到其他项目，小C加入到了项目组中。此时项目经理A要求改造日志系统，要求能把日志写到一个文件中，方便以后分析用户行为。小C在查看了以前的日志方式之后，感觉特别low，于是自己写了一个日志框架，命名为xiaoC-logging.jar，此举收到了项目经理A的好评。</p><p><img src="https://upload-images.jianshu.io/upload_images/11968147-7072fc51b9dfc62d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/472/format/webp" alt></p><h3 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h3><p>项目组中加入了一个大牛老D，老D发现xiaoC-logging.jar这个日志框架虽然可以满足基本的日志要求，但是还不够高大上，没有一些诸如自动归档，异步写入文件，把日志文件写入NoSQL数据库中等功能。于是老D开发了一个更高级的日志框架叫oldD-logging.jar。</p><h3 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h3><p>oldD-logging.jar开发完成之后，需要把原来的xiaoC-logging.jar中的日志API做修改，把之前的日志实现写下来，换上高大上的oldD-logging.jar。</p><h3 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h3><p>在这个卸载与上新的过程中，老D的工作量陡增，他感觉很累。不过姜还是老的辣，他参考了JDBC和spring中面向接口的编程方式，制定了一个日志的门面（一系列的接口），以后所有的日志的记录，都只面向接口编程，至于今后怎么去实现，都要遵循这个接口就可以了。 </p><p>那么在JAVA开发中，这正的日志系统是怎么演变的呢？简短地描述下日志发展，最先出现的是apache开源社区的log4j，这个日志确实是应用最广泛的日志工具，成为了java日志的事实上的标准。然而，当时Sun公司在jdk1.4中增加了JUL日志实现，企图对抗log4j，但是却造成了混乱，这个也是被人诟病的一点。当然也有其他日志工具的出现，这样必然造成开发者的混乱，因为这些日志系统互相没有关联，替换和统一也就变成了比较棘手的一件事。想象下你的应用使用log4j，然后使用了一个其他团队的库，他们使用了JUL，你的应用就得使用两个日志系统了，然后又有第二个库出现了，使用了simplelog。</p><p><img src="https://upload-images.jianshu.io/upload_images/11968147-b042d013f85e993f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/441/format/webp" alt></p><p>这个时候估计让你崩溃了，这是要闹哪样？这个状况交给你来想想办法，你该如何解决呢？进行抽象，抽象出一个接口层，对每个日志实现都适配或者转接，这样这些提供给别人的库都直接使用抽象层即可。不错，开源社区提供了commons-logging抽象，被称为JCL，也就是日志框架了，确实出色地完成了兼容主流的日志实现（log4j、JUL、simplelog），基本一统江湖，就连顶顶大名的spring也是依赖了JCL。</p><p>看起来事物确实是美好，但是美好的日子不长，接下来另一个优秀的日志框架slf4j的加入导致了更加混乱的场面。比较巧的是slf4j的作者(Ceki Gülcü)就是log4j的作者，他觉得JCL不够优秀，所以他要自己搞一套更优雅的出来，于是slf4j日志体系诞生了，并为slf4j实现了一个亲子——logback，确实更加优雅，但是由于之前很多代码库已经使用JCL，虽然出现slf4j和JCL之间的桥接转换，但是集成的时候问题依然多多，对很多新手来说确实会很懊恼，因为比单独的log4j时代“复杂”多了，抱怨声确实很多。</p><p>到此本来应该完了，但是Ceki Gülcü觉得还是得回头拯救下自己的“大阿哥”——log4j，于是log4j2诞生了，同样log4j2也参与到了slf4j日志体系中，想必将来会更加混乱。接下来详细解读日志系统的配合使用问题。slf4j的设计确实比较优雅，采用比较熟悉的方式——接口和实现分离，有个纯粹的接口层——slf4j-api工程，这个里边基本完全定义了日志的接口，所以对于开发来说，只需要使用这个即可。</p><p>有接口就要有实现，比较推崇的实现是logback，logback完全实现了slf4j-api的接口，并且性能也比log4j更好，同时实现了变参占位符日志输出方式等等新特性。刚刚也提到log4j的使用比较普遍，所以支持这批用户依然是必须的，slf4j-log4j12也实现了slf4j-api，这个算是对log4j的适配器。同样推理，也会有对JUL的适配器slf4j-jdk14等等。为了使使用JCL等等其他日志系统后者实现的用户可以很简单地切换到slf4j上来，给出了各种桥接工程，比如：jcl-over-slf4j会把对JCL的调用都桥接到slf4j上来，可以看出jcl-over-slf4j的api和JCL是相同的，所以这两个jar是不能共存的。jul-to-slf4j是把对jul的调用桥接到slf4j上，log4j-over-slf4j是把对log4j的调用桥接到slf4j。</p><h2 id="一、日志框架的分类"><a href="#一、日志框架的分类" class="headerlink" title="一、日志框架的分类"></a>一、日志框架的分类</h2><ul><li>门面型日志框架：</li></ul><ol><li>JCL：　　Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging</li><li>SLF4J：  是一套简易Java日志门面，<strong>本身并无日志的实现</strong>。（Simple Logging Facade for Java，缩写Slf4j）</li></ol><ul><li>记录型日志框架:</li></ul><ol><li>JUL：　　JDK中的日志记录工具，也常称为JDKLog、jdk-logging，自Java1.4以来的官方日志实现。</li><li>Log4j：　 一个具体的日志实现框架。</li><li>Log4j2：   一个具体的日志实现框架，是LOG4J1的下一个版本，与Log4j 1发生了很大的变化，Log4j 2不兼容Log4j 1。</li><li>Logback：一个具体的日志实现框架，和Slf4j是同一个作者，但其性能更好。</li></ol><p>　　　　　　　　　　　　　　<img src="https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801222005588-1535811596.png" alt></p><h2 id="二、发展历程"><a href="#二、发展历程" class="headerlink" title="二、发展历程"></a>二、发展历程</h2><p>要搞清楚它们的关系，就要从它们是在什么情况下产生的说起。我们按照时间的先后顺序来介绍。</p><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>在JDK 1.3及以前，Java打日志依赖System.out.println(), System.err.println()或者e.printStackTrace()，Debug日志被写到STDOUT流，错误日志被写到STDERR流。这样打日志有一个非常大的缺陷，即无法定制化，且日志粒度不够细。<br>于是， Gülcü 于2001年发布了Log4j，后来成为Apache 基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，它定义的Logger、Appender、Level等概念如今已经被广泛使用。Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。</p><h3 id="J-U-L"><a href="#J-U-L" class="headerlink" title="J.U.L"></a>J.U.L</h3><p>受Logj启发，Sun在Java1.4版本中引入了java.util.logging，但是j.u.l功能远不如log4j完善，开发者需要自己编写Appenders（Sun称之为Handlers），且只有两个Handlers可用（Console和File），j.u.l在Java1.5以后性能和可用性才有所提升。</p><h3 id="JCL（commons-logging）"><a href="#JCL（commons-logging）" class="headerlink" title="JCL（commons-logging）"></a>JCL（commons-logging）</h3><p>由于项目的日志打印必然选择两个框架中至少一个，这时候，Apache的JCL（commons-logging）诞生了。JCL 是一个Log Facade，只提供 Log API，不提供实现，然后有 Adapter 来使用 Log4j 或者 JUL 作为Log Implementation。<br>在程序中日志创建和记录都是用JCL中的接口，在真正运行时，会看当前ClassPath中有什么实现，如果有Log4j 就是用 Log4j, 如果啥都没有就是用 JDK 的 JUL。<br>这样，在你的项目中，还有第三方的项目中，大家记录日志都使用 JCL 的接口，然后最终运行程序时，可以按照自己的需求(或者喜好)来选择使用合适的Log Implementation。如果用Log4j, 就添加 Log4j 的jar包进去，然后写一个 Log4j 的配置文件；如果喜欢用JUL，就只需要写个 JUL 的配置文件。如果有其他的新的日志库出现，也只需要它提供一个Adapter，运行的时候把这个日志库的 jar 包加进去。<br>不过，commons-logging对Log4j和j.u.l的配置问题兼容的并不好，使用commons-loggings还可能会遇到类加载问题，导致NoClassDefFoundError的错误出现。</p><p>　　　　　　　　　　　　　　　　　　　　　　　　<img src="https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801215840541-1005764017.png" alt></p><p>到这个时候一切看起来都很简单，很美好。接口和实现做了良好的分离，在统一的JCL之下，不改变任何代码，就可以通过配置就换用功能更强大，或者性能更好的日志库实现。</p><p>这种简单美好一直持续到SLF4J出现。</p><h3 id="SLF4J-amp-Logback"><a href="#SLF4J-amp-Logback" class="headerlink" title="SLF4J &amp; Logback"></a>SLF4J &amp; Logback</h3><p>SLF4J（Simple Logging Facade for Java）和 Logback 也是Gülcü 创立的项目，目的是为了提供更高性能的实现。<br>从设计模式的角度说，SLF4J 是用来在log和代码层之间起到门面作用，类似于 JCL 的 Log Facade。对于用户来说只要使用SLF4J提供的接口，即可隐藏日志的具体实现，SLF4J提供的核心API是一些接口和一个LoggerFactory的工厂类，用户只需按照它提供的统一纪录日志接口，最终日志的格式、纪录级别、输出方式等可通过具体日志系统的配置来实现，因此可以灵活的切换日志系统。</p><p>Logback是log4j的升级版，当前分为三个目标模块：</p><ul><li>logback-core：核心模块，是其它两个模块的基础模块</li><li>logback-classic：是log4j的一个改良版本，同时完整实现 SLF4J API 使你可以很方便地更换成其它日记系统如log4j 或 JDK14 Logging</li><li>logback-access：访问模块与Servlet容器集成提供通过Http来访问日记的功能，是logback不可或缺的组成部分</li></ul><p>Logback相较于log4j有更多的优点：</p><ul><li>更快的执行速度</li><li>更充分的测试</li><li>logback-classic 非常自然的实现了SLF4J</li><li>使用XML配置文件或者Groovy</li><li>自动重新载入配置文件</li><li>优雅地从I/O错误中恢复</li><li>自动清除旧的日志归档文件</li><li>自动压缩归档日志文件</li><li>谨慎模式</li><li>Lilith</li><li>配置文件中的条件处理</li><li>更丰富的过滤</li></ul><p>更详细的解释参见官网：<a href="https://link.jianshu.com/?t=https%3A%2F%2Flogback.qos.ch%2FreasonsToSwitch.html" target="_blank" rel="noopener">https://logback.qos.ch/reasonsToSwitch.html</a></p><p>到这里，你可能会问：Apache 已经有了个JCL，用来做各种Log lib统一的接口，如果 Gülcü 要搞一个更好的 Log 实现的话，直接写一个实现就好了，为啥还要搞一个和SLF4J呢?</p><p>原因是Gülcü 认为 JCL 的 API 设计得不好，容易让使用者写出性能有问题的代码。关于这点，你可以参考这篇文章获得更详细的介绍：<a href="https://link.jianshu.com/?t=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F24272450" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24272450</a></p><p>现在事情就变复杂了。我们有了两个流行的 Log Facade，以及三个流行的 Log Implementation。Gülcü 是个追求完美的人，他决定让这些Log之间都能够方便的互相替换，所以做了各种 Adapter 和 Bridge 来连接:</p><p>　　　　　　　　　　　　　　<img src="https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801220018444-1557580371.png" alt></p><p>可以看到甚至 Log4j 和 JUL 都可以桥接到SLF4J，再通过 SLF4J 适配到到 Logback！需要注意的是不能有循环的桥接，比如下面这些依赖就不能同时存在:</p><ul><li>jcl-over-slf4j 和 slf4j-jcl</li><li>log4j-over-slf4j 和 slf4j-log4j12</li><li>jul-to-slf4j 和 slf4j-jdk14</li></ul><p>然而，事情在变得更麻烦！</p><p>Log4j2</p><p>现在有了更好的 SLF4J 和 Logback，慢慢取代JCL 和 Log4j ，事情到这里总该大统一圆满结束了吧。然而维护 Log4j 的人不这样想，他们不想坐视用户一点点被 SLF4J / Logback 蚕食，继而搞出了 Log4j2。</p><p>Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。</p><p>现在好了，我们有了三个流行的Log 接口和四个流行的Log实现，如果画出桥接关系的图来回事什么样子呢?</p><p>　　　　　　　　　　　　<img src="https://img2018.cnblogs.com/blog/1577453/201908/1577453-20190801220108556-715466336.png" alt><br>看到这里是不是感觉有点晕呢？是的，我也有这种感觉。同样，在添加依赖的时候，要小心不要有循环依赖。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000009707894" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009707894</a></p><p><a href="https://www.cnblogs.com/hysum/p/7100874.html" target="_blank" rel="noopener">https://www.cnblogs.com/hysum/p/7100874.html</a></p><p><a href="http://c.biancheng.net/view/939.html" target="_blank" rel="noopener">http://c.biancheng.net/view/939.html</a></p><p><a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p><p><a href="https://blog.csdn.net/android_hl/article/details/53228348" target="_blank" rel="noopener">https://blog.csdn.net/android_hl/article/details/53228348</a></p><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个JavaWeb技术体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>走进JavaWeb技术世界8：浅析Tomcat9请求处理流程与启动部署过程</title>
    <link href="http://yoursite.com/2019/10/20/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C/%E8%B5%B0%E8%BF%9BJavaWeb%E6%8A%80%E6%9C%AF%E4%B8%96%E7%95%8C8%EF%BC%9A%E6%B5%85%E6%9E%90Tomcat9%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%90%AF%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/20/走进JavaWeb技术世界/走进JavaWeb技术世界8：浅析Tomcat9请求处理流程与启动部署过程/</id>
    <published>2019-10-20T07:56:26.000Z</published>
    <updated>2021-11-24T08:03:24.014Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看</p><blockquote><p><a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p></blockquote><p>喜欢的话麻烦点下Star哈</p><p>文章首发于我的个人博客：</p><blockquote><p><a href="http://www.how2playlife.com" target="_blank" rel="noopener">www.how2playlife.com</a></p></blockquote><p>本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。</p><p>该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个Java Web技术体系，形成自己的知识框架。</p><p>为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p><p>如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。</p><p><strong>文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）</strong></p><a id="more"></a><p>很多东西在时序图中体现的已经非常清楚了，没有必要再一步一步的作介绍，所以本文以图为主，然后对部分内容加以简单解释。</p><p>绘制图形使用的工具是 PlantUML + Visual Studio Code + PlantUML Extension</p><p>本文对 Tomcat 的介绍以 Tomcat-9.0.0.M22 为标准。</p><p>Tomcat-9.0.0.M22 是 Tomcat 目前最新的版本，但尚未发布，它实现了 Servlet4.0 及 JSP2.3 并提供了很多新特性，需要 1.8 及以上的 JDK 支持等等，详情请查阅 Tomcat-9.0-doc。</p><blockquote><p><a href="https://tomcat.apache.org/tomcat-9.0-doc/index.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-9.0-doc/index.html</a></p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="https://img-blog.csdnimg.cn/20190808094540456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsYmVuWGll,size_16,color_FFFFFF,t_70" alt></p><p>Connector 启动以后会启动一组线程用于不同阶段的请求处理过程。</p><ol><li><p>Acceptor 线程组。用于接受新连接，并将新连接封装一下，选择一个 Poller 将新连接添加到 Poller 的事件队列中。</p></li><li><p>Poller 线程组。用于监听 Socket 事件，当 Socket 可读或可写等等时，将 Socket 封装一下添加到 worker 线程池的任务队列中。</p></li><li><p>worker 线程组。用于对请求进行处理，包括分析请求报文并创建 Request 对象，调用容器的 pipeline 进行处理。</p></li></ol><p>Acceptor、Poller、worker 所在的 ThreadPoolExecutor 都维护在 NioEndpoint 中。</p><h2 id="Connector-Init-and-Start"><a href="#Connector-Init-and-Start" class="headerlink" title="Connector Init and Start"></a>Connector Init and Start</h2><p><img src="https://img-blog.csdnimg.cn/20190808094650927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsYmVuWGll,size_16,color_FFFFFF,t_70" alt></p><ol><li><p>initServerSocket()，通过 ServerSocketChannel.open() 打开一个 ServerSocket，默认绑定到 8080 端口，默认的连接等待队列长度是 100， 当超过 100 个时会拒绝服务。我们可以通过配置 conf/server.xml 中 Connector 的 acceptCount 属性对其进行定制。</p></li><li><p>createExecutor() 用于创建 Worker 线程池。默认会启动 10 个 Worker 线程，Tomcat 处理请求过程中，Woker 最多不超过 200 个。我们可以通过配置 conf/server.xml 中 Connector 的 minSpareThreads 和 maxThreads 对这两个属性进行定制。</p></li><li><p>Pollor 用于检测已就绪的 Socket。默认最多不超过 2 个，Math.min(2,Runtime.getRuntime().availableProcessors());。我们可以通过配置 pollerThreadCount 来定制。</p></li><li><p>Acceptor 用于接受新连接。默认是 1 个。我们可以通过配置 acceptorThreadCount 对其进行定制。</p></li></ol><h2 id="Request-Process"><a href="#Request-Process" class="headerlink" title="Request Process"></a>Request Process</h2><h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><p><img src="https://img-blog.csdnimg.cn/20190808094725483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsYmVuWGll,size_16,color_FFFFFF,t_70" alt></p><ol><li><p>Acceptor 在启动后会阻塞在 ServerSocketChannel.accept(); 方法处，当有新连接到达时，该方法返回一个 SocketChannel。</p></li><li><p>配置完 Socket 以后将 Socket 封装到 NioChannel 中，并注册到 Poller,值的一提的是，我们一开始就启动了多个 Poller 线程，注册的时候，连接是公平的分配到每个 Poller 的。NioEndpoint 维护了一个 Poller 数组，当一个连接分配给 pollers[index] 时，下一个连接就会分配给 pollers[(index+1)%pollers.length].</p></li><li><p>addEvent() 方法会将 Socket 添加到该 Poller 的 PollerEvent 队列中。到此 Acceptor 的任务就完成了。</p></li></ol><h3 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h3><p><img src="https://img-blog.csdnimg.cn/20190808094749113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsYmVuWGll,size_16,color_FFFFFF,t_70" alt></p><ol><li><p>selector.select(1000)。当 Poller 启动后因为 selector 中并没有已注册的 Channel，所以当执行到该方法时只能阻塞。所有的 Poller 共用一个 Selector，其实现类是 sun.nio.ch.EPollSelectorImpl</p></li><li><p>events() 方法会将通过 addEvent() 方法添加到事件队列中的 Socket 注册到 EPollSelectorImpl，当 Socket 可读时，Poller 才对其进行处理</p></li><li><p>createSocketProcessor() 方法将 Socket 封装到 SocketProcessor 中，SocketProcessor 实现了 Runnable 接口。worker 线程通过调用其 run() 方法来对 Socket 进行处理。</p></li><li><p>execute(SocketProcessor) 方法将 SocketProcessor 提交到线程池，放入线程池的 workQueue 中。workQueue 是 BlockingQueue 的实例。到此 Poller 的任务就完成了。</p></li></ol><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p><img src="https://img-blog.csdnimg.cn/20190808094814420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsYmVuWGll,size_16,color_FFFFFF,t_70" alt></p><ul><li><p>worker 线程被创建以后就执行 ThreadPoolExecutor 的 runWorker() 方法，试图从 workQueue 中取待处理任务，但是一开始 workQueue 是空的，所以 worker 线程会阻塞在 workQueue.take() 方法。</p></li><li><p>当新任务添加到 workQueue后，workQueue.take() 方法会返回一个 Runnable，通常是 SocketProcessor,然后 worker 线程调用 SocketProcessor 的 run() 方法对 Socket 进行处理。</p></li><li><p>createProcessor() 会创建一个 Http11Processor, 它用来解析 Socket，将 Socket 中的内容封装到 Request 中。注意这个 Request 是临时使用的一个类，它的全类名是 org.apache.coyote.Request，</p></li><li><p>postParseRequest() 方法封装一下 Request，并处理一下映射关系(从 URL 映射到相应的 Host、Context、Wrapper)。</p></li></ul><ol><li><p>CoyoteAdapter 将 Rquest 提交给 Container 处理之前，并将 org.apache.coyote.Request 封装到 org.apache.catalina.connector.Request，传递给 Container 处理的 Request 是 org.apache.catalina.connector.Request。</p></li><li><p>connector.getService().getMapper().map()，用来在 Mapper 中查询 URL 的映射关系。映射关系会保留到 org.apache.catalina.connector.Request 中，Container 处理阶段 request.getHost() 是使用的就是这个阶段查询到的映射主机，以此类推 request.getContext()、request.getWrapper() 都是。</p></li></ol><ul><li>connector.getService().getContainer().getPipeline().getFirst().invoke() 会将请求传递到 Container 处理，当然了 Container 处理也是在 Worker 线程中执行的，但是这是一个相对独立的模块，所以单独分出来一节。</li></ul><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="https://img-blog.csdnimg.cn/20190808094835789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsYmVuWGll,size_16,color_FFFFFF,t_70" alt></p><ul><li><p>需要注意的是，基本上每一个容器的 StandardPipeline 上都会有多个已注册的 Valve，我们只关注每个容器的 Basic Valve。其他 Valve 都是在 Basic Valve 前执行。</p></li><li><p>request.getHost().getPipeline().getFirst().invoke() 先获取对应的 StandardHost，并执行其 pipeline。</p></li><li><p>request.getContext().getPipeline().getFirst().invoke() 先获取对应的 StandardContext,并执行其 pipeline。</p></li><li><p>request.getWrapper().getPipeline().getFirst().invoke() 先获取对应的 StandardWrapper，并执行其 pipeline。</p></li><li><p>最值得说的就是 StandardWrapper 的 Basic Valve，StandardWrapperValve</p></li></ul><ol><li><p>allocate() 用来加载并初始化 Servlet，值的一提的是 Servlet 并不都是单例的，当 Servlet 实现了 SingleThreadModel 接口后，StandardWrapper 会维护一组 Servlet 实例，这是享元模式。当然了 SingleThreadModel在 Servlet 2.4 以后就弃用了。</p></li><li><p>createFilterChain() 方法会从 StandardContext 中获取到所有的过滤器，然后将匹配 Request URL 的所有过滤器挑选出来添加到 filterChain 中。</p></li><li><p>doFilter() 执行过滤链,当所有的过滤器都执行完毕后调用 Servlet 的 service() 方法。</p></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><p>《How Tomcat works》</p><p><a href="https://www.amazon.com/How-Tomcat-Works-Budi-Kurniawan/dp/097521280X" target="_blank" rel="noopener">https://www.amazon.com/How-Tomcat-Works-Budi-Kurniawan/dp/097521280X</a></p></li><li><p>《Tomcat 架构解析》– 刘光瑞</p><p><a href="http://product.dangdang.com/25084132.html" target="_blank" rel="noopener">http://product.dangdang.com/25084132.html</a></p></li><li><p>Tomcat-9.0-doc</p><p><a href="https://tomcat.apache.org/tomcat-9.0-doc/index.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-9.0-doc/index.html</a></p></li><li><p>apache-tomcat-9.0.0.M22-src</p><p><a href="http://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.0.M22/src/" target="_blank" rel="noopener">http://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.0.M22/src/</a></p></li><li><p>tomcat架构分析 (connector NIO 实现)</p><p><a href="http://gearever.iteye.com/blog/1844203" target="_blank" rel="noopener">http://gearever.iteye.com/blog/1844203</a></p></li></ol><h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="个人公众号：程序员黄小斜"><a href="#个人公众号：程序员黄小斜" class="headerlink" title="个人公众号：程序员黄小斜"></a>个人公众号：程序员黄小斜</h3><p>微信公众号【程序员黄小斜】新生代青年聚集地，程序员成长充电站。作者黄小斜，职业是阿里程序员，身份是斜杠青年，希望和更多的程序员交朋友，一起进步和成长！这一次，我们一起出发。</p><p>关注公众号后回复“2019”领取我这两年整理的学习资料，涵盖自学编程、求职面试、算法刷题、Java技术、计算机基础和考研等8000G资料合集。</p><p><img src="https://img-blog.csdnimg.cn/20190829222750556.jpg" alt></p><h3 id="技术公众号：Java技术江湖"><a href="#技术公众号：Java技术江湖" class="headerlink" title="技术公众号：Java技术江湖"></a>技术公众号：Java技术江湖</h3><p>微信公众号【Java技术江湖】一位阿里 Java 工程师的技术小站，专注于 Java 相关技术：SSM、SpringBoot、MySQL、分布式、中间件、集群、Linux、网络、多线程，偶尔讲点Docker、ELK，同时也分享技术干货和学习经验，致力于Java全栈开发！</p><p>关注公众号后回复“PDF”即可领取200+页的《Java工程师面试指南》强烈推荐，几乎涵盖所有Java工程师必知必会的知识点。</p><p><img src="https://img-blog.csdnimg.cn/20190805090108984.jpg" alt></p><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>    const btw = new BTWPlugin();    btw.init({        id: 'container',        blogId: '15310-1577469423472-640',        name: '程序员黄小斜',        qrcode: 'https://s2.ax1x.com/2019/12/28/le9CwT.jpg',        keyword: '验证码',    });</script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "15310-1577469423472-640",        "name": "黄小斜学Java",        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",        "keyword": "关键词"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章将整理到我在GitHub上的《Java面试指南》仓库，更多精彩内容请到我的仓库里查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h2pl/Java-Tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/h2pl/Java-Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喜欢的话麻烦点下Star哈&lt;/p&gt;
&lt;p&gt;文章首发于我的个人博客：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.how2playlife.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.how2playlife.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是微信公众号【Java技术江湖】的《走进JavaWeb技术世界》其中一篇，本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。&lt;/p&gt;
&lt;p&gt;该系列博文会告诉你如何从入门到进阶，从servlet到框架，从ssm再到SpringBoot，一步步地学习JavaWeb基础知识，并上手进行实战，接着了解JavaWeb项目中经常要使用的技术和组件，包括日志组件、Maven、Junit，等等内容，以便让你更完整地了解整个Java Web技术体系，形成自己的知识框架。&lt;/p&gt;
&lt;p&gt;为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。&lt;/p&gt;
&lt;p&gt;如果对本系列文章有什么建议，或者是有什么疑问的话，也可以关注公众号【Java技术江湖】联系作者，欢迎你参与本系列博文的创作和修订。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文末赠送8000G的Java架构师学习资料，需要的朋友可以到文末了解领取方式，资料包括Java基础、进阶、项目和架构师等免费学习资料，更有数据库、分布式、微服务等热门技术学习视频，内容丰富，兼顾原理和实践，另外也将赠送作者原创的Java学习指南、Java程序员面试指南等干货资源）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java技术江湖" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/"/>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/Java%E6%8A%80%E6%9C%AF%E6%B1%9F%E6%B9%96/JavaWeb/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
</feed>
