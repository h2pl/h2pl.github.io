<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content=",">





  <link rel="alternate" href="/atom.xml" title="程序员黄小斜" type="application/atom+xml">






<meta name="description" content="本文首发于我的个人博客：https://h2pl.github.io/ 更多关于Java并发的文章请参阅我的CSDN专栏：Java并发指南https://blog.csdn.net/column/details/21961.html 相关代码会放在我的的Github：https://github.com/h2pl/ Java并发编程一直是Java程序员必须懂但又是很难懂的技术内容。 这里不仅仅是指">
<meta name="keywords" content="Java并发">
<meta property="og:type" content="website">
<meta property="og:title" content="Java并发指南开篇：Java并发编程学习大纲">
<meta property="og:url" content="http://yoursite.com/wait/concurrent.html">
<meta property="og:site_name" content="程序员黄小斜">
<meta property="og:description" content="本文首发于我的个人博客：https://h2pl.github.io/ 更多关于Java并发的文章请参阅我的CSDN专栏：Java并发指南https://blog.csdn.net/column/details/21961.html 相关代码会放在我的的Github：https://github.com/h2pl/ Java并发编程一直是Java程序员必须懂但又是很难懂的技术内容。 这里不仅仅是指">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/623504-3856f8a1e75a85c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:updated_time" content="2021-11-24T08:03:24.065Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发指南开篇：Java并发编程学习大纲">
<meta name="twitter:description" content="本文首发于我的个人博客：https://h2pl.github.io/ 更多关于Java并发的文章请参阅我的CSDN专栏：Java并发指南https://blog.csdn.net/column/details/21961.html 相关代码会放在我的的Github：https://github.com/h2pl/ Java并发编程一直是Java程序员必须懂但又是很难懂的技术内容。 这里不仅仅是指">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/623504-3856f8a1e75a85c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/wait/concurrent.html">





  <title>Java并发指南开篇：Java并发编程学习大纲 | 程序员黄小斜</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2289335dd443797b5867abbd156e7575";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员黄小斜</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Java技术江湖</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline">Java并发指南开篇：Java并发编程学习大纲</h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <div id="vip-container"><p>本文首发于我的个人博客：<a href="https://h2pl.github.io/" target="_blank" rel="noopener">https://h2pl.github.io/</a></p>
<p>更多关于Java并发的文章请参阅我的CSDN专栏：Java并发指南<br><a href="https://blog.csdn.net/column/details/21961.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/21961.html</a></p>
<p>相关代码会放在我的的Github：<a href="https://github.com/h2pl/" target="_blank" rel="noopener">https://github.com/h2pl/</a></p>
<p>Java并发编程一直是Java程序员必须懂但又是很难懂的技术内容。</p>
<p>这里不仅仅是指使用简单的多线程编程，或者使用juc的某个类。当然这些都是并发编程的基本知识，除了使用这些工具以外，Java并发编程中涉及到的技术原理十分丰富。为了更好地把并发知识形成一个体系，也鉴于本人没有能力写出这类文章，于是参考几位并发编程专家的博客和书籍，做一个简单的整理和复习。</p>
<p>本文只是简要的介绍和总结。详细的内容欢迎来我的专栏阅读，会有更多的系列文章。</p>
<a id="more"></a>

<h2 id="并发基础和多线程"><a href="#并发基础和多线程" class="headerlink" title="并发基础和多线程"></a>并发基础和多线程</h2><p>首先需要学习的就是并发的基础知识，什么是并发，为什么要并发，多线程的概念，线程安全的概念等。</p>
<p>然后学会使用Java中的Thread或是其他线程实现方法，了解线程的状态转换，线程的方法，线程的通信方式等。</p>
<h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><p>任何语言最终都是运行在处理器上，JVM虚拟机为了给开发者一个一致的编程内存模型，需要制定一套规则，这套规则可以在不同架构的机器上有不同实现，并且向上为程序员提供统一的JMM内存模型。</p>
<p>所以了解JMM内存模型也是了解Java并发原理的一个重点，其中了解指令重排，内存屏障，以及可见性原理尤为重要。</p>
<p>JMM只保证happens-before和as-if-serial规则，所以在多线程并发时，可能出现原子性，可见性以及有序性这三大问题。</p>
<p>下面的内容则会讲述Java是如何解决这三大问题的。</p>
<h2 id="synchronized，volatile，final等关键字"><a href="#synchronized，volatile，final等关键字" class="headerlink" title="synchronized，volatile，final等关键字"></a>synchronized，volatile，final等关键字</h2><p>对于并发的三大问题，volatile可以保证原子性和可见性，synchronized三种特性都可以保证（允许指令重排）。</p>
<p>synchronized是基于操作系统的mutex lock指令实现的，volatile和final则是根据JMM实现其内存语义。</p>
<p>此处还要了解CAS操作，它不仅提供了类似volatile的内存语义，并且保证操作原子性，因为它是由硬件实现的。</p>
<p>JUC中的Lock底层就是使用volatile加上CAS的方式实现的。synchronized也会尝试用cas操作来优化器重量级锁。</p>
<p>了解这些关键字是很有必要的。</p>
<h2 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h2><p>在了解完上述内容以后，就可以看看JUC的内容了。</p>
<p>JUC提供了包括Lock，原子操作类，线程池，同步容器，工具类等内容。</p>
<p>这些类的基础都是AQS，所以了解AQS的原理是很重要的。</p>
<p>除此之外，还可以了解一下Fork/Join，以及JUC的常用场景，比如生产者消费者，阻塞队列，以及读写容器等。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>上述这些内容，除了JMM部分的内容比较不好实现之外，像是多线程基本使用，JUC的使用都可以在代码实践中更好地理解其原理。多尝试一些场景，或者在网上找一些比较经典的并发场景，或者参考别人的例子，在实践中加深理解，还是很有必要的。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>由于很多Java新手可能对并发编程没什么概念，在这里放一篇不错的总结，简要地提几个并发编程中比要重要的点，也是比较基本的点吗，算是抛砖引玉，开个好头，在大致了解了这些基础内容以后，才能更好地开展后面详细内容的学习。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623504-3856f8a1e75a85c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt></p>
<h3 id="1-并发编程三要素"><a href="#1-并发编程三要素" class="headerlink" title="1.并发编程三要素"></a>1.并发编程三要素</h3><ul>
<li>原子性<br>原子，即一个不可再被分割的颗粒。在Java中原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</li>
<li>有序性<br>程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</li>
<li>可见性<br>当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。</li>
</ul>
<h3 id="2-线程的五大状态"><a href="#2-线程的五大状态" class="headerlink" title="2. 线程的五大状态"></a>2. 线程的五大状态</h3><ul>
<li>创建状态<br>当用 new 操作符创建一个线程的时候</li>
<li>就绪状态<br>调用 start 方法，处于就绪状态的线程并不一定马上就会执行 run 方法，还需要等待CPU的调度</li>
<li>运行状态<br>CPU 开始调度线程，并开始执行 run 方法</li>
<li>阻塞状态<br>线程的执行过程中由于一些原因进入阻塞状态<br>比如：调用 sleep 方法、尝试去得到一个锁等等​​</li>
<li>死亡状态<br>run 方法执行完 或者 执行过程中遇到了一个异常</li>
</ul>
<h3 id="3-悲观锁与乐观锁"><a href="#3-悲观锁与乐观锁" class="headerlink" title="3.悲观锁与乐观锁"></a>3.悲观锁与乐观锁</h3><ul>
<li>悲观锁：每次操作都会加锁，会造成线程阻塞。</li>
<li>乐观锁：每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。​</li>
</ul>
<h3 id="4-线程之间的协作"><a href="#4-线程之间的协作" class="headerlink" title="4.线程之间的协作"></a>4.线程之间的协作</h3><h4 id="4-1-wait-notify-notifyAll"><a href="#4-1-wait-notify-notifyAll" class="headerlink" title="4.1 wait/notify/notifyAll"></a>4.1 wait/notify/notifyAll</h4><p>这一组是 Object 类的方法<br>需要注意的是：这三个方法都必须在同步的范围内调用​</p>
<ul>
<li><p>wait<br>阻塞当前线程，直到 notify 或者 notifyAll 来唤醒​​​​</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wait有三种方式的调用</span><br><span class="line">wait()</span><br><span class="line">必要要由 notify 或者 notifyAll 来唤醒​​​​</span><br><span class="line">wait(long timeout)</span><br><span class="line">在指定时间内，如果没有notify或notifAll方法的唤醒，也会自动唤醒。</span><br><span class="line">wait(long timeout,long nanos)</span><br><span class="line">本质上还是调用一个参数的方法</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">      if (timeout &lt; 0) &#123;</span><br><span class="line">             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">      if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">              throw new IllegalArgumentException(</span><br><span class="line">             &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (nanos &gt; 0) &#123;</span><br><span class="line">             timeout++;</span><br><span class="line">       &#125;</span><br><span class="line">       wait(timeout);</span><br><span class="line">&#125;</span><br><span class="line">              ​</span><br></pre></td></tr></table></figure>

<ul>
<li>notify<br>只能唤醒一个处于 wait 的线程</li>
<li>notifyAll<br>唤醒全部处于 wait 的线程<br>​</li>
</ul>
</li>
</ul>
<h4 id="4-2-sleep-yield-join"><a href="#4-2-sleep-yield-join" class="headerlink" title="4.2 sleep/yield/join"></a>4.2 sleep/yield/join</h4><p>这一组是 Thread 类的方法</p>
<ul>
<li><p>sleep<br>让当前线程暂停指定时间，只是让出CPU的使用权，并不释放锁</p>
</li>
<li><p>yield<br>暂停当前线程的执行，也就是当前CPU的使用权，让其他线程有机会执行，不能指定时间。会让当前线程从运行状态转变为就绪状态，此方法在生产环境中很少会使用到，​​​官方在其注释中也有相关的说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* A hint to the scheduler that the current thread is willing to yield</span><br><span class="line">* its current use of a processor. The scheduler is free to ignore this</span><br><span class="line">* hint.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class="line">* between threads that would otherwise over-utilise a CPU. Its use</span><br><span class="line">* should be combined with detailed profiling and benchmarking to</span><br><span class="line">* ensure that it actually has the desired effect.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class="line">* for debugging or testing purposes, where it may help to reproduce</span><br><span class="line">* bugs due to race conditions. It may also be useful when designing</span><br><span class="line">* concurrency control constructs such as the ones in the</span><br><span class="line">* &#123;@link java.util.concurrent.locks&#125; package.</span><br><span class="line">*/​​</span><br><span class="line">​​​​</span><br></pre></td></tr></table></figure>
</li>
<li><p>join<br>等待调用 join 方法的线程执行结束，才执行后面的代码<br>其调用一定要在 start 方法之后（看源码可知）​<br>使用场景：当父线程需要等待子线程执行结束才执行后面内容或者需要某个子线程的执行结果会用到 join 方法​</p>
</li>
</ul>
<h3 id="5-valitate-关键字"><a href="#5-valitate-关键字" class="headerlink" title="5.valitate 关键字"></a>5.valitate 关键字</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<blockquote>
<p>valitate是轻量级的synchronized，不会引起线程上下文的切换和调度，执行开销更小。</p>
</blockquote>
<h4 id="5-2-原理"><a href="#5-2-原理" class="headerlink" title="5.2 原理"></a>5.2 原理</h4><p>1. 使用volitate修饰的变量在汇编阶段，会多出一条lock前缀指令<br>2. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成<br>3. 它会强制将对缓存的修改操作立即写入主存<br>4. 如果是写操作，它会导致其他CPU里缓存了该内存地址的数据无效</p>
<h4 id="5-3-作用"><a href="#5-3-作用" class="headerlink" title="5.3 作用"></a>5.3 作用</h4><p>内存可见性<br>多线程操作的时候，一个线程修改了一个变量的值 ，其他线程能立即看到修改后的值<br>防止重排序<br>即程序的执行顺序按照代码的顺序执行（处理器为了提高代码的执行效率可能会对代码进行重排序）</p>
<blockquote>
<p>并不能保证操作的原子性（比如下面这段代码的执行结果一定不是100000）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public class testValitate &#123;</span><br><span class="line"> public volatile int inc = 0;</span><br><span class="line"> public void increase() &#123;</span><br><span class="line">     inc = inc + 1;</span><br><span class="line"> &#125;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">     final testValitate test = new testValitate();</span><br><span class="line">     for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">         new Thread() &#123;</span><br><span class="line">             public void run() &#123;</span><br><span class="line">                 for (int j = 0; j &lt; 1000; j++)</span><br><span class="line">                     test.increase();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;.start();</span><br><span class="line">     &#125;</span><br><span class="line">     while (Thread.activeCount() &gt; 2) &#123;  //保证前面的线程都执行完</span><br><span class="line">         Thread.yield();</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(test.inc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-synchronized-关键字"><a href="#6-synchronized-关键字" class="headerlink" title="6. synchronized 关键字"></a>6. synchronized 关键字</h3><blockquote>
<p>确保线程互斥的访问同步代码</p>
</blockquote>
<h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>synchronized 是JVM实现的一种锁，其中锁的获取和释放分别是<br>monitorenter 和 monitorexit 指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在 java1.6 是默认开启的，轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中</p>
<h4 id="6-2-原理"><a href="#6-2-原理" class="headerlink" title="6.2 原理"></a>6.2 原理</h4><p>加了 synchronized 关键字的代码段，生成的字节码文件会多出 monitorenter 和 monitorexit 两条指令（利用javap -verbose 字节码文件可看到关，关于这两条指令的文档如下：</p>
<ul>
<li><p>monitorenter<br>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:<br>• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.​</p>
</li>
<li><p>monitorexit<br>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.​​</p>
</li>
</ul>
<p>加了 synchronized 关键字的方法，生成的字节码文件中会多一个 ACC_SYNCHRONIZED 标志位，当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
<h4 id="6-3-关于使用"><a href="#6-3-关于使用" class="headerlink" title="6.3 关于使用"></a>6.3 关于使用</h4><ul>
<li>修饰普通方法<br>同步对象是实例对象</li>
<li>修饰静态方法<br>同步对象是类本身</li>
<li>修饰代码块<br>可以自己设置同步对象​</li>
</ul>
<h4 id="6-4-缺点"><a href="#6-4-缺点" class="headerlink" title="6.4 缺点"></a>6.4 缺点</h4><p>会让没有得到锁的资源进入Block状态，争夺到资源之后又转为Running状态，这个过程涉及到操作系统用户模式和内核模式的切换，代价比较高。Java1.6为 synchronized 做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。</p>
<h3 id="7-CAS"><a href="#7-CAS" class="headerlink" title="7. CAS"></a>7. CAS</h3><blockquote>
<p>AtomicBoolean，AtomicInteger，AtomicLong以及 Lock 相关类等底层就是用 CAS实现的，在一定程度上性能比 synchronized 更高。</p>
</blockquote>
<h4 id="7-1-什么是CAS"><a href="#7-1-什么是CAS" class="headerlink" title="7.1 什么是CAS"></a>7.1 什么是CAS</h4><p>CAS全称是Compare And Swap，即比较替换，是实现并发应用到的一种技术。操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p>
<h4 id="7-2-为什么会有CAS"><a href="#7-2-为什么会有CAS" class="headerlink" title="7.2 为什么会有CAS"></a>7.2 为什么会有CAS</h4><p>如果只是用 synchronized 来保证同步会存在以下问题<br>synchronized 是一种悲观锁，在使用上会造成一定的性能问题。在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<h4 id="7-3-实现原理"><a href="#7-3-实现原理" class="headerlink" title="7.3 实现原理"></a>7.3 实现原理</h4><p>Java不能直接的访问操作系统底层，是通过native方法（JNI）来访问。CAS底层通过Unsafe类实现原子性操作。</p>
<h4 id="7-4-存在的问题"><a href="#7-4-存在的问题" class="headerlink" title="7.4 存在的问题"></a>7.4 存在的问题</h4><ul>
<li>ABA问题<br>什么是ABA问题？比如有一个 int 类型的值 N 是 1<br>此时有三个线程想要去改变它：<br>线程A ​​：希望给 N 赋值为 2<br>线程B： 希望给 N 赋值为 2<br>线程C： 希望给 N 赋值为 1​​<br>此时线程A和线程B同时获取到N的值1，线程A率先得到系统资源，将 N 赋值为 2，线程 B 由于某种原因被阻塞住，线程C在线程A执行完后得到 N 的当前值2<br>此时的线程状态<br>线程A成功给 N 赋值为2<br>线程B获取到 N 的当前值 1 希望给他赋值为 2，处于阻塞状态<br>线程C获取当好 N 的当前值 2 ​​​​​希望给他赋值为1<br>​​<br>然后线程C成功给N赋值为1<br>​最后线程B得到了系统资源，又重新恢复了运行状态，​在阻塞之前线程B获取到的N的值是1，执行compare操作发现当前N的值与获取到的值相同（均为1），成功将N赋值为了2。<br>​<br>在这个过程中线程B获取到N的值是一个旧值​​，虽然和当前N的值相等，但是实际上N的值已经经历了一次 1到2到1的改变<br>上面这个例子就是典型的ABA问题​<br>怎样去解决ABA问题<br>给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。Java中AtomicStampedReference 就解决了这个问题</li>
<li>循环时间长开销大<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
</ul>
<blockquote>
<p>CAS只能保证一个共享变量的原子操作</p>
</blockquote>
<h3 id="8-AbstractQueuedSynchronizer-AQS"><a href="#8-AbstractQueuedSynchronizer-AQS" class="headerlink" title="8. AbstractQueuedSynchronizer(AQS)"></a>8. AbstractQueuedSynchronizer(AQS)</h3><p>AQS抽象的队列式同步器，是一种基于状态（state）的链表管理方式。state 是用CAS去修改的。它是 java.util.concurrent 包中最重要的基石，要学习想学习 java.util.concurrent 包里的内容这个类是关键。 ReentrantLock​、CountDownLatcher、Semaphore 实现的原理就是基于AQS。想知道他怎么实现以及实现原理 可以参看这篇文章<a href="https://link.jianshu.com/?t=https%3A%2F%2Fwww.cnblogs.com%2Fwaterystone%2Fp%2F4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>
<h3 id="9-Future"><a href="#9-Future" class="headerlink" title="9. Future"></a>9. Future</h3><p>在并发编程我们一般使用Runable去执行异步任务，然而这样做我们是不能拿到异步任务的返回值的，但是使用Future 就可以。使用Future很简单，只需把Runable换成FutureTask即可。使用上比较简单，这里不多做介绍。</p>
<h3 id="10-线程池"><a href="#10-线程池" class="headerlink" title="10. 线程池"></a>10. 线程池</h3><blockquote>
<p>如果我们使用线程的时候就去创建一个线程，虽然简单，但是存在很大的问题。如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程池通过复用可以大大减少线程频繁创建与销毁带来的性能上的损耗。</p>
</blockquote>
<p>Java中线程池的实现类 ThreadPoolExecutor，其构造函数的每一个参数的含义在注释上已经写得很清楚了，这里几个关键参数可以再简单说一下</p>
<ul>
<li>corePoolSize ：核心线程数即一直保留在线程池中的线程数量，即使处于闲置状态也不会被销毁。要设置 allowCoreThreadTimeOut 为 true，才会被销毁。</li>
<li>maximumPoolSize：线程池中允许存在的最大线程数</li>
<li>keepAliveTime ：非核心线程允许的最大闲置时间，超过这个时间就会本地销毁。</li>
<li>workQueue：用来存放任务的队列。<ul>
<li>SynchronousQueue：这个队列会让新添加的任务立即得到执行，如果线程池中所有的线程都在执行，那么就会去创建一个新的线程去执行这个任务。当使用这个队列的时候，maximumPoolSizes一般都会设置一个最大值 Integer.MAX_VALUE</li>
<li>LinkedBlockingQueue：这个队列是一个无界队列。怎么理解呢，就是有多少任务来我们就会执行多少任务，如果线程池中的线程小于corePoolSize ,我们就会创建一个新的线程去执行这个任务，如果线程池中的线程数等于corePoolSize，就会将任务放入队列中等待，由于队列大小没有限制所以也被称为无界队列。当使用这个队列的时候 maximumPoolSizes 不生效（线程池中线程的数量不会超过corePoolSize），所以一般都会设置为0。</li>
<li>ArrayBlockingQueue：这个队列是一个有界队列。可以设置队列的最大容量。当线程池中线程数大于或者等于 maximumPoolSizes 的时候，就会把任务放到这个队列中，当当前队列中的任务大于队列的最大容量就会丢弃掉该任务交由 RejectedExecutionHandler 处理。</li>
</ul>
</li>
</ul>
<p>最后，本文主要对Java并发编程开发需要的知识点作了简单的讲解，这里每一个知识点都可以用一篇文章去讲解，由于篇幅原因不能对每一个知识点都详细介绍，我相信通过本文你会对Java的并发编程会有更近一步的了解。如果您发现还有缺漏或者有错误的地方，可以在评论区补充，谢谢。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "15310-1577469423472-640",
			        "name": "黄小斜学Java",
			        "qrcode": "https://s2.ax1x.com/2019/12/28/le9CwT.jpg",
			        "keyword": "关键词"
			    });
			}
			</script>
		
        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/hxx.jpeg" alt="黄小斜学Java">
            
              <p class="site-author-name" itemprop="name">黄小斜学Java</p>
              <p class="site-description motion-element" itemprop="description">本博客后续不再维护更新，新的文章内容请移步我的微信公众号【程序员黄小斜】阅读。 目前专注分享Java领域干货，不限于BAT面试，算法、计算机基础、数据库、分布式、spring全家桶、微服务、高并发、JVM、Docker容器，ELK、大数据等相关知识，希望我们可以一起进步。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">160</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/h2pl" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/a724888" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/9ab8d7b38c4e" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/h2pl" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/a724888" title="CSDN博客" target="_blank">CSDN博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发基础和多线程"><span class="nav-number">1.</span> <span class="nav-text">并发基础和多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM内存模型"><span class="nav-number">2.</span> <span class="nav-text">JMM内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized，volatile，final等关键字"><span class="nav-number">3.</span> <span class="nav-text">synchronized，volatile，final等关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC包"><span class="nav-number">4.</span> <span class="nav-text">JUC包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实践"><span class="nav-number">5.</span> <span class="nav-text">实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">6.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-并发编程三要素"><span class="nav-number">6.1.</span> <span class="nav-text">1.并发编程三要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线程的五大状态"><span class="nav-number">6.2.</span> <span class="nav-text">2. 线程的五大状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-悲观锁与乐观锁"><span class="nav-number">6.3.</span> <span class="nav-text">3.悲观锁与乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-线程之间的协作"><span class="nav-number">6.4.</span> <span class="nav-text">4.线程之间的协作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-wait-notify-notifyAll"><span class="nav-number">6.4.1.</span> <span class="nav-text">4.1 wait/notify/notifyAll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-sleep-yield-join"><span class="nav-number">6.4.2.</span> <span class="nav-text">4.2 sleep/yield/join</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-valitate-关键字"><span class="nav-number">6.5.</span> <span class="nav-text">5.valitate 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-定义"><span class="nav-number">6.5.1.</span> <span class="nav-text">5.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-原理"><span class="nav-number">6.5.2.</span> <span class="nav-text">5.2 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-作用"><span class="nav-number">6.5.3.</span> <span class="nav-text">5.3 作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-synchronized-关键字"><span class="nav-number">6.6.</span> <span class="nav-text">6. synchronized 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-定义"><span class="nav-number">6.6.1.</span> <span class="nav-text">6.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-原理"><span class="nav-number">6.6.2.</span> <span class="nav-text">6.2 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-关于使用"><span class="nav-number">6.6.3.</span> <span class="nav-text">6.3 关于使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-缺点"><span class="nav-number">6.6.4.</span> <span class="nav-text">6.4 缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-CAS"><span class="nav-number">6.7.</span> <span class="nav-text">7. CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-什么是CAS"><span class="nav-number">6.7.1.</span> <span class="nav-text">7.1 什么是CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-为什么会有CAS"><span class="nav-number">6.7.2.</span> <span class="nav-text">7.2 为什么会有CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-实现原理"><span class="nav-number">6.7.3.</span> <span class="nav-text">7.3 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-存在的问题"><span class="nav-number">6.7.4.</span> <span class="nav-text">7.4 存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-AbstractQueuedSynchronizer-AQS"><span class="nav-number">6.8.</span> <span class="nav-text">8. AbstractQueuedSynchronizer(AQS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Future"><span class="nav-number">6.9.</span> <span class="nav-text">9. Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-线程池"><span class="nav-number">6.10.</span> <span class="nav-text">10. 线程池</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">©2018 by 黄小斜,程序员江湖</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'vR9M1gbfLTI6fXyVUdqbAajG-gzGzoHsz',
        appKey: 'kHXQgB5OhW5g5dvDAPOY6gvc',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
